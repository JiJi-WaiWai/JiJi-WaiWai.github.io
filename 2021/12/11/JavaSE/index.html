<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jiji-waiwai.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="JaveSE 这是一篇关于javaSE基础的笔记 其中包括java面向对象，java核心类库，java型特性和项目">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="https://jiji-waiwai.github.io/2021/12/11/JavaSE/index.html">
<meta property="og:site_name" content="De&#39;s Blog">
<meta property="og:description" content="JaveSE 这是一篇关于javaSE基础的笔记 其中包括java面向对象，java核心类库，java型特性和项目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/11/oTqXEq.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/12/oq9Xb6.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/31/TfqsJ0.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/31/TfqsJ0.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/31/TfqsJ0.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/31/TfqsJ0.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/31/TfqsJ0.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/18/7w6SW8.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/23/74xkgf.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/23/74xXin.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/29/HSA0TP.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/01/29/HSKQPI.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/05/Hme9fK.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/HgIISg.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/HgHfBj.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/Hgb4MD.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/HgqolT.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/HgO7dJ.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/HgjwDS.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/15/H2S8qf.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/03/05/b08ppd.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/03/05/b0GGrt.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/03/05/b0YRgJ.png">
<meta property="og:image" content="https://s4.ax1x.com/2022/03/05/b0Yq8e.png">
<meta property="article:published_time" content="2021-12-11T06:41:56.000Z">
<meta property="article:modified_time" content="2022-03-05T12:44:11.210Z">
<meta property="article:author" content="唧唧歪歪">
<meta property="article:tag" content="java">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2021/12/11/oTqXEq.png">


<link rel="canonical" href="https://jiji-waiwai.github.io/2021/12/11/JavaSE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jiji-waiwai.github.io/2021/12/11/JavaSE/","path":"2021/12/11/JavaSE/","title":"JavaSE"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaSE | De's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://GitHub.com/JiJi-WaiWai" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">De's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">Java面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">方法和封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.2.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">1.2.4.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.5.</span> <span class="nav-text">封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.</span> <span class="nav-text">static关键字和继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">构造块和静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%EF%BC%88Singleton%E7%B1%BB%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">单例设计模型（Singleton类）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.4.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">1.3.5.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E8%80%83%E7%82%B9"><span class="nav-number">1.3.6.</span> <span class="nav-text">构造块和静态代码块的考点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="nav-number">1.3.7.</span> <span class="nav-text">常用的访问控制符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package%E5%8C%85"><span class="nav-number">1.3.8.</span> <span class="nav-text">package包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.9.</span> <span class="nav-text">final关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%92%8C%E7%89%B9%E6%AE%8A%E7%B1%BB-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">多态和特殊类(抽象类,接口)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.1.</span> <span class="nav-text">多态特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">引用数据类型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">多态的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.4.4.</span> <span class="nav-text">抽象方法和抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.5.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">特殊类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">普通内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.5.2.</span> <span class="nav-text">枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">自定义枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">用enum定义枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enum%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Enum类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E9%87%8D%E5%86%99%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">枚举类重写接口方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.5.3.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">定义和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%84%E5%88%B6%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">常见的预制注解</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93-%E4%B8%8A"><span class="nav-number">2.</span> <span class="nav-text">Java核心类库(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">常用类的概述和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="nav-number">2.1.1.</span> <span class="nav-text">常用的包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">equals()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">hashCode()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString-NaN"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">toString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getClass"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">getClass()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">2.1.3.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">Integer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bouble"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">Bouble</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boolean"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">Boolean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Character"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">Character</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%A4%84%E7%90%86%E7%B1%BB"><span class="nav-number">2.1.4.</span> <span class="nav-text">数学处理类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigDecimal"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">BigDecimal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigInteger"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">BigInteger</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">String类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.1.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">常用构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">常用成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.2.4.</span> <span class="nav-text">正则表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">可变字符串类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder"><span class="nav-number">2.3.1.</span> <span class="nav-text">StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8%E4%BB%A5%E5%89%8D%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">Java8以前时间相关类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System%E7%B1%BB"><span class="nav-number">2.4.1.</span> <span class="nav-text">System类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date%E7%B1%BB"><span class="nav-number">2.4.2.</span> <span class="nav-text">Date类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SimpleDateFormat"><span class="nav-number">2.4.3.</span> <span class="nav-text">SimpleDateFormat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calendar"><span class="nav-number">2.4.4.</span> <span class="nav-text">Calendar</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8%E4%BB%A5%E5%90%8E%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">2.5.</span> <span class="nav-text">Java8以后时间相关类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalDate"><span class="nav-number">2.5.1.</span> <span class="nav-text">LocalDate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalTime"><span class="nav-number">2.5.2.</span> <span class="nav-text">LocalTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalDateTime"><span class="nav-number">2.5.3.</span> <span class="nav-text">LocalDateTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DateTimeFormatter"><span class="nav-number">2.5.4.</span> <span class="nav-text">DateTimeFormatter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Instant"><span class="nav-number">2.5.5.</span> <span class="nav-text">Instant</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%BA%93-%E4%B8%8A"><span class="nav-number">2.6.</span> <span class="nav-text">集合类库(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E9%9B%86%E5%90%88"><span class="nav-number">2.6.1.</span> <span class="nav-text">Collection集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.6.2.</span> <span class="nav-text">Iterator接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.6.3.</span> <span class="nav-text">for each循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E9%9B%86%E5%90%88"><span class="nav-number">2.6.4.</span> <span class="nav-text">List集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue%E9%9B%86%E5%90%88"><span class="nav-number">2.6.5.</span> <span class="nav-text">Queue集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%BA%93-%E4%B8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">集合类库(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.7.1.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">定义泛型接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">定义泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">定义泛型方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">通配符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E9%9B%86%E5%90%88"><span class="nav-number">2.7.2.</span> <span class="nav-text">Set集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">TreeSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E9%9B%86%E5%90%88"><span class="nav-number">2.7.3.</span> <span class="nav-text">Map集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections%E7%B1%BB"><span class="nav-number">2.7.4.</span> <span class="nav-text">Collections类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93-%E4%B8%8B"><span class="nav-number">3.</span> <span class="nav-text">Java核心类库(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.1.1.</span> <span class="nav-text">异常的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7"><span class="nav-number">3.1.2.</span> <span class="nav-text">异常的捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="nav-number">3.1.3.</span> <span class="nav-text">异常的抛出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">3.1.4.</span> <span class="nav-text">自定义异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">3.3.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB"><span class="nav-number">3.3.1.</span> <span class="nav-text">基本分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileWriter%E7%B1%BB"><span class="nav-number">3.3.3.</span> <span class="nav-text">FileWriter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileReader%E7%B1%BB"><span class="nav-number">3.3.4.</span> <span class="nav-text">FileReader类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileOutputStream%E7%B1%BB"><span class="nav-number">3.3.5.</span> <span class="nav-text">FileOutputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileInputStream%E7%B1%BB"><span class="nav-number">3.3.6.</span> <span class="nav-text">FileInputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferedOutputStream%E7%B1%BB"><span class="nav-number">3.3.7.</span> <span class="nav-text">BufferedOutputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferedInputStream%E7%B1%BB"><span class="nav-number">3.3.8.</span> <span class="nav-text">BufferedInputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferedWriter%E7%B1%BB"><span class="nav-number">3.3.9.</span> <span class="nav-text">BufferedWriter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferedReader%E7%B1%BB"><span class="nav-number">3.3.10.</span> <span class="nav-text">BufferedReader类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PrintStream%E7%B1%BB"><span class="nav-number">3.3.11.</span> <span class="nav-text">PrintStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PrintWriter%E7%B1%BB"><span class="nav-number">3.3.12.</span> <span class="nav-text">PrintWriter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutputStreamWriter%E7%B1%BB"><span class="nav-number">3.3.13.</span> <span class="nav-text">OutputStreamWriter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStreamReader%E7%B1%BB"><span class="nav-number">3.3.14.</span> <span class="nav-text">InputStreamReader类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-number">3.3.15.</span> <span class="nav-text">字符编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataOutputStream%E7%B1%BB"><span class="nav-number">3.3.16.</span> <span class="nav-text">DataOutputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataInputStream%E7%B1%BB"><span class="nav-number">3.3.17.</span> <span class="nav-text">DataInputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectOutputStream%E7%B1%BB"><span class="nav-number">3.3.18.</span> <span class="nav-text">ObjectOutputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectInputStream%E7%B1%BB"><span class="nav-number">3.3.19.</span> <span class="nav-text">ObjectInputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile%E7%B1%BB"><span class="nav-number">3.3.20.</span> <span class="nav-text">RandomAccessFile类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB"><span class="nav-number">3.4.1.</span> <span class="nav-text">Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.4.2.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="nav-number">3.4.3.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.4.</span> <span class="nav-text">线程同步机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">3.4.5.</span> <span class="nav-text">线程之间的通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.4.6.</span> <span class="nav-text">生产者和消费者模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.7.</span> <span class="nav-text">Callable接口创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">3.4.8.</span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%AF%86"><span class="nav-number">3.5.1.</span> <span class="nav-text">网络常识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">TCP协议的编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-S%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">C&#x2F;S架构介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">编程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">相关类和方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.5.3.</span> <span class="nav-text">UDP协议的编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">编程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95-1"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">相关类和方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL%E7%B1%BB"><span class="nav-number">3.5.4.</span> <span class="nav-text">URL类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">3.6.</span> <span class="nav-text">反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E7%B1%BB"><span class="nav-number">3.6.1.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor"><span class="nav-number">3.6.2.</span> <span class="nav-text">Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Field%E7%B1%BB"><span class="nav-number">3.6.3.</span> <span class="nav-text">Field类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method%E7%B1%BB"><span class="nav-number">3.6.4.</span> <span class="nav-text">Method类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="nav-number">3.6.5.</span> <span class="nav-text">其他结构信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.7.</span> <span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.7.1.</span> <span class="nav-text">静态代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-1"><span class="nav-number">3.7.2.</span> <span class="nav-text">动态代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">常用设计原则和设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">4.1.</span> <span class="nav-text">常用设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">常用设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">单例设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.4.</span> <span class="nav-text">装饰器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.5.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.6.</span> <span class="nav-text">模板方法模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">Java新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">Java8新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.1.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda"><span class="nav-number">5.1.2.</span> <span class="nav-text">lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.3.</span> <span class="nav-text">引用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.4.</span> <span class="nav-text">Stream接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">创建操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">中间操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.4.3.</span> <span class="nav-text">终止操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional%E7%B1%BB"><span class="nav-number">5.1.5.</span> <span class="nav-text">Optional类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">Java9新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java10%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">Java10新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.4.</span> <span class="nav-text">Java11新特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">在线考试系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO"><span class="nav-number">7.</span> <span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">7.1.</span> <span class="nav-text">核心组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="nav-number">7.2.</span> <span class="nav-text">Buffer缓存区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBuffer%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">ByteBuffer的创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="nav-number">7.2.2.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%98%E9%87%8F"><span class="nav-number">7.2.3.</span> <span class="nav-text">核心变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel%E9%80%9A%E9%81%93"><span class="nav-number">7.3.</span> <span class="nav-text">Channel通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.3.1.</span> <span class="nav-text">Channel接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileChannel%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.2.</span> <span class="nav-text">FileChannel的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ETCP%E7%BC%96%E7%A8%8B"><span class="nav-number">7.3.3.</span> <span class="nav-text">基于TCP编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">7.4.</span> <span class="nav-text">Selector选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel%E6%B3%A8%E5%86%8C%E5%88%B0Selector%E4%B8%8A"><span class="nav-number">7.4.1.</span> <span class="nav-text">Channel注册到Selector上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E9%94%AESelectionKey"><span class="nav-number">7.4.2.</span> <span class="nav-text">选择键SelectionKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E6%9F%A5%E8%AF%A2%E5%B0%B1%E7%BB%AA%E6%93%8D%E4%BD%9C"><span class="nav-number">7.4.3.</span> <span class="nav-text">轮询查询就绪操作</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="唧唧歪歪"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">唧唧歪歪</p>
  <div class="site-description" itemprop="description">踏上新征程----go！！！</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JiJi-WaiWai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiJi-WaiWai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1753645532@qq.com" title="E-Mail → mailto:1753645532@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://tool.gljlw.com/qq/?qq=1753645532" title="http:&#x2F;&#x2F;tool.gljlw.com&#x2F;qq&#x2F;?qq&#x3D;1753645532" rel="noopener" target="_blank">加qq</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiji-waiwai.github.io/2021/12/11/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="唧唧歪歪">
      <meta itemprop="description" content="踏上新征程----go！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="De's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-11 14:41:56" itemprop="dateCreated datePublished" datetime="2021-12-11T14:41:56+08:00">2021-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-05 20:44:11" itemprop="dateModified" datetime="2022-03-05T20:44:11+08:00">2022-03-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jave/" itemprop="url" rel="index"><span itemprop="name">jave</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>JaveSE</p>
<p>这是一篇关于javaSE基础的笔记</p>
<p>其中包括java面向对象，java核心类库，java型特性和项目</p>
<span id="more"></span>

<h1 id="Java面向对象编程"><a href="#Java面向对象编程" class="headerlink" title="Java面向对象编程"></a>Java面向对象编程</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>定义类：class 类名{ 类体 }。<br><code>class Person&#123;&#125;</code></p>
<p>创建对象：new 类名();<br><code>Person p = new Person();</code></p>
<p>成员变量的定义：数据类型 变量名 = 初始值;<br><code>int age;</code></p>
<p>成员方法的定义：返回值类型 方法名（参数）{ 方法体 }<br><code>void setAge(int age)&#123; &#125;</code></p>
<p>成员方法的可变长参数，即该参数长度是0~~n个，最多定义一个，而且放在最后一个参数。使用时，相当于一维数组。<br>可变长参数定义<code>void xiaoName(String... args)&#123; &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;, 今年&quot;</span> + age + <span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">xiaoName</span><span class="params">(String... args)</span><span class="comment">/*可变参数*/</span> </span>&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个参数是：&quot;</span> + args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建Person类型引用指向Person类型对象</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.setName(<span class="string">&quot;李&quot;</span>);</span><br><span class="line">		p.age = <span class="number">18</span>;</span><br><span class="line">		p.show();</span><br><span class="line">		p.xiaoName(<span class="string">&quot;德&quot;</span>, <span class="string">&quot;昭的&quot;</span>, <span class="string">&quot;得得&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>1）基本数据类型：byte、short、char、int、long、float、double、boolean 八个。</p>
<p>这些基本数据类型定义变量时，内存中的栈区会申请一个存储单元用来存储数据。</p>
<p>如 int a = 10;  内存中的栈区申请一个名为a的存储单元，大小为4个字节，里面存放着数据10。</p>
<p>2）引用数据类型：数组、类、接口、枚举、标注</p>
<p>用引用数据类型（数组、类、接口、枚举、标注）定义的变量叫做引用型变量，简称<strong>引用</strong>。如<code>Person p</code></p>
<p>引用数据类型在定义时，如<code>Person p = new Person();</code> ，内存中的栈区申请一个名为p的存储单元，用来存放地址。而new Person()这部分存放在内存中的堆区，有数据。假设new Person()在堆区中的地址是0x10，而p中存放的就是这个地址0x10。</p>
<p>如图，变量a为int类型，在栈区中存放的是数据10。引用型变量（引用）p为Person类型（类），在栈区中存放的是一个地址（0x10），该地址指向堆区中的new Person()，而new Person()中才有数据。</p>
<p>基本数据类型变量中存放的是数据，而引用数据类型变量中存放的是地址。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oTqXEq"><img src="https://s4.ax1x.com/2021/12/11/oTqXEq.png" alt="oTqXEq.png" border="0" /></a></p>
<p><strong>注意</strong>：</p>
<p>基本数据类型的变量，作为方法的参数传递时，形参不会影响到实参，因为这两个变量存放的是各自的数据，虽然数据一样。</p>
<p>引用数据类型的变量，作为方法的参数传递时，形参可能会影响到实参，因为这两个变量存放的是同一个地址。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>其实创建对象是<code>new Person();</code>,此时内存堆区会申请一块空间存放对象，但是由于没有引用型变量（引用）指向该对象的地址，就会被当作垃圾回收。所以创建对象时使用<code>Person p = new Person();</code>,含义是“创建Person类型引用p指向Person类型对象”。引用型变量p存放着对象的地址，因此不会被回收。</p>
<h2 id="方法和封装"><a href="#方法和封装" class="headerlink" title="方法和封装"></a>方法和封装</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>使用new关键字创建对象时，会自动调用构造方法。一般用于对象的初始化工作</p>
<p>定义：</p>
<ul>
<li><p>不用写返回值类型</p>
</li>
<li><p>构造方法名和类名一致</p>
</li>
</ul>
<p>当用户没有定义构造方法时，系统会默认定义一个无参无内容的构造方法，如Person类，<code>Person()&#123;&#125;</code></p>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>重载：方法名可以相同，但是参数个数，或类型，或顺序不一样。</p>
<p>例如：一般我们定义构造方法时，会定义一个有参的构造方法，同时再定义一个无参的构造方法，这就属于重载。</p>
<p>意义：调用用一个方法名，参数不一样可以实现不同的功能。例如println()方法，调用该方法我们传参可以是多种数据类型，但是依然可以打印出来，是因为官方写好了许多个println()同名不同参数方法。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>在类中使用this关键字表示，创建的该对象本身。</p>
<p>用法：</p>
<ul>
<li>this.成员变量、this.成员方法：当成员变量和局部变量重名时，系统会就近原则。变量前加上this.前缀，就表明是成员变量。（成员方法相同）</li>
<li>this还可以当作返回值，表示该对象本身。返回值类型就是该类名的类型。</li>
<li><code>this();</code>用在构造方法的第一行，可以调用本类的其他构造方法</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归：定义 方法时，该方法会调用该方法自己</p>
<p>例如：计算费氏数列：1，1，2，3，5，8，13，21，第一项和第二项是1，之后的每一项的前两项和。下面分别使用递归和递推(循环)实现。传入第n项，返回第n项的数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FengShi</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">diGui</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//用递归的方法计算</span></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n ==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> diGui(n-<span class="number">1</span>) + diGui(n-<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">diTui</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//用递推的方法计算</span></span><br><span class="line">		<span class="keyword">int</span> ia = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ib = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ic;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			ic = ia + ib;</span><br><span class="line">			ia = ib;</span><br><span class="line">			ib = ic;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ib;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，使用递归代码简单明了，而递推复杂。但是递归代码的执行速度慢许多。</p>
<p><strong>递归注意事项</strong></p>
<ul>
<li>使用递归必须有递归规律以及退出条件</li>
<li>使用递归是把问题变得简单化而不是复杂化</li>
<li>若递归影响到程序的执行性能，则不推荐。建议使用递推取代之。</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常情况下测试类给成员变量赋值一些合法但不合理的数值，程序不会报错，但是与现实不符。例如age赋值负数等。</p>
<p>为避免这一现象，需要对成员变量进行密封包装处理，保证成员变量的合理性，该机制就叫封装。</p>
<p>步骤：</p>
<ul>
<li><p>私有化成员变量，用private关键字修饰。如<code>private int age;</code></p>
</li>
<li><p>提供公有的set和get成员方法来访问成员变量，在方法中对合理值进行判断</p>
</li>
<li><p>构造方法中也调用set方法进行合理值判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1,私有化成员变量。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3,构造方法也调用成员方法来初始化成员变量。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		setAge(age);</span><br><span class="line">		setName(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2,提供我们写成员方法来访问成员变量，成员方法会判断参数是否正确。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;age不能小于0岁。&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义show()来打印对象的特征</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>案例</strong></em>：使用上面定义的类完成。提示用户输入人数，然后输入学生信息：姓名，年龄，最后打印出来。</p>
<p>提示：Student[] arr = new Student[num];</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入学生人数：&quot;</span>);</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">		<span class="comment">//根据输入的人数，创建Student引用类型的一维数组</span></span><br><span class="line">		Student[] arr = <span class="keyword">new</span> Student[num];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入name和age：&quot;</span>);</span><br><span class="line">			arr[i] = <span class="keyword">new</span> Student(sc.next(), sc.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">			arr[i].show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student[] arr = new Student[num];</code>，表示创建一个一维数组，数组类型是自己定义的Student引用类型。数组中的每个元素都是Student引用类型变量，里面存放的只是地址，指向后面创建的对象。如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oq9Xb6"><img src="https://s4.ax1x.com/2021/12/12/oq9Xb6.png" alt="oq9Xb6.png" border="0" /></a></p>
<h2 id="static关键字和继承"><a href="#static关键字和继承" class="headerlink" title="static关键字和继承"></a>static关键字和继承</h2><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>在类中正常定义的成员方法或变量隶属于<strong>对象层级</strong>，即创建对象时才拥有。且每个对象独有一份，互不影响，需要通过 <code>引用.成员</code> 的方式调用。</p>
<p>在定义成员时，加上static关键字修饰，就变成了静态成员，由原来的<strong>对象层级</strong>上升为<strong>类层级</strong>。即加载该类时就出现了，跟创不创建对象没有关系。类拥有一份，且被所有实例对象共享该同一份。不仅可通过 <code>引用.成员</code> 调用，还可以 <code>类名.成员</code> 调用。推荐 <code>类名.成员</code> 调用。</p>
<p><strong>static修饰成员变量</strong></p>
<p>例如：<code>public static String country;</code></p>
<p>变量由对象层级上升为类层级，叫做静态变量或者类变量。类和对象共享同一份该变量，所以一个改变该对象值，大家都跟着改变。不仅可通过 <code>引用.变量</code> 调用，还可以 <code>类名.变量</code> 调用。</p>
<p><strong>staitc修饰成员方法</strong></p>
<p>例如：<code>public static void show(参数) &#123;方法体&#125;</code></p>
<p>方法由对象层级上升为类层级，叫做静态方法或者类方法。不仅可通过 <code>引用.方法</code> 调用，还可以 <code>类名.方法</code> 调用。</p>
<p>由于方法是static修饰，属于类层级，所以在加载类时就已经被加载了，跟创建不创建对象无关。<br>而非静态的成员属于对象层级，必须要在创建对象后才出现。<br>所以在静态方法中只能访问静态成员，不可以访问非静态的成员，也不可以出现this之类跟对象有关的关键字（因为对象可能还没被创建）。</p>
<p>非静态方法即能访问非静态成员又可以访问静态成员。</p>
<p><strong>注意</strong>：</p>
<p>在开发中只有隶属于类层级并被所有对象共享的内容才可以使用static关键字修饰。（不能滥用static关键字）</p>
<h3 id="构造块和静态代码块"><a href="#构造块和静态代码块" class="headerlink" title="构造块和静态代码块"></a>构造块和静态代码块</h3><p>构造块：在类中直接大括号{}括起来的代码叫构造快，在每次创建对象时，构造方法之前执行。</p>
<p>静态代码块：在构造快前面加上static关键字。当类被加载时立马执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态代码块</span></span><br><span class="line">    <span class="comment">//需要在执行代码块之前随着类的加载做一些准备工作，比如，加载数据库的驱动包等。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//构造块。</span></span><br><span class="line">    <span class="comment">//需要在执行构造方法体之前做一些准备工作，比如，对成员变量经行统一初始化操作。</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是构造块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：当该类被加载时，就会立马调用一次”静态代码块“。此后，每次创建一个对象都会调用”构造块“，接着再调用”构造方法“。</p>
<h3 id="单例设计模型（Singleton类）"><a href="#单例设计模型（Singleton类）" class="headerlink" title="单例设计模型（Singleton类）"></a>单例设计模型（Singleton类）</h3><p>编程实现Singleton类，并且该类只能创建一个对象。</p>
<p>如下：</p>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//饿汉式，创建了引用 s 立马创建对象并指向，推荐</span></span><br><span class="line">    <span class="comment">//2,声明本类类型的引用指向本类类型的对象，配合private，static。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="comment">//1,私有化构造方法(private)，使得外面不能直接通过&quot;new 类名();&quot;的方式创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3,提供公有的get方法将类中定义的对象返回出去，配合public，static。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//懒汉式，创建了引用 s 并没有初始化,而是在后面方法里初始化。</span></span><br><span class="line">    <span class="comment">//2,声明本类类型的引用指向暂时为null，配合private，static。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">//1,私有化构造方法(private)，使得外面不能直接通过&quot;new 类名();&quot;的方式创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//3,提供公有的get方法将类中定义的对象返回出去，配合public，static。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">			s = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，可以外面只可以通过提供的共有的静态方法getSingleton()，即 <code>类名.静态方法（）</code> 的方法得到该类创建的对象。并且无论调用多少次方法，得到的都是同一个对象。</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Singleton s1 = Singleton.getSingleton();</span><br><span class="line">        Singleton s2 = Singleton.getSingleton();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1 = &quot;</span> + s1);   <span class="comment">/*s1 = org.de.test_3.Singleton@312b1dae*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s2 = &quot;</span> + s2);   <span class="comment">/*s2 = org.de.test_3.Singleton@312b1dae*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p>当Singleton类被加载时，静态变量<code>private static Singleton s = new Singleton();</code>就被加载，栈区创建引用s指向堆区创建的对象。执行静态方法<code>getSingleton()</code>，返回引用s。即返回堆区对象的地址。而无论调用多少次<code>getSingleton()</code>方法，返回的都是同一个地址，即同一个对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>例如定义教师类、定义工人类、学生类等等，这些类都有些共同的特征，比如它们都有人的特征。每个类都重新定义有关人的特征的话，重复代码严重。所以可以定义一个人类，而这些类都继承人类。</p>
<p>使用extends关键字表示继承关系，例如：<code>public class Teach extends People&#123;&#125;</code><br>Teach类继承People类。其中<br>Person类叫做父类，超类，基类<br>Teach类叫做子类，派生类，孩子类<br>Teach类继承People类后，就可以继承People类的成员方法和变量。</p>
<p>意义：使用继承提高了代码的复用性，可维护性及扩展性，是多态的前提条件</p>
<p>继承的特点：</p>
<ul>
<li>子类不能继承父类的构造方法和私有方法，但私有成员变量可以被继承，只是不能直接访问</li>
<li>无论调用何种方法创建子类对象是都会调用父类的无参构造方法，来初始化从父类继承的成员变量，相当于在子类的构造方法的第一行增加代码super()的效果。</li>
<li>使用继承必须满足逻辑关系：子类 is a 父类，例如老师 是 一个 人。也就是继承不能滥用。</li>
<li>java语言只支持单继承。一个子类只能有一个父类，但一个父类可以有多个子类。</li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>从父类中继承下来的方法不满足子类的需求时，就需要在子类中重写一个新的和父类一样名字的方法，来覆盖从父类中继承下来的版本。该方式叫做方法的重写( Override )。</p>
<p>重写方法时，可以在方法上一行写<code>@Override</code>，有助于帮助我们检查该方法是不是重写。</p>
<p>重写原则：</p>
<ul>
<li>方法名相同、参数列表相同、返回值类型相同，从java5开始允许返回子类类型</li>
<li>方法的访问权限不能变小，可以相同或变大。</li>
<li>方法不能抛出更大的异常（异常机制）。</li>
</ul>
<p><strong>代码演示：</strong></p>
<p>封装了一个Animal类，有age、name私有变量，show()打印特征的成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        setAge(age);</span><br><span class="line">        setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是动物，我叫&quot;</span> + getName() + <span class="string">&quot;，今年&quot;</span> + getAge() + <span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装了一个Dog类，该类继承了Animal类。该类有tooth私有变量，还重写了父类的show()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tooth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">int</span> tooth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name);</span><br><span class="line">        setTooth(tooth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTooth</span><span class="params">(<span class="keyword">int</span> tooth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tooth = tooth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTooth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tooth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是狗狗有&quot;</span> + getTooth() +<span class="string">&quot;颗牙齿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装了一个Cat类，该类继承了Animal类。该类有color私有变量，还重写了父类的show()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> age, String name, String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name);</span><br><span class="line">        setColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是猫，我的颜色是&quot;</span> + getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造块和静态代码块的考点"><a href="#构造块和静态代码块的考点" class="headerlink" title="构造块和静态代码块的考点"></a>构造块和静态代码块的考点</h3><p>假设：父类有构造方法，构造块，静态代码块。子类继承了父类，子类中也有构造方法，构造块，静态代码块。<br>问：  执行流程。</p>
<p>刚开始父类比子类先加载出来，所以先执行父类的静态代码块，再执行子类的静态代码块（一次）。<br>（由于创建子类对象一定会调用父类的构造方法怎么一说）<br>所以然后每次创建一个子类的对象时，都会先执行父类的构造块—–&gt;父类的构造方法——&gt;再执行子类的构造块—–&gt;子类的构造方法</p>
<h3 id="常用的访问控制符"><a href="#常用的访问控制符" class="headerlink" title="常用的访问控制符"></a>常用的访问控制符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一个包中的类</th>
<th>子类</th>
<th>其他类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
</tr>
<tr>
<td>protected</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不能访问</td>
</tr>
<tr>
<td>默认，即不写</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不能访问</td>
<td>不能访问</td>
</tr>
<tr>
<td>private</td>
<td>可以访问</td>
<td>不能访问</td>
<td>不能访问</td>
<td>不能访问</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>public修饰的成员可以在任意位置使用</li>
<li>private修饰的成员只能在本类内部使用</li>
<li>通常情况下，没有特殊要求，成员方法用public修饰，成员变量用private修饰。</li>
</ul>
<h3 id="package包"><a href="#package包" class="headerlink" title="package包"></a>package包</h3><p>定义类需要指定类名，仅仅将类名作为类的唯一标识，会出现命名冲突的问题。<br>java用包（package）的概念解决该问题</p>
<ul>
<li><p>定义类的时，还需要指定一个包，例如：<br>package 包名;<br>package 包名1.包名2.包名3…..包名n;</p>
</li>
<li><p>为实现项目管理、解决命名冲突以及权限控制的效果</p>
</li>
</ul>
<p>定义包规范：<br>例如：org.apache.commons.lang.StringUtil<br>其中StringUtil是类名，而org.apache.commons.lang是多层包名，含义：<br>org.apache表示公司或组织的信息，<br>commons表示项目的名称信息，<br>lang表示模块的名称信息。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final表示最终的、不可改变的。可以修饰类，成员方法和成员变量。</p>
<ul>
<li>final关键字修饰类，表示该类不能被继承。<br>主要用于防止滥用继承，如：java.lang.String类等。</li>
<li>final关键字修饰成员方法，表示该方法不能被重写，但可以被继承。<br>主要用于防止不经意间造成重写，如java.text.Dateformat类中的format方法等。</li>
<li>final关键字修饰成员变量，表示该变量必须初始化且不能被改变了。<br>初始化的三种方式：定义时直接加等于号“=”初始化，在构造方法中初始化，在构造块中初始化。<br>主要用于防止不经意间造成改写，如java.lang.Thread类中的MAX_PRIORITY等。</li>
</ul>
<p><strong>常量</strong>：</p>
<p>用final关键字修饰的成员变量一般叫做常量。<br>但是通常不会单独使用final关键字修饰，会配合public static final关键字一起修饰来表达常量的含义。<br>常量的命名规范：所有字母要大写，不同单词之间用下划线连接。</p>
<h2 id="多态和特殊类-抽象类-接口"><a href="#多态和特殊类-抽象类-接口" class="headerlink" title="多态和特殊类(抽象类,接口)"></a>多态和特殊类(抽象类,接口)</h2><p>多态是指同一种事物表现出来的多种形态</p>
<p>饮料：可乐、雪碧、红牛、旺仔·····<br>宠物：猫、狗、鱼······<br>人：学生、老师、工人、警察······</p>
<p>多态语法格式：<br><code>父类类型 引用变量名 = new 子类类型();</code><br>声明父类类型的引用指向子类类型对象。</p>
<p>如：创建了Animal类。再创建Dog类，其中Dog类继承Animal类。再创建Cat类，其中Cat类继承Animal类。<br>多态：<code>Animal a1 = new Dog();</code>  或 <code>Animal a2 = new Cat();</code></p>
<p>其实，父类引用指向子类对象的形式就叫做多态。</p>
<h3 id="多态特点"><a href="#多态特点" class="headerlink" title="多态特点"></a>多态特点</h3><ul>
<li>当父类类型的引用指向子类类型的对象时(多态)，父类类型的引用可以直接调用父类独有的方法</li>
<li>当父类类型的引用指向子类类型的对象时(多态)，父类类型的引用不能直接调用子类独有的方法。（强制类型转换成子类就可以解决）</li>
<li>对与父类和子类都有的非静态方法来说(重写)，编译阶段调用父类版本，运行阶段调用子类重写的版本。</li>
<li>对于父类和子类都有的静态方法来说，编译和运行阶段都调用父类版本。（因为静态成员跟创建不创建对象无关，所以和子类无关）</li>
</ul>
<h3 id="引用数据类型的转换"><a href="#引用数据类型的转换" class="headerlink" title="引用数据类型的转换"></a>引用数据类型的转换</h3><p>父类类型可以理解为较大的类型，子类类型可以理解为较小的类型。<br>引用数据类型的转换方式有：自动类型转换、强制类型转换<br>转换方法跟基本数据类型相似。</p>
<ul>
<li>自动类型转换：指小类型转换成大类型，即子类转父类，也叫向上转型。比如多态的语法格式：Animal a = new Dog();</li>
<li>强制类型转换：指大类型转换成小类型，即父类转子类，也叫向下转换。比如：将上面的Animal a转换一下成Dog类型，Dog d = (Dog) a;</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>引用数据类型的转换必须发生再父子类之间，否则编译报错</li>
<li>若强制转换的目标不是该引用真正指向的数据类型时，编译通过，但是运行异常。ClassCastException类型转换异常。案例如下：</li>
</ul>
<p>例如，有Animal类作为父类，有Dog类和Cat类都继承Animal类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line"> <span class="comment">//该代码在运行报错，ClassCastException类型转换异常</span></span><br><span class="line">Cat c = (Cat)a;   </span><br><span class="line">Dog d = (Dog)a;  <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>如上，a虽然是Animal类型，但是真正意义上却是Dog类型。所以即使通过强制转换也不能转换成Cat类型。</p>
<p>为了避免上述错误发生，应该在强制转之前进行判断，借助instanceof，格式：<br>if(引用变量 instanceof 数据类型){ 为真时执行 }</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;可以放心强制转换&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;不可以转换哦&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>例如，有Animal类作为父类，有Dog类和Cat类都继承Animal类。<br>要求：1，自定义方法实现，将参数指定的Dog对象的特征打印出来。<br>            2，自定义方法实现，将参数指定的Cat对象的特征打印出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//要求1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Dog d)</span></span>&#123;</span><br><span class="line">        d.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要求2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Cat c)</span> </span>&#123;</span><br><span class="line">        c.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试，调用</span></span><br><span class="line">        Test2.test(<span class="keyword">new</span> Dog(<span class="number">18</span>, <span class="string">&quot;WangCai&quot;</span>, <span class="number">27</span>));</span><br><span class="line">        Test2.test(<span class="keyword">new</span> Cat(<span class="number">10</span>, <span class="string">&quot;Baozi&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，Animal类中只有两个子类Dog和Cat。假如有n个子类，这类要求也是n个。代码冗余严重。<br>借助多态，可以完美解决该问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//形参是父类类型的引用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal a)</span> </span>&#123; </span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">        Test2.test(<span class="keyword">new</span> Animal());</span><br><span class="line">        <span class="comment">//实参是子类类型的对象。</span></span><br><span class="line">        Test2.test(<span class="keyword">new</span> Dog(<span class="number">18</span>, <span class="string">&quot;WangCai&quot;</span>, <span class="number">27</span>));</span><br><span class="line">        Test2.test(<span class="keyword">new</span> Cat(<span class="number">10</span>, <span class="string">&quot;Baozi&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态的使用场合之一：通过传参的方法，实现多态。形参是父类类型的引用，实参是子类类型的对象。</p>
<p><strong>多态使用场合：</strong></p>
<ul>
<li>通过方法的参数传递形成多态；<br>形参是父类类型引用，实参是子类类型对象。</li>
<li>在方法体中直接使用多态的语法格式；<br>父类类型 引用变量名 = new 子类类型();</li>
<li>通过方法的返回值类型形成多态<br>定义方法的返回值类型是父类类型，但是return后面真实返回的是子类对象。</li>
</ul>
<h3 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h3><p>抽象方法：在定义方法时，加上abstract关键字。抽象方法没有方法体。如：<br><code> public abstract void show(参数);</code></p>
<p>抽象类：在定义时，加上abstract关键字。如：<br><code>public abstract class 类名&#123; 类体 &#125;</code></p>
<ul>
<li>抽象方法一定要定义在抽象类中。</li>
<li>抽象类中可以有或着没有，成员变量，成员方法，构造方法，抽象方法等。</li>
<li>抽象类不可以实例化对象（万一实例化了对象，而对象又调用了没有方法体的抽象方法怎么办！！）。</li>
</ul>
<p><strong>意义</strong></p>
<ul>
<li>抽象类的实际意义不在于创建对象，而在与被继承。</li>
<li>并且继承了抽象类的子类，必须重写抽象类的所有抽象方法，否者也定义成抽象类。<br>也就是说，抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>
</ul>
<p><strong>注意</strong>：</p>
<p>虽然只要是满足abstract关键字修饰的类是抽象类，但是真正意义上的抽象类还应该有抽象方法。</p>
<p><strong>案例</strong>：银行有 定期账户 和 活期账户 ，都继承自 账户类。</p>
<p>定义 账户类Account，该类定义成抽象类，获取利息的方法也定义成抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        setMoney(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取利息的抽象方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getLiXing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义定期账户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingQiAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DingQiAccount</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLiXing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMoney() * <span class="number">0.03</span> * <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义活期账户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuoQiAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuoQiAccount</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLiXing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMoney() * <span class="number">0.01</span> * <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多态场景之一</span></span><br><span class="line">        Account a = <span class="keyword">new</span> <span class="comment">/*DingQi*/</span>HuoQiAccount(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;利息是&quot;</span> + a.getLiXing() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>考点</strong></p>
<p>abstract关键字不能和private、static、final关键字一起使用。原因：</p>
<ul>
<li>abstract 和 private： private是私有的，子类访问不到，就更不用说重写了。而abstract就是需要重写，互相矛盾。</li>
<li>abstract 和 static：用static修饰的方法隶属于类层级，可以用“类名.方法”来调用，而此时抽象方法没有方法体，错误。</li>
<li>abstract 和 final：final修饰的方法表示不能被重写，而abstract就是需要重写，互相矛盾。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是一种比抽象类还抽象的类。体现接口中在只有常量和抽象方法。</p>
<p>定义时接口时，把class关键字改成interface。如<code>public interface 接口名&#123; 接口体 &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口只有常量和抽象方法（型特性除外）,注释中的关键字可以省略。</span></span><br><span class="line">    <span class="comment">/*public static final*/</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//常量</span></span><br><span class="line">    <span class="comment">/*public abstract*/</span> <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;    <span class="comment">//抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8版本之后的新特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;    <span class="comment">//非抽象方法，子类自由选择重写不重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;     <span class="comment">//静态方法，子类不能重写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//9版本的新特性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show4</span><span class="params">()</span></span>&#123;&#125;           <span class="comment">//私有方法，子类不能重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，接口只有常量和抽象方法。但是Java8版本之后的新特性可以有非抽象方法，静态方法；Java9版本的新特性可以有私有方法。</p>
<p><strong>意义</strong></p>
<p>接口出现可以弥补Java中类不能多继承的不足。</p>
<p>例如：黄金即属于金属，又属于货币。如果用类描述关系的话，很难描述。而接口可以。<br>定义金属接口，定义货币接口，再定义黄金类。黄金类继承金属接口又继承货币接口。<br><em>注意</em>：类继承接口，叫做类实现接口，不用extends关键字，而用implements关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//金属接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Metal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//货币接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Money</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//黄金类Gold，实现(继承)了金属接口Metal和货币接口Money。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gold</span> <span class="keyword">implements</span> <span class="title">Metal</span>, <span class="title">Money</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>      <span class="comment">//重写金属接口Metal的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;黄金闪闪发光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>      <span class="comment">//重写货币接口Money的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买买买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口和类的关系</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>关键字</th>
<th>关系</th>
</tr>
</thead>
<tbody><tr>
<td>类和类之间</td>
<td>用extends关键字表示继承</td>
<td>单继承</td>
</tr>
<tr>
<td>类和接口之间</td>
<td>用implements关键字表示实现</td>
<td>多实现</td>
</tr>
<tr>
<td>接口和接口之间</td>
<td>用extends关键字表示继承</td>
<td>多继承</td>
</tr>
</tbody></table>
<p><em>注意</em>：</p>
<ul>
<li>类可以实现(继承)接口，而接口不能继承类。</li>
<li>子接口a继承了父接口b，某个类实现子接口a的话，该类必须重写接口a和接口b的所有抽象方法，否则将该类变成抽象类。</li>
</ul>
<p>想要即继承父类又实现接口的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1, 接口2, 接口3 </span>&#123; 类体 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><em>概念</em><br>当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类（Inner），而这个内部类所在的类叫做外部类（Outer）。</p>
<p>类中的内容可以有：成员变量、成员方法、构造方法、静态方法、构造块、静态代码块、内部类。<br>由此可见内部类和其他成员是平级关系。</p>
<p><em>作用：</em><br>当一个类的存在价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为服务类中的内部类，这样可以隐藏该类的现实细节并且可以方便的访问外部类的私有成员。</p>
<p><em>内部类的分类</em></p>
<ul>
<li>普通（成员）内部类：直接将一个类定义在另一个类的类体中</li>
<li>静态内部类：使用static关键字修饰的内部类，隶属于类层级</li>
<li>局部内部类：直接将一个类定义在方法体的内部</li>
<li>匿名内部类：就是指没有名字的内部类（重要）</li>
</ul>
<h4 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h4><p>又叫成员内部类，直接将一个类定义在另一个类的类体中，写法和普通的类一样。<br>内部类可以直接访问外部类的成员。出现同名成员，可以用<code>外部类名.this.成员</code>访问外部类的成员。<br>测试中想要创建内部类，必须先创建外部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//定义普通内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Innter</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;形参a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;普通内部类的成员变量a = &quot;</span> + <span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类的成员变量a = &quot;</span> + Outer1.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer1 o = <span class="keyword">new</span> Outer1();</span><br><span class="line">        Outer1.Innter i = o.<span class="function">new <span class="title">Innter</span><span class="params">()</span></span>;</span><br><span class="line">        i.show(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>使用static关键字修饰的内部类，隶属于类层级<br>由于静态内部类隶属于类层级，可以用类名.的方式直接调用。<br>并且静态内部类里面不可以访问外部类的非静态成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//该静态内部类里面不能访问外部类的非静态成员。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnter</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;形参a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类的成员变量b = &quot;</span> + <span class="keyword">this</span>.b);</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类的静态变量a = &quot;</span> + StaticInnter.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类的静态变量a = &quot;</span> + Outer2.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer2.StaticInnter si = <span class="keyword">new</span> Outer2.StaticInnter();</span><br><span class="line">        si.show(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>直接将一个类定义在方法体的内部。<br>只能在该方法体中使用。<br>和局部变量一样，定义局部内部类时不用加public等关键字修饰。<br>局部内部类中访问外部方法体的变量时，应该把该变量当作常量一样使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ia = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ib = <span class="number">2</span>;   <span class="comment">//对于局部内部类来说，该外部方法体的变量ib相当于常量。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在方法体中定义局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AreaInner</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> ic = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ia = &quot;</span> + ia);</span><br><span class="line">                System.out.println(<span class="string">&quot;ib = &quot;</span> + ib);<span class="comment">//外部方法体的变量ib相当于常量。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ic = &quot;</span> + ic);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只能在所在的方法体中调用。</span></span><br><span class="line">        AreaInner ai = <span class="keyword">new</span> AreaInner();</span><br><span class="line">        ai.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer3 o = <span class="keyword">new</span> Outer3();</span><br><span class="line">        o.show1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><strong>回调模式的概念</strong></p>
<p>回调模式：指如果一个方法的形参是接口类型，则调用该方法时，实参就要是该接口类型的实现类创建的对象。而该方法在运行时会调用到参数对象中所重写的方法。</p>
<p>例如：定义一个接口MyInterface。接口中有抽象方法show();<br>定义一个方法如下，符合回调模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参是接口类型引用。注意：而接口有不能创建对象，只能利用多态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">huiDiao</span><span class="params">(MyInterface i)</span></span>&#123;</span><br><span class="line">    i.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法，实参是接口的某个实现类(子类)创建的对象。所以我们又需要为接口MyInterface定义一个实现类(子类)Sub。实现类Sub要重写接口的抽象方法。<br>然后可以如下调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,实参是接口的某个实现类(子类)创建的对象</span></span><br><span class="line">huiDiao( <span class="keyword">new</span> Sub() );</span><br></pre></td></tr></table></figure>

<p>假如该方法只要调用一次就没有用了，所以实现类Sub只会用到一次就没用了。相当于是临时定义出来的类，为了方便，我们可以使用匿名内部类。</p>
<p><strong>匿名内部类</strong></p>
<p>接口/父类 引用名 = new 接口/父类（）{ 匿名内部类的方法体(注意要重写方法) };</p>
<p>根据上面的代码，调用huiDiao()方法传实参时，我们可以不用定义临时的实现类Sub了。<br>采用匿名内部类，为接口MyInterface 临时创建一个没有名字实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2,实参是利用匿名内部类创建的对象</span></span><br><span class="line">MyInterface i = <span class="keyword">new</span> MyInterface()&#123; <span class="comment">//类体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;临时创建出来的匿名内部类重写接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;   <span class="comment">//注意最后的分号;</span></span><br><span class="line">huiDiao(i);</span><br></pre></td></tr></table></figure>

<p>从java8开始提出型特性lamda表达式可以简化上述代码，<br>格式为：(参数列表) -&gt; {方法体}，后面会讲。</p>
<p><strong>开发经验</strong></p>
<p>当  接口/父类  类型的引用作为方法的形参时，实参的传递方式有两种：</p>
<ul>
<li>自定义类来  实现接口/继承父类，并重写方法。然后创建该类的对象作为实参传递。</li>
<li>使用上述匿名内部类的语法格式，得到  接口/类  类型的引用即可。</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>定义季节类，对象只有：春夏秋冬<br>定义性别类，对象只有：男女</p>
<p>例如：定义一个枚举类，枚举类只能创建指定的几个对象。</p>
<h4 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h4><p>编程实现方向枚举类，该类只能创建对象：向上，向下，向左，向右。（定义方法跟之前的单例设计模型类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String direc;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *2，声明本类类型的引用指向本类类型的对象，配合public static final关键字</span></span><br><span class="line"><span class="comment">     *   使得外部只能得到这4个引用（类名.引用名），而且不能修改。外部不能创建别的对象了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction UP = <span class="keyword">new</span> Direction(<span class="string">&quot;向上&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction DOWN = <span class="keyword">new</span> Direction(<span class="string">&quot;向下&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction LEFT = <span class="keyword">new</span> Direction(<span class="string">&quot;向左&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction RIGHT = <span class="keyword">new</span> Direction(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line">    <span class="comment">//1,私有化构造方法，使得外部不能通过new的方法创建对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction</span><span class="params">(String derec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direc = derec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方向是&quot;</span> + <span class="keyword">this</span>.direc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部只能得到这4个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Direction d1 = Direction.UP;</span><br><span class="line">Direction d2 = Direction.DOWN;</span><br><span class="line">Direction d3 = Direction.LEFT;</span><br><span class="line">Direction d4 = Direction.RIGHT;</span><br></pre></td></tr></table></figure>

<h4 id="用enum定义枚举类"><a href="#用enum定义枚举类" class="headerlink" title="用enum定义枚举类"></a>用enum定义枚举类</h4><p>使用上述public static final配合表示有点繁琐，Java5以后有了新的引用数据类型：<em>枚举类型</em>，用enum关键字。<br>定义枚举类时，将class替换成enum表示枚举类类型。</p>
<p>Java5后建议如下这样定义枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction2</span></span>&#123;</span><br><span class="line">    <span class="comment">//public static final Direction UP = new Direction(&quot;向上&quot;);</span></span><br><span class="line">    <span class="comment">//在枚举类中简写成： UP(&quot;向上&quot;);   且放在第一行。</span></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>), DOWN(<span class="string">&quot;向下&quot;</span>), LEFT(<span class="string">&quot;向左&quot;</span>), RIGHT(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String deric;</span><br><span class="line">    <span class="comment">//1,私有化构造方法，使得外部不能通过new的方法创建对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction2</span><span class="params">(String deric)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deric = deric;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.deric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Direction2 d1 = Direction2.UP;</span><br><span class="line">Direction2 d2 = Direction2.DOWN;</span><br><span class="line">Direction2 d3 = Direction2.LEFT;</span><br><span class="line">Direction2 d4 = Direction2.RIGHT;</span><br></pre></td></tr></table></figure>

<p>在switch结构中支持采用enum关键字定义的枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Direction2 d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(d)&#123;</span><br><span class="line">            <span class="keyword">case</span> UP: System.out.println(<span class="string">&quot;贪吃蛇向上走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN: System.out.println(<span class="string">&quot;贪吃蛇向下走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT: System.out.println(<span class="string">&quot;贪吃蛇向左走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT: System.out.println(<span class="string">&quot;贪吃蛇向右走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test2.test2(Direction2.UP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enum类的方法"><a href="#Enum类的方法" class="headerlink" title="Enum类的方法"></a>Enum类的方法</h4><p>用enum关键字定义的枚举类天生继承自java.lang.Enum类，所以也继承父类的方法。<br><em>注意</em>：由于继承Enum父类。枚举类不能再继承其他类了，但是可以实现接口。</p>
<p>继承的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>static T[] values()</td>
<td>返回当前枚举类中所有对象</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回当前枚举类对象名称</td>
</tr>
<tr>
<td>int ordinal()</td>
<td>获取枚举类对象在枚举中的索引位置</td>
</tr>
<tr>
<td>static T valueOf(String str)</td>
<td>将参数指定的字符串转换为当前枚举类的对象</td>
</tr>
<tr>
<td>ing compareTo(E o)</td>
<td>比较当前枚举类对象和参数枚举类对象的顺序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Direction2[] arr = Direction2.values();   <span class="comment">//values()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前对象的名称是：&quot;</span> + arr[i].toString());   <span class="comment">//toString()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前对象的索引值是：&quot;</span> + arr[i].ordinal());  <span class="comment">//ordinal()</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意细节，print打印“引用”或者是“引用.toString()”的结果是一样的。</span></span><br><span class="line">    Direction2 d = Direction2.valueOf(<span class="string">&quot;LEFT&quot;</span>);     <span class="comment">//valueOf()</span></span><br><span class="line">    System.out.println(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compareTo()是将当前对象索引值减去参数对象索引值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ia = d.compareTo(arr[i]);                      <span class="comment">//compareTo()</span></span><br><span class="line">        System.out.println(d.toString() + <span class="string">&quot;和&quot;</span> + arr[i].toString() + <span class="string">&quot;比的结果是&quot;</span> + ia);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举类重写接口方法"><a href="#枚举类重写接口方法" class="headerlink" title="枚举类重写接口方法"></a>枚举类重写接口方法</h4><p>上面说过，由于继承Enum父类。枚举类不能再继承其他类了，但是可以实现接口。</p>
<p>枚举类实现了某个接口，就需要重写接口的方法。重写方法有两种方式：</p>
<ul>
<li>所有枚举类对象共享同一个重写方法。</li>
<li>每个枚举类对象各自重写方法，利用匿名内部类的方式。</li>
</ul>
<p>假设定义一个接口MyInterface，有抽象方法show()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction3</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>), DOWN(<span class="string">&quot;向下&quot;</span>), LEFT(<span class="string">&quot;向左&quot;</span>), RIGHT(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String direc;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction3</span><span class="params">(String direc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direc = direc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1,所有枚举类对象共享同一个重写方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction3</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2,每个枚举类对象各自重写方法，利用匿名内部类的方式。</span></span><br><span class="line">    <span class="comment">//匿名内部类：接口/父类 引用名 = new 接口/父类()&#123;类体&#125;;</span></span><br><span class="line">    <span class="comment">//public static finla Directioin3 UP = new Direction3(&quot;向上&quot;) &#123;类体中重写方法&#125;;</span></span><br><span class="line">    <span class="comment">//简化为：UP(&quot;向上&quot;)&#123;类体中重写方法&#125;, DOWN(&quot;向下&quot;)&#123;类体中重写方法&#125;, ......</span></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, DOWN(<span class="string">&quot;向下&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, LEFT(<span class="string">&quot;向左&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, RIGHT(<span class="string">&quot;向右&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String direc;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction3</span><span class="params">(String direc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direc = direc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解(Annotation)又叫标注。是Java5开始增加的一种引用数据类型。是一种特殊的接口。</p>
<p>本质上就是给代码贴标签，特殊标记。通过这些标记可以在编译、类加载、以及运行时执行指定的处理。</p>
<h4 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h4><p><strong>定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">	注解成员;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解成员只有成员变量。注解的成员变量声明语法：<br><code>public 数据类型 变量名();</code>     或者<br><code>public 数据类型 变量名() default 默认值;</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//只能有成员变量。public 数据类型 变量名() /*default 默认值*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value2</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个注解没有任何成员，叫做标记注解/标识注解。</p>
<p><strong>使用</strong></p>
<p>在需要注解的代码上写上：@ 注解名(传参)</p>
<p>例如：注解标注Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=1, value2=2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>注解是标注在代码上面。<br>但是有些注解可以标注在注解上———叫做元注解。</p>
<p>元注解主要有：@retention、@Documented、@Target、@Inherited、@Repeatable</p>
<p><strong>@retention</strong></p>
<p>@retention应用(贴)在一个注解上，用于说明该注解的生命周期，取值如下：</p>
<ul>
<li><p>RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时</p>
<p>它将被丢弃忽视。java文件前有效</p>
</li>
<li><p>RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加</p>
<p>载到 JVM 中，默认方式。class文件前有效</p>
</li>
<li><p>RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载</p>
<p>进入到 JVM 中，所以在程序运行时可以获取到它们。</p>
</li>
</ul>
<p>java文件——–(javac.exe编译器编译阶段)——-&gt;class文件——(java.exe解释器解释运行阶段)———-&gt;结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定所修饰的注解MyAnnotation的生命周期在class文件前有效(默认)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;  <span class="comment">//自定义注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Documented</strong></p>
<p>使用Javadoc工具可以从程序源代码中抽取类、方法、成员等形成一个和源代码配套的API帮助文档。默认不包括注解内容。</p>
<p>例如写了如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=1, value2=2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//文档注释</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * age是描述年龄的成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * name是描述姓名的成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i:随便传的形参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:返回参数int i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用过IDEA演示，点击“Tools”—&gt;“Generate JavaDoc”，打开对话框，填写好相关信息后点击ok。然后会自动生成跟我们写的代码配套的API帮助文档。<br>文档注释/**    */会变成代码的功能说明。</p>
<p>生成的API帮助文档，里面默认不包括注解内容。<br>想要在API帮助文档包括注解内容的话，需要在定义注解时，贴上元注解@Documented。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所修饰的注解MyAnnotation可以被添加到API帮助文档中</span></span><br><span class="line"><span class="meta">@Documented</span>                     </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Target</strong></p>
<p>@Target用于指定被修饰的注解只能贴在哪些元素上。</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ElementType.ANNOTATION_TYPE</td>
<td>可以给一个注解进行注解</td>
</tr>
<tr>
<td>ElementType.CONSTRUCTOR</td>
<td>可以给构造方法进行注解</td>
</tr>
<tr>
<td>ElementType.FIELD</td>
<td>可以给属性进行注解</td>
</tr>
<tr>
<td>ElementType.LOCAL_VARIABLE</td>
<td>可以给局部变量进行注解</td>
</tr>
<tr>
<td>ElementType.METHOD</td>
<td>可以给方法进行注解</td>
</tr>
<tr>
<td>ElementType.PACKAGE</td>
<td>可以给一个包进行注解</td>
</tr>
<tr>
<td>ElementType.PARAMETER</td>
<td>可以给一个方法内的参数进行注解</td>
</tr>
<tr>
<td>ElementType.TYPE</td>
<td>可以给类型进行注解，比如类、接口、枚举</td>
</tr>
</tbody></table>
<p>从Java8开始对元注解@Target的参数类型ElementType枚举值增加了两个：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ElementType.TYPE_PARAMETER</td>
<td>该注解能写在类型变量的声明语句中，如：泛型。</td>
</tr>
<tr>
<td>中ElementType.TYPE_USE</td>
<td>该注解能写在使用类型的任何语句中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所修饰的注解MyAnnotation只可以贴在属性或类型上。</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Inherited</strong></p>
<p>默认子类继承父类时，不会把父类的注解也继承。</p>
<p>@Inherited所应用的注解可以被继承。</p>
<p>并不是说注解本身可以继承，而是说如果一个父类被该元注解(@Inherited)标记过的注解进行标记时，如果子类没有被任何注解应用时，则子类就继承父类的注解。</p>
<p><strong>@Repeatable</strong></p>
<p>表示自然可重复的含义</p>
<p>正常定义的注解不能对同一代码反复标注。</p>
<p>如果某一注解想要对同一代码反复标注，Java8以前的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManType &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManTypes &#123;</span><br><span class="line">    <span class="keyword">public</span> ManType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8以前是这样处理多个注解</span></span><br><span class="line"><span class="meta">@ManTypes(value=&#123;@ManType(value=&quot;超人&quot;), @ManType(value=&quot;父亲&quot;)&#125;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java8以后借助元注解@Repeatable可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(value=ManTypes.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManType &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManTypes &#123;</span><br><span class="line">    <span class="keyword">public</span> ManType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8以后借助元注解@Repeatable可以这样写</span></span><br><span class="line"><span class="meta">@ManType(value=&quot;超人&quot;)</span>    </span><br><span class="line"><span class="meta">@ManType(value=&quot;父亲&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是无论哪种写法，ManType注解想要反复使用的话，都需要定义ManTypes注解，里面的成员是ManType注解类型的数组。</p>
<h4 id="常见的预制注解"><a href="#常见的预制注解" class="headerlink" title="常见的预制注解"></a>常见的预制注解</h4><p>预制注解就是Java语言自身提供的注解，具体如下：</p>
<table>
<thead>
<tr>
<th>预制注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>标明开发该类模块的作者，多个作者之间使用,分割</td>
</tr>
<tr>
<td>@version</td>
<td>标明该类模块的版本</td>
</tr>
<tr>
<td>@see</td>
<td>参考转向，也就是相关主题</td>
</tr>
<tr>
<td>@since</td>
<td>从哪个版本开始增加的</td>
</tr>
<tr>
<td>@param</td>
<td>对方法中某参数的说明，如果没有参数就不能写</td>
</tr>
<tr>
<td>@return</td>
<td>对方法返回值的说明，如果方法的返回值类型是void就不能写</td>
</tr>
<tr>
<td>@exception</td>
<td>对方法可能抛出的异常进行说明</td>
</tr>
<tr>
<td>@Override</td>
<td>限定重写父类方法, 该注解只能用于方法</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>用于表示所修饰的元素(类, 方法等)已过时</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>抑制编译器警告</td>
</tr>
</tbody></table>
<h1 id="Java核心类库-上"><a href="#Java核心类库-上" class="headerlink" title="Java核心类库(上)"></a>Java核心类库(上)</h1><h2 id="常用类的概述和使用"><a href="#常用类的概述和使用" class="headerlink" title="常用类的概述和使用"></a>常用类的概述和使用</h2><p>这里开始学习官方提供的类和接口，需要借助API工具。</p>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ul>
<li><p>java.lang包 - 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。<br>如：System类、String类、… </p>
</li>
<li><p>java.util包 - 该包是Java语言的工具包，里面提供了大量工具类以及集合类等。<br>如：Scanner类、Random类、List集合、…</p>
</li>
<li><p>java.io包 - 该包是Java语言中的输入输出包，里面提供了大量读写文件相关的类等。<br>如：FileInputStream类、FileOutputStream类、…</p>
</li>
<li><p>java.net包 - 该包是Java语言中的网络包，里面提供了大量网络编程相关的类等。<br>如：ServerSocket类、Socket类、…</p>
</li>
<li><p>java.sql 包 - 该包是Java语言中的数据包，里面提供了大量操作数据库的类和接口等。<br>如：DriverManager类、Connection接口、…</p>
</li>
<li><p>… …</p>
</li>
</ul>
<p>Java程序员在编程时可以使用大量类库，因此Java编程时需要记的很多，对编程能力本身要求不是</p>
<p>特别的高。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li><p>java.lang.Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间<br>接子类。</p>
</li>
<li><p>如果定义一个Java类时没有使用extends关键字声明其父类，则其父类默认为 java.lang.Object 类。</p>
</li>
<li><p>Object类定义了“对象”的基本行为, 被子类默认继承。</p>
</li>
</ul>
<p><strong>Object类的常用方法如下：</strong>（被所有子类继承）</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>boolean equals(Object obj)：</p>
<p>用于判断调用对象是否与参数对象相等。默认是判断地址是否相等，和==运算符一样。<br>若希望比较两个对象的内容，则需要重写该方法。<br>若该方法被重写后，则应该重写hashCode方法来保证结果的一致性。</p>
<p><em>例如</em>，定义了student类，假如两个对象的id一样，则equals()就为true。重写如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数obj为空，或者参数和当前对象this不是同一类，直接返回false。</span></span><br><span class="line">    <span class="keyword">if</span>( obj == <span class="keyword">null</span> || obj.getClass()!= <span class="keyword">this</span>.getClass() ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//参数obj和当前对象this地址相同直接返回true。</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果id相同，直接返回true。</span></span><br><span class="line">    ObjectTest that = (ObjectTest)obj;</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>.getId() == that.getId() )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id不同返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是String name这种引用数据类型的话，条件如下(因为String类中重写了equals方法)</span></span><br><span class="line"><span class="comment">//if( this.getName().equals(that.getName()) )</span></span><br></pre></td></tr></table></figure>

<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p>int hashCode()：</p>
<p>用于获取调用对象的哈希码值(内存地址的编号)。<br>若两个对象调用equals方法相等，则各自调用该方法的结果必须相同。<br>若两个调用对象equals方法不相等，则各自调用该方法的结果应该不相同。<br>为了使得该方法与equals方法保持一致，重写了equals方法，就需要重写该方法。</p>
<p><em>例如</em>，上面重写了equals()方法，是基于对象的id比较是否相等，那么hashCode()方法也要重写来与id有关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">31</span> * <span class="number">12</span> + <span class="keyword">this</span>.getId();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是String name这种引用数据类型的话，返回值如下(因为String类中重写了hashCode方法)</span></span><br><span class="line"><span class="comment">//return 31 * 12 + this.getName().hashCode();</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>String toString()：</p>
<p>该方法默认返回的字符串为：包名.类名@哈希码值的十六进制。<br>为了返回更有意义的数据，需要重写该方法。<br>使用print或println打印引用或字符串拼接引用都会自动调用该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;id=&quot;</span> + <span class="keyword">this</span>.id + <span class="string">&quot;,name=&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h4><p>Class&lt;?&gt; getClass() ：</p>
<p>用于返回调用对象执行时的Class实例，反射机制使用</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>通常情况下基本数据类型的变量不是对象，为了满足万物皆对象的理念就需要对基本数据类型的变量进行打包封装处理变成对象，而负责将这些变量声明为成员变量进行对象化处理的相关类，叫做包装类。</p>
<table>
<thead>
<tr>
<th><strong>包装类</strong></th>
<th><strong>对应的基本类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Byte</td>
<td>byte</td>
</tr>
<tr>
<td>java.lang.Short</td>
<td>short</td>
</tr>
<tr>
<td>java.lang.Integer</td>
<td>int</td>
</tr>
<tr>
<td>java.lang.Long</td>
<td>long</td>
</tr>
<tr>
<td>java.lang.Float</td>
<td>float</td>
</tr>
<tr>
<td>java.lang.Double</td>
<td>double</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>java.lang.Character</td>
<td>char</td>
</tr>
</tbody></table>
<p>其中Byte、Short、Integer、Long、Float、Double包装类都继承自java.lang.Number抽象类。</p>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p>java.lang.Integer类内部包装了一个int类型的变量作为成员变量，主要用于实现对int类型的包装并<br>提供int类型到String类之间的转换等方法。</p>
<p><strong>常用常量</strong></p>
<table>
<thead>
<tr>
<th><strong>常量类型和名称</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public static final int MAX_VALUE</td>
<td>表示int类型可以描述的最大值，即2^31-1</td>
</tr>
<tr>
<td>public static final int MIN_VALUE</td>
<td>表示int类型可以描述的最小值，即-2^31</td>
</tr>
<tr>
<td>public static final int SIZE</td>
<td>表示int类型采用二进制补码形式的位数</td>
</tr>
<tr>
<td>public static final int BYTES</td>
<td>表示int类型所占的字节个数</td>
</tr>
<tr>
<td>public static final Class TYPE</td>
<td>表示int类型的Class实例</td>
</tr>
</tbody></table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Integer(int value)</td>
<td>根据参数指定的整数来构造对象（已过时）</td>
</tr>
<tr>
<td>Integer(String s)</td>
<td>根据参数指定的字符串来构造对象 （已过时）</td>
</tr>
<tr>
<td>static Integer valueOf(int i)</td>
<td>根据参数指定整数值得到Integer类型对象</td>
</tr>
<tr>
<td>int intValue()</td>
<td>获取调用对象中的整数值并返回</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回描述调用对象数值的字符串形式</td>
</tr>
<tr>
<td>static int parseInt(String s)</td>
<td>将字符串类型转换为int类型并返回</td>
</tr>
<tr>
<td>static String toString(int i)</td>
<td>获取参数指定整数的十进制字符串形式</td>
</tr>
<tr>
<td>static String toBinaryString(int i)</td>
<td>获取参数指定整数的二进制字符串形式</td>
</tr>
<tr>
<td>static String toHexString(int i)</td>
<td>获取参数指定整数的十六进制字符串形式</td>
</tr>
<tr>
<td>static String toOctalString(int i)</td>
<td>获取参数指定整数</td>
</tr>
</tbody></table>
<p><strong>装箱和拆箱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用构造方法创建对象，已过时（不建议使用）</span></span><br><span class="line">Integer it1 = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Integer对象，相当于将int类型转换Integer类型，装箱</span></span><br><span class="line">Integer it2 = Integer.valueOf(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于将Integer类型转换int类型，拆箱</span></span><br><span class="line"><span class="keyword">int</span> ia = it2.intValue();</span><br></pre></td></tr></table></figure>

<p><strong>自动装箱和拆箱</strong>(java5之后的新特性)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java5后，自动装箱拆箱</span></span><br><span class="line">Integer it1 = <span class="number">9</span>;  </span><br><span class="line"><span class="keyword">int</span> ia = it1;</span><br></pre></td></tr></table></figure>

<p><strong>自动装箱池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer it1 = <span class="number">128</span>;</span><br><span class="line">Integer it2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(it5 == it6);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>如上，明显it1和it2的地址不相同，所以结果是false，但是如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer it3 = <span class="number">127</span>;</span><br><span class="line">Integer it4 = <span class="number">127</span>;</span><br><span class="line">System.out.println(it3 == it4);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>结果却是true。因为：</p>
<p>在Integer类的内部提供了自动装箱池技术，将-128到127之间的整数已经装箱完毕，当程序中使用<br>该范围之间的整数时，无需装箱直接取用自动装箱池中的对象即可，从而提高效率。</p>
<p><strong>其他方法演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;返回十进制&quot;</span> + Integer.toString(<span class="number">200</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;返回二进制&quot;</span> + Integer.toBinaryString(<span class="number">200</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;返回八进制&quot;</span> + Integer.toOctalString(<span class="number">200</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;返回十六进制&quot;</span>+Integer.toHexString(<span class="number">200</span>));</span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer类型表示的最大值&quot;</span> + Integer.MAX_VALUE);  <span class="comment">//2147483647</span></span><br></pre></td></tr></table></figure>

<h4 id="Bouble"><a href="#Bouble" class="headerlink" title="Bouble"></a>Bouble</h4><p>用法和Interger差不多，例如，装箱拆箱和自动装箱拆箱等…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean isNaN()：判断调用对象的数值是否为非数字</span></span><br><span class="line">Double D1 = Double.valueOf(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">System.out.println( D1.isNaN() );   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Double D2 = Double.valueOf(<span class="number">0</span>/<span class="number">0.0</span>);</span><br><span class="line">System.out.println( D2.isNaN() );   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>用法和Interger差不多，例如，装箱拆箱和自动装箱拆箱等…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换Boolean类型，只有字符串是true(不区分大小写)时，结果才是true，其他都为false。</span></span><br><span class="line">Boolean B = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">System.out.println(B.toString());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h4><p>用法和Interger差不多，例如，装箱拆箱和自动装箱拆箱等…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;是否大写：&quot;</span> + Character.isUpperCase(<span class="string">&#x27;A&#x27;</span>));    <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否小写：&quot;</span> + Character.isLowerCase(<span class="string">&#x27;A&#x27;</span>));    <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否数字：&quot;</span> + Character.isDigit(<span class="string">&#x27;2&#x27;</span>));        <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;转换成大写：&quot;</span> + Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));  <span class="comment">//A</span></span><br><span class="line">System.out.println(<span class="string">&quot;转换成小写：&quot;</span> + Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));  <span class="comment">//a</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>基本数据类型转换为对应包装类的方式</li>
</ul>
<p>调用包装类的构造方法或静态方法valueOf即可</p>
<ul>
<li>获取包装类对象中基本数据类型变量数值的方式</li>
</ul>
<p>调用包装类中的xxxValue方法即可</p>
<ul>
<li>字符串转换为基本数据类型的方式</li>
</ul>
<p>调用包装类中的parseXxx方法即可</p>
<h3 id="数学处理类"><a href="#数学处理类" class="headerlink" title="数学处理类"></a>数学处理类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>java.lang.Math类主要用于提供执行数学运算的方法，如：对数，平方根。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static int max(int a, int b)</td>
<td>返回两个参数中的最大值</td>
</tr>
<tr>
<td>static int min(int a, int b)</td>
<td>返回两个参数中的最小值</td>
</tr>
<tr>
<td>static double pow(double a, double b)</td>
<td>返回第一个参数的幂</td>
</tr>
<tr>
<td>static int abs(int a)</td>
<td>返回参数指定数值的绝对值</td>
</tr>
<tr>
<td>static long round(double a)</td>
<td>返回参数四舍五入的结果</td>
</tr>
<tr>
<td>static double sqrt(double a)</td>
<td>返回参数的平方根</td>
</tr>
<tr>
<td>static double random()</td>
<td>返回0.0到1.0的随机数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;最大数：&quot;</span> + Math.max(<span class="number">5</span>,<span class="number">8</span>));    <span class="comment">//8</span></span><br><span class="line">System.out.println(<span class="string">&quot;最小数&quot;</span> + Math.min(<span class="number">5</span>,<span class="number">8</span>));      <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;求幂&quot;</span> + Math.pow(<span class="number">2</span>,<span class="number">3</span>));        <span class="comment">//8.0</span></span><br><span class="line">System.out.println(<span class="string">&quot;绝对值&quot;</span> + Math.abs(-<span class="number">1</span>));       <span class="comment">//1</span></span><br><span class="line">System.out.println(<span class="string">&quot;四舍五路:&quot;</span> + Math.round(<span class="number">2</span>/<span class="number">0.3</span>));<span class="comment">//7</span></span><br><span class="line">System.out.println(<span class="string">&quot;平方跟:&quot;</span> + Math.sqrt(<span class="number">25</span>));      <span class="comment">//5.0</span></span><br><span class="line">System.out.println(<span class="string">&quot;0到1.0的随机数:&quot;</span> + Math.random());<span class="comment">//随机数</span></span><br></pre></td></tr></table></figure>

<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>由于flfloat类型和double类型在运算时可能会有误差，若希望实现精确运算则借助<br>java.math.BigDecimal类型加以描述。</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BigDecimal(String val)</td>
<td>根据参数指定的字符串来构造对象</td>
</tr>
<tr>
<td>BigDecimal add(BigDecimal augend)</td>
<td>用于实现加法运算</td>
</tr>
<tr>
<td>BigDecimal subtract(BigDecimal subtrahend)</td>
<td>用于实现减法运算</td>
</tr>
<tr>
<td>BigDecimal multiply(BigDecimal multiplicand)</td>
<td>用于实现乘法运算</td>
</tr>
<tr>
<td>BigDecimal divide(BigDecimal divisor)</td>
<td>用于实现除法运算</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;5.2&quot;</span>);</span><br><span class="line">BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.3&quot;</span>);</span><br><span class="line"><span class="comment">//正常浮点类型运算会由失误，虽然误差很小。</span></span><br><span class="line">System.out.println(<span class="number">5.2</span>*<span class="number">1.3</span>);    <span class="comment">//6.760000000000001</span></span><br><span class="line">System.out.println(<span class="string">&quot;加法运算：&quot;</span> + bd1.add(bd2));       <span class="comment">//6,5</span></span><br><span class="line">System.out.println(<span class="string">&quot;减法运算：&quot;</span> + bd1.subtract(bd2));  <span class="comment">//3.9</span></span><br><span class="line">System.out.println(<span class="string">&quot;乘法运算：&quot;</span> + bd1.multiply(bd2));  <span class="comment">//6.76</span></span><br><span class="line">System.out.println(<span class="string">&quot;除法运算：&quot;</span> + bd1.divide(bd2));    <span class="comment">//4.0</span></span><br></pre></td></tr></table></figure>

<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>若希望表示比long类型范围还大的整数数据，则需要借助java.math.BigInteger类型描述。</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BigInteger(String val)</td>
<td>根据参数指定的字符串来构造对象</td>
</tr>
<tr>
<td>“加减乘除”与上述BigDecimal一样</td>
<td></td>
</tr>
<tr>
<td>BigInteger remainder(BigInteger val)</td>
<td>用于实现取余运算</td>
</tr>
<tr>
<td>BigInteger[] divideAndRemainder(BigInteger val)</td>
<td>用于实现取商和余数的运算</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">BigInteger bi2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取商和取余数一起</span></span><br><span class="line">BigInteger[] arr = bi1.divideAndRemainder(bi2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;下标为&quot;</span> + i + <span class="string">&quot;的元素值是：&quot;</span> + arr[i]);    <span class="comment">//0--2， 1--4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul>
<li><p>java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加以描述，如：”abc”。</p>
</li>
<li><p>该类由fifinal关键字修饰，表示该类不能被继承。</p>
</li>
<li><p>从jdk1.9开始该类的底层不使用char[]来存储数据，而是改成 byte[]加上编码标记，从而节约了一些空间。</p>
</li>
<li><p>该类描述的字符串内容是个常量不可更改，因此可以被共享使用。</p>
<p>如：</p>
<p> String str = “abc”; -表示str指向”abc”，其中”abc”这个字符串是个常量不可改变。 </p>
<p> str = “123”; - 将“123”字符串的地址赋值给变量str。</p>
<p> - 改变str的指向并没有改变指向的内容</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>由于String类型描述的字符串内容是常量不可改变，因此Java虚拟机将首次出现的字符串放入常量</p>
<p>池中，若后续代码中出现了相同字符串内容则直接使用池中已有的字符串对象而无需申请内存及创建对</p>
<p>象，从而提高了性能。</p>
<p>例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h3><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String()</td>
<td>使用无参方式构造对象得到空字符序列</td>
</tr>
<tr>
<td>String(byte[] bytes, int offset, int length)</td>
<td>使用bytes数组中下标从offset位置开始的length个字节来构造对象</td>
</tr>
<tr>
<td>String(byte[] bytes)</td>
<td>使用bytes数组中的所有内容构造对象</td>
</tr>
<tr>
<td>String(char[] value, int offset, int count)</td>
<td>使用value数组中下标从offset位置开始的count个字符来构造对象</td>
</tr>
<tr>
<td>String(char[] value)</td>
<td>使用value数组中的所有内容构造对象</td>
</tr>
<tr>
<td>String(String original)</td>
<td>根据参数指定的字符串内容来构造对象，新创建对象为参数对象的副本</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bArr = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(bArr);</span><br><span class="line">System.out.println(str);  <span class="comment">//abcd   由ASCII码转换而成。</span></span><br></pre></td></tr></table></figure>

<p><strong>考点</strong>：</p>
<ul>
<li>String str = “abc”  和 String str = new String(“abc”)的区别：<br>String str = “abc”：常量“abc”被创建在常量池中，str指向“abc”。<br>String str = new String(“abc”)：常量“abc”被创建在常量池中，new String()被创建在堆区，str指向堆区的new String()。</li>
<li>判断如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;adcd&quot;</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;adcd&quot;</span>);</span><br><span class="line"><span class="comment">//判断内容</span></span><br><span class="line">System.out.println(str1.equals(str2));   <span class="comment">//true</span></span><br><span class="line">System.out.println(str3.equals(str4));   <span class="comment">//true</span></span><br><span class="line"><span class="comment">//判断地址</span></span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true，都指向常量池中的常量“abcd”。</span></span><br><span class="line">System.out.println(str3 == str4);   <span class="comment">//false，指向堆区中不同的String类型对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;   <span class="comment">//常量优化机制</span></span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String str4 = str3 + <span class="string">&quot;cd&quot;</span>;  <span class="comment">//没有常量优化机制</span></span><br><span class="line">System.out.println(str1 == str4);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回字符串本身</td>
</tr>
<tr>
<td>byte[] getBytes()</td>
<td>将当前字符串内容转换为byte数组并返回</td>
</tr>
<tr>
<td>char[] toCharArray()</td>
<td>用于将当前字符串内容转换为char数组并返回</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>char charAt(int index)</td>
<td>方法charAt用于返回字符串指定位置的字符。</td>
</tr>
<tr>
<td>int length()</td>
<td>返回字符串字符序列的长度</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>
</tbody></table>
<p>案例题目:</p>
<p>判断字符串“上海自来水来自海上”是否为回文并打印，所谓回文是指一个字符序列无论从左向右读</p>
<p>还是从右向左读都是相同的句子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">&quot;上海自来水来自海上&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str2.length()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>( str2.charAt(i) != str2.charAt(str2.length()-<span class="number">1</span>-i) )&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不是回文！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;是回文！&quot;</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int compareTo(String anotherString)</td>
<td>用于比较调用对象和参数对象的大小关系</td>
</tr>
<tr>
<td>int compareToIgnoreCase(String str)</td>
<td>不考虑大小写，也就是’a’和’A’是相等的关系</td>
</tr>
</tbody></table>
<p>从头比，相同的继续比较下一个，不同就用字符串对应的ASCII码值相减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println( str.compareTo(<span class="string">&quot;hello&quot;</span>) );          <span class="comment">//相同返回 0</span></span><br><span class="line">System.out.println( str.compareTo(<span class="string">&quot;hgllo&quot;</span>) );          <span class="comment">//e-g 返回 -2</span></span><br><span class="line">System.out.println( str.compareTo(<span class="string">&quot;hello1234&quot;</span>) );      <span class="comment">//长度返回 -4</span></span><br><span class="line">System.out.println( str.compareToIgnoreCase(<span class="string">&quot;HELLO&quot;</span>) );<span class="comment">//不区分大小写 0</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String concat(String str)</td>
<td>用于实现字符串的拼接</td>
</tr>
<tr>
<td>boolean contains(CharSequence s)</td>
<td>用于判断当前字符串是否包含参数指定的内容</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>返回字符串的小写形式</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>返回字符串的大写形式</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回去掉前导和后继空白的字符串</td>
</tr>
<tr>
<td>boolean startsWith(String prefifix)</td>
<td>判断字符串是否以参数字符串开头</td>
</tr>
<tr>
<td>boolean startsWith(String prefifix, int toffffset)</td>
<td>从指定位置开始是否以参数字符串开头</td>
</tr>
<tr>
<td>boolean endsWith(String suffiffiffix)</td>
<td>判断字符串是否以参数字符串结尾</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean equals(Object anObject)</td>
<td>用于比较字符串内容是否相等并返回</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>用于比较字符串内容是否相等并返回，不考虑大小写，如：’A’和’a’是相等</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>获取调用对象的哈希码值</td>
</tr>
</tbody></table>
<p>案例题目</p>
<p>提示用户从键盘输入用户名和密码信息，若输入”admin”和”123456”则提示“登录成功，欢迎使</p>
<p>用”，否则提示“用户名或密码错误，您还有n次机会”，若用户输入三次后依然错误则提示“账户已</p>
<p>冻结，请联系客服人员！”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">    String user = sc.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">    String password = sc.next();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(user) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功，欢迎使用&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;账户已冻结，请联系客服人员！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名或密码错误，您还有&quot;</span> + (i-<span class="number">1</span>) + <span class="string">&quot;次机会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int indexOf(int ch)</td>
<td>用于返回当前字符串中参数ch指定的字符第一次出现的下标</td>
</tr>
<tr>
<td>int indexOf(int ch, int fromIndex)</td>
<td>用于从fromIndex位置开始查找ch指定的字符</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>在字符串中检索str返回其第一次出现的位置，若找不到返回-1</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>表示从字符串的fromIndex位置开始检索str第一次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(int ch)</td>
<td>用于返回参数ch指定的字符最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(int ch, int fromIndex)</td>
<td>用于从fromIndex位置开始查找ch指定字符出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>返回str指定字符串最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>用于从fromIndex位置开始反向搜索的第一次出现的下标。</td>
</tr>
</tbody></table>
<p>注意：indexOf() 是从左往右第一个，而lastIndexOf() 是从右往左第一个。</p>
<ul>
<li>案例题目</li>
</ul>
<p>编写通用的代码可以查询字符串”Good Good Study, Day Day Up!”中所有”Day”出现的索引位置并打印出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Good Good Study, Day Day Up!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = str.indexOf(<span class="string">&quot;Day&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(i != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i = str.indexOf(<span class="string">&quot;Day&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Good Good Study, Day Day Up!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( (i=str.indexOf(<span class="string">&quot;Day&quot;</span>, i)) != -<span class="number">1</span> )&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i += <span class="string">&quot;Day&quot;</span>.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>返回字符串中从下标beginIndex（包括）开始到endIndex（不包括）结束的子字符串</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>返回字符串中从下标beginIndex（包括）开始到字符串结尾的子字符串</td>
</tr>
</tbody></table>
<ul>
<li>案例题目</li>
</ul>
<p>提示用户从键盘输入一个字符串和一个字符，输出该字符(不含)后面的所有子字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">String str1 = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入字符：&quot;</span>);</span><br><span class="line">String str2 = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = str1.indexOf(str2);</span><br><span class="line">String str3 = str1.substring(i+<span class="number">1</span>);</span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式本质就是一个“规则字符串”，可以用于对字符串数据的格式进行验证，以及匹配、查</p>
<p>找、替换等操作。该字符串通常使用^运算符作为开头标志，使用$运算符作为结尾标志，当然也可以省</p>
<p>略。</p>
<p>规则：</p>
<ul>
<li><p>[abc] ：可以出现a、b、c中任意一个字符</p>
</li>
<li><p>[^abc] ：可以出现任何字符，除了a、b、c的任意字符</p>
</li>
<li><p>[a-z] ：可以出现a、b、c、……、z中的任意一个字符</p>
</li>
<li><p>[a-zA-Z0-9] ：可以出现a<del>z、A</del>Z、0~9中任意一个字符</p>
</li>
</ul>
<hr>
<hr>
<ul>
<li><p>. ：任意一个字符（通常不包含换行符）</p>
</li>
<li><p>\d ：任意一个数字字符，相当于[0-9]</p>
</li>
<li><p>\D ：任意一个非数字字符</p>
</li>
<li><p>\s ：空白字符，相当于[\t\n\x0B\f\r]</p>
</li>
<li><p>\S ：非空白字符</p>
</li>
<li><p>\w ：任意一个单词字符，相当于[a-zA-Z_0-9]</p>
</li>
<li><p>\W ：任意一个非单词字符</p>
</li>
</ul>
<hr>
<hr>
<ul>
<li><p>X? ：表示X可以出现一次或一次也没有，也就是0 ~ 1次</p>
</li>
<li><p>X* ：表示X可以出现零次或多次，也就是0 ~ n次</p>
</li>
<li><p>X+ ：表示X可以出现一次或多次，也就是1 ~ n次</p>
</li>
<li><p>X{n} ：表示X可以出现恰好 n 次</p>
</li>
<li><p>X{n，} ：表示X可以出现至少 n 次，也就是&gt;=n次</p>
</li>
<li><p>X{n，m} ：表示X可以出现至少 n 次，但是不超过 m 次，也就是&gt;=n并且&lt;=m次</p>
</li>
</ul>
<p><strong>相关方法：</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>方法说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean matches(String regex)</td>
<td>判断当前正在调用的字符串是否匹配参数指定的正则表达式规则</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">String str = sc.next();</span><br><span class="line"><span class="comment">//规则: 银行卡密码的规则：要求是由6位数字组成。</span></span><br><span class="line">String reg = <span class="string">&quot;\\d&#123;6&#125;&quot;</span>;   </span><br><span class="line"><span class="keyword">if</span>( str.matches(reg) )&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;字符规则正确！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;字符规则错误！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分割和替换：</p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>String[] split(String regex)</td>
<td>参数regex为正则表达式，以regex所表示的字符串为分隔符，将字符串拆分成字符串数组</td>
</tr>
<tr>
<td>String replace(char oldChar, char newChar)</td>
<td>使用参数newChar替换此字符串中出现的所有参数oldChar</td>
</tr>
<tr>
<td>String replaceFirst(String regex, String replacement)</td>
<td>替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>将字符串中匹配正则表达式regex的字符串替换成replacement</td>
</tr>
</tbody></table>
<h2 id="可变字符串类"><a href="#可变字符串类" class="headerlink" title="可变字符串类"></a>可变字符串类</h2><ul>
<li><p>由于String类描述的字符串内容是个常量不可改变，当需要在Java代码中描述大量类似的字符串时，只能单独申请和存储，此时会造成内存空间的浪费。</p>
</li>
<li><p>为了解决上述问题，可以使用java.lang.StringBuilder类和java.lang.StringBuffer类来描述字符列可以改变的字符串</p>
</li>
<li><p>StringBuffer类是从jdk1.0开始存在，属于线程安全的类，因此效率比较低。</p>
</li>
<li><p>StringBuilder类是从jdk1.5开始存在，属于非线程安全的类，效率比较高。</p>
</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>使用无参方式构造对象，容量为16</td>
</tr>
<tr>
<td>StringBuilder(int capacity)</td>
<td>根据参数指定的容量来构造对象，容量为参数指定大小</td>
</tr>
<tr>
<td>StringBuilder(String str)</td>
<td>根据参数指定的字符串来构造对象，容量为：16+字符串长度</td>
</tr>
</tbody></table>
<p><strong>成员方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int capacity()</td>
<td>用于返回调用对象的容量</td>
</tr>
<tr>
<td>int length()</td>
<td>用于返回字符串的长度，也就是字符的个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">System.out.println(<span class="string">&quot;sb1的容量是：&quot;</span> + sb1.capacity());   <span class="comment">//16</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb1的长度是：&quot;</span> + sb1.length());     <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="number">20</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb2的容量是：&quot;</span> + sb2.capacity());   <span class="comment">//20</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb2的长度是：&quot;</span> + sb2.length());     <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">StringBuilder sb3 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb3的容量是：&quot;</span> + sb3.capacity());    <span class="comment">//16+5=21</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb3的长度是：&quot;</span> + sb3.length());      <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder insert(int offset, String str)</td>
<td>插入字符串并返回调用对象的引用，就是自己。</td>
</tr>
<tr>
<td>StringBuilder append(String str)</td>
<td>追加字符串</td>
</tr>
<tr>
<td>StringBuilder deleteCharAt(int index)</td>
<td>将当前字符串中下标为index位置的单个字符删除</td>
</tr>
<tr>
<td>StringBuilder delete(int start，int end)</td>
<td>删除字符串</td>
</tr>
<tr>
<td>StringBuilder replace(int start，int end，String str)</td>
<td>替换字符串</td>
</tr>
<tr>
<td>void setCharAt(int index, char ch)</td>
<td>指定索引处的字符设置为 ch 。</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>字符串反转</td>
</tr>
<tr>
<td>查询操作与String类差不多。。。。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">sb1.insert(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//he123llo</span></span><br><span class="line">sb1.append(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//he123lloword</span></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">sb1.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//he23lloword</span></span><br><span class="line">sb1.delete(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//helloword</span></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">sb1.setCharAt(<span class="number">0</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//Helloword</span></span><br><span class="line">sb1.replace(<span class="number">5</span>,<span class="number">9</span>, <span class="string">&quot;Teacher&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//Helloteacher</span></span><br><span class="line"><span class="comment">//反转操作</span></span><br><span class="line">sb1.reverse();</span><br><span class="line">System.out.println(<span class="string">&quot;sb1 = &quot;</span> + sb1);  <span class="comment">//rehcaetolleH</span></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">System.out.println(<span class="string">&quot;索引为1的字符是：&quot;</span> + sb1.charAt(<span class="number">1</span>) );     <span class="comment">//e</span></span><br><span class="line">System.out.println(<span class="string">&quot;e第一次出现的位置的下标是：&quot;</span> + sb1.indexOf(<span class="string">&quot;e&quot;</span>) );  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</p>
<p><strong>自动扩容机制</strong></p>
<p>当StringBuffer和StringBuilder中的字符串长度超过了原始的容量。容量会自动扩容。<br>扩容后容量 = 原始容量 * 2 + 2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动扩容机制</span></span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1的容量是：&quot;</span> + sb1.capacity());  <span class="comment">//16+5=21</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb1的长度是：&quot;</span> + sb1.length());    <span class="comment">//5</span></span><br><span class="line"><span class="comment">//增加，但没超过原始容量</span></span><br><span class="line">sb1.append(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1的容量是：&quot;</span> + sb1.capacity());  <span class="comment">//21</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb1的长度是：&quot;</span> + sb1.length());    <span class="comment">//9</span></span><br><span class="line"><span class="comment">//增加，并且超过了原始容量，sb1将自动扩容。</span></span><br><span class="line">sb1.append(<span class="string">&quot;1234567890123456&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sb1的容量是：&quot;</span> + sb1.capacity());  <span class="comment">//21*2+2=44</span></span><br><span class="line">System.out.println(<span class="string">&quot;sb1的长度是：&quot;</span> + sb1.length());    <span class="comment">//25</span></span><br></pre></td></tr></table></figure>

<p><strong>考点</strong></p>
<ul>
<li><p>1，既然StringBuilder类的对象本身可以被改变，为什么成员方法还要返回值，返回本身。<br>答：为了连续调用，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb1.append(<span class="string">&quot;1&quot;</span>).append(<span class="string">&quot;5&quot;</span>).reverse().delete(<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>2，如何实现String和StringBuilder之间的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;213456&quot;</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(s1);</span><br><span class="line">String s2 = sb1.toString();</span><br></pre></td></tr></table></figure></li>
<li><p>3，String、StringBuilder和StringBuffer效率排序：</p>
<pre><code>  低到高：String &lt; StringBuffer &lt; StringBuilder
</code></pre>
</li>
</ul>
<h2 id="Java8以前时间相关类"><a href="#Java8以前时间相关类" class="headerlink" title="Java8以前时间相关类"></a>Java8以前时间相关类</h2><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>Java.lang.System类中提供了一些有用的类字段和方法。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static long currentTimeMillis()</td>
<td>返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差（时间戳）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">System.out.println(l);   <span class="comment">//1640670878418</span></span><br></pre></td></tr></table></figure>

<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>java.util.Date类主要用于描述特定的瞬间，也就是年月日时分秒，可以精确到毫秒。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Date()</td>
<td>使用无参的方式构造对象，也就是当前系统时间</td>
</tr>
<tr>
<td>Date(long date)</td>
<td>根据参数指定毫秒数构造对象， 参数为距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>long getTime()</td>
<td>获取调用对象距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>void setTime(long time)</td>
<td>设置调用对象为距离基准时间time毫秒的时间点</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前系统时间</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d1);  <span class="comment">//Tue Dec 28 10:39:07 CST 2021</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//距离基准时间相差1000毫秒的时间</span></span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">1000</span>);</span><br><span class="line">System.out.println(d2);  <span class="comment">//Thu Jan 01 08:00:01 CST 1970  (东八区，所以超了八小时)</span></span><br><span class="line"><span class="comment">//对象时间与基准时间的相差毫秒</span></span><br><span class="line"><span class="keyword">long</span> l = d2.getTime();</span><br><span class="line">System.out.println(l);   <span class="comment">//1000</span></span><br><span class="line"><span class="comment">//更改对象时间与基准时间相差的毫秒</span></span><br><span class="line">d2.setTime(<span class="number">2000</span>);</span><br><span class="line">System.out.println(d2);  <span class="comment">//Thu Jan 01 08:00:02 CST 1970  (东八区，所以超了八小时)</span></span><br></pre></td></tr></table></figure>

<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>java.text.SimpleDateFormat类主要用于实现日期和文本之间的转换。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SimpleDateFormat()</td>
<td>使用无参方式构造对象</td>
</tr>
<tr>
<td>SimpleDateFormat(String pattern)</td>
<td>根据参数指定的模式来构造对象，模式主要有: y-年 M-月 d-日H-时 m-分 s-秒</td>
</tr>
<tr>
<td>fifinal String format(Date date)</td>
<td>用于将日期类型转换为文本类型</td>
</tr>
<tr>
<td>Date parse(String source)</td>
<td>用于将文本类型转换为日期类型</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Date now = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//设定时间格式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd  HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">String s = sdf.format(now);</span><br><span class="line">System.out.println(s);       <span class="comment">//2021-12-28  10:49:42</span></span><br><span class="line">Date now1 = sdf.parse(s);</span><br><span class="line">System.out.println(now1);    <span class="comment">//Tue Dec 28 10:49:42 CST 2021</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>java.util.Calender类主要用于描述特定的瞬间，取代Date类中的过时方法实现全球化。</p>
<p>该类是个抽象类，因此不能实例化对象，其具体子类针对不同国家的日历系统，其中应用最广泛的<br>是GregorianCalendar（格里高利历），对应世界上绝大多数国家/地区使用的标准日历系统。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static Calendar getInstance()</td>
<td>用于获取Calendar类型的引用</td>
</tr>
<tr>
<td>void set(int year, int month, int date, int hourOfDay, int minute, int second)</td>
<td>用于设置年月日时分秒信息，月份需减一</td>
</tr>
<tr>
<td>void set(int fifield, int value)</td>
<td>设置指定字段的数值</td>
</tr>
<tr>
<td>void add(int fifield, int amount)</td>
<td>向指定字段增加数值</td>
</tr>
<tr>
<td>Date getTime()</td>
<td>用于将Calendar类型转换为Date类型</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Calendar实例</span></span><br><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line"><span class="comment">//设置时间，月份需要减一</span></span><br><span class="line">c1.set(<span class="number">2020</span>, <span class="number">12</span>-<span class="number">1</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">30</span>,<span class="number">00</span>);</span><br><span class="line">c1.set(Calendar.YEAR, <span class="number">2021</span>);</span><br><span class="line">c1.add(Calendar.DAY_OF_MONTH, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//将Calendar类型转换从Date类型</span></span><br><span class="line">Date d1 = c1.getTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常打印对应格式的时间</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日  HH:mm:ss&quot;</span>);</span><br><span class="line">String s1 = sdf.format(d1);</span><br><span class="line">System.out.println(s1);   <span class="comment">//2021年12月15日  08:30:00</span></span><br></pre></td></tr></table></figure>

<h2 id="Java8以后时间相关类"><a href="#Java8以后时间相关类" class="headerlink" title="Java8以后时间相关类"></a>Java8以后时间相关类</h2><p><strong>java8以前</strong></p>
<p>JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。</p>
<p>而Calendar并不比Date好多少。它们面临的问题是：</p>
<ul>
<li><p>Date类中的年份是从1900开始的，而月份都从0开始。</p>
</li>
<li><p>格式化只对Date类有用，对Calendar类则不能使用。</p>
</li>
<li><p>非线程安全等。</p>
</li>
</ul>
<p><strong>Java8以后</strong></p>
<ul>
<li><p>Java 8通过发布新的Date-Time API来进一步加强对 日期与时间的处理。</p>
</li>
<li><p>java.time包：该包日期/时间API的基础包。</p>
</li>
<li><p>java.time.chrono包：该包提供对不同日历系统的访问。 </p>
</li>
<li><p>java.time.format包：该包能够格式化和解析日期时间对象。</p>
</li>
<li><p>java.time.temporal包：该包包含底层框架和扩展特性。</p>
</li>
<li><p>java.time.zone包：该包支持不同时区以及相关规则的类。</p>
</li>
</ul>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>java.time.LocalDate类主要用于描述年-月-日格式的日期信息，该类不表示时间和时区信息。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static LocalDate now()</td>
<td>在默认时区中从系统时钟获取当前日期</td>
</tr>
</tbody></table>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>java.time.LocalTime 类主要用于描述时间信息，可以描述时分秒以及纳秒。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static LocalTime now()</td>
<td>从默认时区的系统时间中获取当前时间</td>
</tr>
<tr>
<td>static LocalTime now(ZoneId zone)</td>
<td>获取指定时区的当前时间</td>
</tr>
</tbody></table>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>java.time.LocalDateTime类主要用于描述ISO-8601日历系统中没有时区的日期时间，如2007-12-03T10:15:30。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static LocalDateTime now()</td>
<td>从默认时区的系统时间中获取当前日期时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate now1 = LocalDate.now();</span><br><span class="line">System.out.println(now1);            <span class="comment">//2021-12-28</span></span><br><span class="line"></span><br><span class="line">LocalTime now2 = LocalTime.now();</span><br><span class="line">System.out.println(now2);            <span class="comment">//14:23:29.800789600</span></span><br><span class="line"></span><br><span class="line">LocalDateTime now3 = LocalDateTime.now();</span><br><span class="line">System.out.println(now3);            <span class="comment">//2021-12-28T14:23:29.800789600</span></span><br></pre></td></tr></table></figure>

<p>其他成员方法</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)</td>
<td>根据参数指定的年月日时分秒信息来设置日期时间</td>
</tr>
<tr>
<td>int getYear()</td>
<td>获取年份字段的数值</td>
</tr>
<tr>
<td>int getMonthValue()</td>
<td>获取1到12之间的月份字段</td>
</tr>
<tr>
<td>int getDayOfMonth()</td>
<td>获取日期字段</td>
</tr>
<tr>
<td>int getHour()</td>
<td>获取小时数</td>
</tr>
<tr>
<td>int getMinute()</td>
<td>获取分钟数</td>
</tr>
<tr>
<td>int getSecond()</td>
<td>获取秒数</td>
</tr>
<tr>
<td>LocalDateTime withYear(int year)</td>
<td>设置为参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime withMonth(int month)</td>
<td>设置为参数指定的月</td>
</tr>
<tr>
<td>LocalDateTime withDayOfMonth(int dayOfMonth)</td>
<td>设置为参数指定的日</td>
</tr>
<tr>
<td>LocalDateTime withHour(int hour)</td>
<td>设置为参数指定的时</td>
</tr>
<tr>
<td>LocalDateTime withMinute(int minute)</td>
<td>设置为参数指定的分</td>
</tr>
<tr>
<td>LocalDateTime withSecond(int second)</td>
<td>设置为参数指定的秒</td>
</tr>
<tr>
<td>LocalDateTime plusYears(long years)</td>
<td>加上参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime plusMonths(long months)</td>
<td>加上参数指定的月</td>
</tr>
<tr>
<td>LocalDateTime plusDays(long days)</td>
<td>加上参数指定的日</td>
</tr>
<tr>
<td>LocalDateTime plusHours(long hours)</td>
<td>加上参数指定的时</td>
</tr>
<tr>
<td>LocalDateTime plusMinutes(long minutes)</td>
<td>加上参数指定的分</td>
</tr>
<tr>
<td>LocalDateTime plusSeconds(long seconds)</td>
<td>加上参数指定的秒</td>
</tr>
<tr>
<td>LocalDateTime minusYears(long years)</td>
<td>减去参数指定的年</td>
</tr>
<tr>
<td>LocalDateTime minusMonths(long months)</td>
<td>减去参数指定的月</td>
</tr>
<tr>
<td>LocalDateTime minusDays(long days)</td>
<td>减去参数指定的日</td>
</tr>
<tr>
<td>LocalDateTime minusHours(long hours)</td>
<td>减去参数指定的时</td>
</tr>
<tr>
<td>LocalDateTime minusMinutes(long minutes)</td>
<td>减去参数指定的分</td>
</tr>
<tr>
<td>LocalDateTime minusSeconds(long seconds)</td>
<td>减去参数指定的秒</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定时间</span></span><br><span class="line">LocalDateTime time = LocalDateTime.of(<span class="number">2021</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">30</span>,<span class="number">00</span>);</span><br><span class="line"><span class="comment">//重新设定年</span></span><br><span class="line">time = time.withYear(<span class="number">2020</span>);</span><br><span class="line"><span class="comment">//加上指定年</span></span><br><span class="line">time = time.plusYears(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//减去指定年</span></span><br><span class="line">time = time.minusYears(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//获取年</span></span><br><span class="line"><span class="keyword">int</span> year = time.getYear();</span><br><span class="line">System.out.println(year);    <span class="comment">//2019</span></span><br></pre></td></tr></table></figure>

<h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><p>java.time.format.DateTimeFormatter类主要用于格式化和解析日期。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static DateTimeFormatter ofPattern(String pattern)</td>
<td>根据参数指定的模式来获取对象</td>
</tr>
<tr>
<td>String format(TemporalAccessor temporal)</td>
<td>将参数指定日期时间转换为字符串</td>
</tr>
<tr>
<td>TemporalAccessor parse(CharSequence text)</td>
<td>将参数指定字符串转换为日期时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前时间</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"><span class="comment">//1,设定时间格式</span></span><br><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日  HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">String s = dtf.format(now);</span><br><span class="line">System.out.println(s);      <span class="comment">//2021年12月28日  11:50:45</span></span><br><span class="line"></span><br><span class="line">TemporalAccessor date = dtf.parse(s);</span><br><span class="line">System.out.println(date);   <span class="comment">//&#123;&#125;,ISO resolved to 2021-12-28T11:50:45</span></span><br></pre></td></tr></table></figure>

<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>java.time.Instant类主要用于描述瞬间的时间点信息。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Instant now()</td>
<td>从系统时钟上获取当前时间</td>
</tr>
<tr>
<td>OffsetDateTime atOffset(ZoneOffset offset)</td>
<td>将此瞬间与偏移量组合以创建偏移日期时间</td>
</tr>
<tr>
<td>static Instant ofEpochMilli(long epochMilli)</td>
<td>根据参数指定的毫秒数来构造对象，参数为距离1970年1月1 日0时0分0秒的毫秒数</td>
</tr>
<tr>
<td>long toEpochMilli()</td>
<td>获取距离1970年1月1日0时0分0秒的毫秒数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line">System.out.println(now);       <span class="comment">//与本地时间相差8小时，</span></span><br><span class="line"><span class="comment">//将now相差的8小时偏移过来，变成本地时间</span></span><br><span class="line">OffsetDateTime now2 = now.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(now2);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据毫秒数创建时间</span></span><br><span class="line">Instant time = Instant.ofEpochMilli(<span class="number">1000</span>);</span><br><span class="line">System.out.println(time);    <span class="comment">//1970-01-01T00:00:01Z</span></span><br><span class="line"><span class="comment">//对象时间与基准时间相差的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> l = time.toEpochMilli();</span><br><span class="line">System.out.println(l);    <span class="comment">//1000</span></span><br></pre></td></tr></table></figure>

<h2 id="集合类库-上"><a href="#集合类库-上" class="headerlink" title="集合类库(上)"></a>集合类库(上)</h2><p><strong>集合的由来</strong></p>
<ul>
<li>当需要在Java程序中记录单个数据内容时，则声明一个变量。</li>
<li>当需要在Java程序中记录多个类型相同的数据内容时，声明一个一维数组。 </li>
<li>当需要在Java程序中记录多个类型不同的数据内容时，则创建一个对象。</li>
<li>当需要在Java程序中记录多个类型相同的对象数据时，创建一个对象数组。 </li>
<li>当需要在Java程序中记录多个类型不同的对象数据时，则准备一个集合。<br>（注意集合可以记录类型不同的对象，但是也可以记录类型相同的对象。）</li>
</ul>
<p><strong>集合的框架结构</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TfqsJ0"><img src="https://s4.ax1x.com/2021/12/31/TfqsJ0.png" alt="TfqsJ0.png"></a></p>
<ul>
<li>Java中集合框架顶层框架是：java.util.Collection集合 和 java.util.Map集合。</li>
<li>其中Collection集合中存取元素的基本单位是：单个元素。</li>
<li>其中Map集合中存取元素的基本单位是：单对元素。</li>
</ul>
<h3 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h3><p>java.util.Collection接口是List接口、Queue 接口以及Set接口的父接口，<br>因此该接口里定义的方法既可用于操作List集合，也可用于操作Queue集合和Set集合。</p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e);</td>
<td>向集合中添加对象</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>用于将参数指定集合c中的所有元素添加到当前集合中</td>
</tr>
<tr>
<td>boolean contains(Object o);</td>
<td>判断是否包含指定对象</td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td>判断是否包含参数指定的所有对象</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td>保留当前集合中存在且参数集合中存在的所有对象（取交集保留到所调用集合）</td>
</tr>
<tr>
<td>boolean remove(Object o);</td>
<td>从集合中删除对象</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td>从集合中删除参数指定的所有对象</td>
</tr>
<tr>
<td>void clear();</td>
<td>清空集合</td>
</tr>
<tr>
<td>int size();</td>
<td>返回包含对象的个数</td>
</tr>
<tr>
<td>boolean isEmpty();</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>boolean equals(Object o)</td>
<td>判断是否相等</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>获取当前集合的哈希码值</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>将集合转换为数组</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>获取当前集合的迭代器</td>
</tr>
</tbody></table>
<p>add()和addAll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(c1);    <span class="comment">//[]</span></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">c1.add(<span class="number">1</span>);      <span class="comment">//自动装箱机制</span></span><br><span class="line">c1.add(<span class="string">&quot;abc&quot;</span>);  <span class="comment">//常量池</span></span><br><span class="line">c1.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">System.out.println(c1);   <span class="comment">//[1, abc, Person&#123;name=&#x27;张飞&#x27;, id=1&#125;], 相当于输出每个元素的toString()方法</span></span><br><span class="line"></span><br><span class="line">c2.add(<span class="number">5</span>);</span><br><span class="line">c2.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">System.out.println(c2);   <span class="comment">//[5, one]</span></span><br><span class="line">c1.addAll(c2);       </span><br><span class="line">System.out.println(c1); <span class="comment">//[1, abc, Person&#123;name=&#x27;张飞&#x27;, id=1&#125;, 5, one]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//考点： c1.add(c2); 和 c1.addAll(c2); 的区别。</span></span><br><span class="line"><span class="comment">//c1.add(c2);    把c2当作整体添加到c1中---&gt;[1, abc, Person&#123;name=&#x27;张飞&#x27;, id=1&#125;, [5, one]]</span></span><br><span class="line"><span class="comment">//c1.addAll(c2); 把c2的每个元素依次添加到c1中---&gt;[1, abc, Person&#123;name=&#x27;张飞&#x27;, id=1&#125;, 5, one]</span></span><br></pre></td></tr></table></figure>

<p>contains()和containsAll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.add(<span class="number">1</span>);</span><br><span class="line">c1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">c1.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">System.out.println(c1);    <span class="comment">//[1, one, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试contains()</span></span><br><span class="line"><span class="keyword">boolean</span> b = c1.contains(<span class="number">1</span>);</span><br><span class="line">System.out.println(b);   <span class="comment">//true</span></span><br><span class="line">b = c1.contains(<span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;张飞&quot;</span>));   </span><br><span class="line">System.out.println(b);   <span class="comment">//false      因为没有重写Person的equals()方法。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过源代码可知，contains判断是否包含的原理是调用 Objects.equals();方法。即：</span><br><span class="line">return a == b || a != null &amp;&amp; a.equals(b);   返回true包含，false不包含</span><br><span class="line">先判断地址是否相同：参数对象==集合元素</span><br><span class="line">然后判断参数对象不是null的前提下，调用：参数对象.equalse(集合元素)</span><br><span class="line">由于上面的Person类没有重写equels方法，所以默认判断地址是否相同。</span><br><span class="line">很明显两个张飞内存地址不相同，所以判断是否包含张飞时，返回false。</span><br><span class="line">假如我们在Person类中重写了equals方法，使得基于id相同，返回true的话。</span><br><span class="line">此时再判断是否包含张飞时，返回true。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试containsAll()</span></span><br><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c2.add(<span class="number">1</span>);</span><br><span class="line">c2.add(<span class="number">2</span>);</span><br><span class="line">System.out.println(c2);   <span class="comment">//[1, 2]</span></span><br><span class="line"></span><br><span class="line">b = c1.containsAll(c2);</span><br><span class="line">System.out.println(b);     <span class="comment">//false   因为没有全部包含</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//考点：c1.contains(c2); 和 c1.containsAll(c2); 区别。</span></span><br><span class="line"><span class="comment">//c1.contains(c2);     判断c1是否包含c2这个集合整体</span></span><br><span class="line"><span class="comment">//c1.containsAll(c2);  判断c1是否包含c2中的所有元素</span></span><br></pre></td></tr></table></figure>

<p>remove() 和  removeAll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.add(<span class="number">1</span>);</span><br><span class="line">c1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">c1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(c1);   <span class="comment">//[1, one, hello]</span></span><br><span class="line"><span class="comment">//remover()</span></span><br><span class="line">c1.remove(<span class="number">2</span>);</span><br><span class="line">System.out.println(c1);   <span class="comment">//[1, one, hello]</span></span><br><span class="line">c1.remove(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">System.out.println(c1);   <span class="comment">//[1, hello]</span></span><br><span class="line"><span class="comment">//removeAll()</span></span><br><span class="line">Collection c2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c2.add(<span class="number">1</span>);</span><br><span class="line">c2.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">c1.removeAll(c2);</span><br><span class="line">System.out.println(c1);   <span class="comment">//[]</span></span><br><span class="line"><span class="comment">//包含就删，没有包含就不删。删除原理也是调用Objects.equals()，判断是true就表示包含，并删除。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//考点：c1.remove(c2); 和 c1.removeAll(c2);区别。</span></span><br><span class="line"><span class="comment">//c1.remove(c2)      c1删除c2这个集合整体</span></span><br><span class="line"><span class="comment">//c1.reomveAll(c2)   c1删除c2中的所有元素</span></span><br></pre></td></tr></table></figure>

<p><strong>集合和数组的转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">c1.add(<span class="number">2</span>);</span><br><span class="line">c1.add(<span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;张飞&quot;</span>));</span><br><span class="line"><span class="comment">//c1集合转数组</span></span><br><span class="line">Object[] arr = c1.toArray();</span><br><span class="line">System.out.println( Arrays.toString(arr) );   <span class="comment">//打印数组arr：[one, 2, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br><span class="line"><span class="comment">//arr数组转集合</span></span><br><span class="line">Collection c2 = Arrays.asList(arr);</span><br><span class="line">System.out.println(c2);   		 <span class="comment">//打印集合c2：[one, 2, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><ul>
<li>java.util.Iterator接口主要用于描述迭代器对象，可以遍历Collection集合中的所有元素。</li>
<li>java.util.Collection接口继承Iterable接口，因此所有实现Collection接口的实现类都可以使用该迭 代器对象。</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断集合中是否有可以迭代/访问的元素</td>
</tr>
<tr>
<td>E next()</td>
<td>用于取出一个元素并指向下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>用于删除访问到的最后一个元素</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.add(<span class="number">1</span>);</span><br><span class="line">c1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">c1.add(<span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">System.out.println(c1);       <span class="comment">//[1, one, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br><span class="line"><span class="comment">//生成迭代器iterator1</span></span><br><span class="line">Iterator iterator1 = c1.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">    Object obj = iterator1.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;one&quot;</span>.equals(obj))&#123;</span><br><span class="line">        iterator1.remove();    <span class="comment">//删除next最近一个访问的元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(c1);    <span class="comment">//[1, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>用迭代器模拟集合提供的toString</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.add(<span class="number">1</span>);</span><br><span class="line">c1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">c1.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">System.out.println( c1.toString() );       <span class="comment">//[1, one, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]，模拟此格式</span></span><br><span class="line"><span class="comment">//用迭代器模拟toString打印</span></span><br><span class="line">Iterator iterator1 = c1.iterator();</span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();   <span class="comment">//存放打印的内容</span></span><br><span class="line">sb1.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Object obj = iterator1.next();</span><br><span class="line">    <span class="comment">//判断是不是最后一个元素。</span></span><br><span class="line">    <span class="keyword">if</span>(!iterator1.hasNext())&#123;</span><br><span class="line">        sb1.append(obj).append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sb1.append(obj).append(<span class="string">&quot;,&quot;</span>).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb1);   <span class="comment">//[1, one, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><ul>
<li><p>Java5推出了增强型for循环语句，可以应用数组和集合的遍历。  </p>
</li>
<li><p>是经典迭代的“简化版”。</p>
</li>
<li><p>格式：for(元素类型 变量名 :  数组/集合名称)  {循环体;}</p>
</li>
<li><p>不断地从数组/集合中取出一个元素赋值给变量名并执行循环体，直到取完所有元素为止。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for each遍历集合</span></span><br><span class="line">Collection c1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">c1.add(<span class="number">1</span>);</span><br><span class="line">c1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">c1.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">System.out.println( c1.toString() );       <span class="comment">//[1, one, Person&#123;id=1, name=&#x27;张飞&#x27;&#125;]</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : c1)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for each遍历数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i += <span class="number">5</span>;    <span class="comment">//不改变原始数组数据。</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));    <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TfqsJ0"><img src="https://s4.ax1x.com/2021/12/31/TfqsJ0.png" alt="TfqsJ0.png"></a></p>
<ul>
<li>java.util.List集合是Collection集合的子集合，该集合中允许有重复的元素并且有先后放入次序。<br>该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。</li>
</ul>
<p>实现类：</p>
<ul>
<li>其中ArrayList类的底层是采用动态数组进行数据管理的，支持下标访问，增删元素不方便。</li>
<li>其中LinkedList类的底层是采用双向链表进行数据管理的，访问不方便，增删元素方便。</li>
</ul>
<p>可以认为ArrayList和LinkedList的方法在逻辑上完全一样，只是在性能上有一定的差别，ArrayList 更适合于随<br>机访问而LinkedList更适合于插入和删除；在性能要求不是特别苛刻的情形下可以忽略这个差别。</p>
<ul>
<li>其中Stack类的底层是采用动态数组进行数据管理的，该类主要用于描述一种具有后进先出特征的数据结构，<br>叫做栈(last in ﬁrst out LIFO)。</li>
<li>其中Vector类的底层是采用动态数组进行数据管理的，该类与ArrayList类相比属于线程安全的类，效率比较低，<br>以后开发中基本不用。</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, E element)</td>
<td>向集合中指定位置添加元素</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td>向集合中添加所有元素</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>从集合中获取指定位置元素</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td>查找参数指定的对象</td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td>反向查找参数指定的对象</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>修改指定位置的元素</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定位置的元素</td>
</tr>
<tr>
<td>List subList(int fromIndex, int toIndex)</td>
<td>用于获取子List</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List l = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">l.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">l.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(l);   <span class="comment">//[one, 1]</span></span><br><span class="line">l.add(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(l);   <span class="comment">//[one, hello, 1]</span></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">l.remove(<span class="number">2</span>);</span><br><span class="line">System.out.println(l);   <span class="comment">//[one, hello]</span></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">l.set(<span class="number">0</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">System.out.println(l);   <span class="comment">//[two, hello]</span></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">Object obj = l.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(obj);   <span class="comment">//two</span></span><br><span class="line"><span class="keyword">int</span> i = l.indexOf(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(i);   <span class="comment">//1</span></span><br><span class="line"><span class="comment">//获取子list</span></span><br><span class="line">List l2 = l.subList(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(l2);     <span class="comment">//[two]</span></span><br></pre></td></tr></table></figure>

<p><strong>stack实现类</strong>（栈，后进先出）</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stack()</td>
<td>创建一个空堆栈</td>
</tr>
<tr>
<td>boolean empty()</td>
<td>测试此堆栈是否为空。</td>
</tr>
<tr>
<td>E pop()</td>
<td>移除此堆栈顶部的对象，并将该对象作为此函数的值返回。</td>
</tr>
<tr>
<td>E push(E item)</td>
<td>将项目推到此堆栈的顶部。</td>
</tr>
<tr>
<td>E peek()</td>
<td>查看此堆栈顶部的对象，而不将其从堆栈中删除。</td>
</tr>
</tbody></table>
<ul>
<li>案例题目<br>准备一个Stack集合，将数据11、22、33、44、55依次入栈并打印，然后查看栈顶元素并打印， 然后将栈中所有数据依次出栈并打印。<br>再准备一个Stack对象，将数据从第一个栈中取出来放入第二个栈中，然后再从第二个栈中取出并   打印。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stack st = <span class="keyword">new</span> Stack();    <span class="comment">//[]</span></span><br><span class="line">Stack st2 = <span class="keyword">new</span> Stack();   <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st进栈：11，22，33，44，55</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    st.push(i*<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(st);    <span class="comment">//[11, 22, 33, 44, 55]</span></span><br><span class="line">System.out.println(st.peek());  <span class="comment">//栈顶元素：55</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st出栈:55,44,33,22,11 ,并st2进栈每个元素</span></span><br><span class="line"><span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">    Object obj = st.pop();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    st2.push(obj);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(st2);   <span class="comment">//[55, 44, 33, 22, 11]</span></span><br><span class="line">System.out.println(st2.peek());  <span class="comment">//栈顶元素：11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st2出栈：11，22，33，44，55</span></span><br><span class="line"><span class="keyword">while</span>(!st2.empty())&#123;</span><br><span class="line">    Object obj = st2.pop();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TfqsJ0"><img src="https://s4.ax1x.com/2021/12/31/TfqsJ0.png" alt="TfqsJ0.png"></a></p>
<ul>
<li>java.util.Queue集合是Collection集合的子集合，与List集合属于平级关系。</li>
<li>该集合的主要用于描述具有先进先出特征的数据结构，叫做队列(ﬁrst in ﬁrst out FIFO)。</li>
<li>该集合的主要实现类是LinkedList类，因为该类在增删方面比较有优势。</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean oﬀer(E e)</td>
<td>将一个对象添加至队尾，若添加成功则返回true</td>
</tr>
<tr>
<td>E poll()</td>
<td>从队首删除并返回一个元素</td>
</tr>
<tr>
<td>E peek()</td>
<td>返回队首的元素（但并不删除）</td>
</tr>
</tbody></table>
<ul>
<li>案例题目<br>准备一个Queue集合，将数据11、22、33、44、55依次入队并打印，然后查看队首元素并打印， 然后将队列中所有数据依次出队并打印。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Queue q = <span class="keyword">new</span> LinkedList();   <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进队列：11，22，33，44，55</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line">    q.offer(i*<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(q);   <span class="comment">//[11, 22, 33, 44, 55]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列：11，22，33，44，55</span></span><br><span class="line"><span class="keyword">while</span>(q.peek() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object obj = q.poll();</span><br><span class="line">    System.out.println(obj);   <span class="comment">//11，22，33，44，55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合类库-下"><a href="#集合类库-下" class="headerlink" title="集合类库(下)"></a>集合类库(下)</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li>通常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的，因此  从集合中取出元素时也是Object类型，为了表达该元素真实的数据类型，则需要强制类型转换，  而强制类型转换可能会引发类型转换异常。</li>
<li>为了避免上述错误的发生，从Java5开始增加泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt;     的方式来明确要求该集合中可以存放的元素类型，若放入其它类型的元素则编译报错。</li>
<li>泛型只在编译时期有效，在运行时期不区分是什么类型。</li>
</ul>
<p><strong>原理</strong></p>
<p>泛型的本质就是参数化类型，也就是让数据类型作为参数传递，其中E相当于形式参数负责占位，  而使用集合时&lt;&gt;中的数据类型相当于实际参数，用于给形式参数E进行初始化，从而使得集合中所   有的E被实际参数替换，由于实际参数可以传递各种各样广泛的数据类型，因此得名为泛型。<br>如：<br>//其中i叫做形式参数，负责占位<br>//int i = 10;<br>//int i = 20;<br>public static void show(int i) {<br>    …<br>}<br>//其中10叫做实际参数，负责给形式参数初始化<br>show(10);<br>show(20);        </p>
<p>如：<br>//其中E叫做形式参数，负责占位<br>E = String;<br>E = Integer;<br>public interface List&lt;E&gt;{<br>    …<br> }<br>//其中String叫做实际参数<br>List&lt;String&gt; lt1 = …;<br>List&lt;Integer&gt; lt2 = …;</p>
<h4 id="定义泛型接口"><a href="#定义泛型接口" class="headerlink" title="定义泛型接口"></a>定义泛型接口</h4><p>泛型接口和普通接口的区别就是后面添加了类型参数列表，可以有多个类型参数，如：&lt;E, T, .. &gt;<br>等。</p>
<h4 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h4><ul>
<li>泛型类和普通类的区别就是类名后面添加了类型参数列表，可以有多个类型参数，如：&lt;E, T, .. &gt;<br>等。</li>
<li>实例化泛型类时应该指定具体的数据类型，并且是引用数据类型而不是基本数据类型。 </li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。</li>
<li>子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> E gender;   <span class="comment">//gender的数据类型是E，E是什么类型由创建对象决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, E gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(E gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;String&gt; t1 = <span class="keyword">new</span> Person&lt;&gt;(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;男&quot;</span>);   <span class="comment">//将E赋值为String</span></span><br><span class="line">Person&lt;Boolean&gt; t2 = <span class="keyword">new</span> Person&lt;&gt;(<span class="string">&quot;li&quot;</span>, <span class="keyword">true</span>);  <span class="comment">//将E赋值为Booleean</span></span><br></pre></td></tr></table></figure>

<p>继承关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class SubPerson extends Person &#123;         //不保留的泛型且没有指定类型，此时父类的E默认是Object类型，擦除</span></span><br><span class="line"><span class="comment">//public class SubPerson extends Person&lt;String&gt; &#123; //不保留的泛型但是指定了类型，此时父类的E默认是String类型</span></span><br><span class="line"><span class="comment">//public class SubPerson&lt;E&gt; extends Person&lt;E&gt; &#123;   //保留了父类的泛型，可以在构造方法中指定E的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span>&lt;<span class="title">E</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Person</span>&lt;<span class="title">E</span>&gt; </span>&#123;  <span class="comment">//保留了父类的泛型，同时子类还增加了新的泛型T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h4><ul>
<li>泛型方法就是我们输入参数的时候，输入的是泛型参数，而不是具体的参数。我们在调用这个泛型  方法的时需要对泛型参数进行实例化。</li>
<li>泛型方法的格式：<br>[访问权限] &lt;泛型&gt; 返回值类型 方法名([泛型标识 参数名称]) { 方法体; }</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T <span class="title">show</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s1 = show(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">Integer ia = show(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>如果A和B具备父子类关系，但是List&lt;A&gt;和List&lt;B&gt;不具备父子关系。</p>
<ul>
<li>有时候我们希望传入的类型在一个指定的范围内，此时就可以使用泛型通配符了。</li>
<li>如：之前传入的类型要求为Integer类型，但是后来业务需要Integer的父类Number类也可以传入。</li>
<li>泛型中有三种通配符形式：<?> 无限制通配符：表示我们可以传入任意类型的参数。
<? extends E> 表示类型的上界是E，只能是E或者是E的子类。
<? super E> 表示类型的下界是E，只能是E或者是E的父类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; lt1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;SubPerson&gt; lt2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//lt1 = lt2;    //Error:不具备父子类关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用通配符作为泛型类型的公共父类</span></span><br><span class="line">List&lt;?&gt; lt3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lt3 = lt2;</span><br><span class="line">lt3 = lt1;</span><br><span class="line"><span class="comment">//lt3.add(new Person())    //Eooor:不支持添加元素操作，因为有更小的类型</span></span><br><span class="line">Object obj1 = lt3.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;? extends Person&gt; lt4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//lt4.add(new Person());      //Error:不支持添加元素操作，因为有更小的类型</span></span><br><span class="line">Person p1 = lt4.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;? <span class="keyword">super</span> Person&gt; lt5 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lt5.add(<span class="keyword">new</span> Person());    <span class="comment">//可以添加Person及以下子类型的对象</span></span><br><span class="line">Object obj2 = lt5.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TfqsJ0"><img src="https://s4.ax1x.com/2021/12/31/TfqsJ0.png" alt="TfqsJ0.png"></a></p>
<ul>
<li>java.util.Set集合是Collection集合的子集合，与List集合平级。  </li>
<li>该集合中元素没有先后放入次序，且不允许重复。</li>
</ul>
<p>实现类：HashSet类 和 TreeSet类以及LinkedHashSet类。</p>
<ul>
<li>其中HashSet类的底层是采用哈希表进行数据管理的。</li>
<li>其中TreeSet类的底层是采用红黑树进行数据管理的。</li>
<li>其中LinkedHashSet类与HashSet类的不同之处在于内部维护了一个双向链表，链表中记录了元  素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>参考Collection集合中的方法即可！ </li>
<li>案例题目<br>准备一个Set集合指向HashSet对象，向该集合中添加元素”two”并打印，再向集合中添加元  素”one”并打印，再向集合中添加元素”three”并打印，再向集合中添加”one”并打印。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set1.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">set1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">set1.add(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">set1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">System.out.println(set1);    <span class="comment">//[one, two, three]  没有先后顺序，且不能重复</span></span><br></pre></td></tr></table></figure>

<p><strong>元素放入HashSet原理</strong></p>
<ul>
<li>使用元素调用hashCode方法获取对应的<em>哈希码值</em>，再由某种哈希算法计算出该元素在数组中的索  引位置。</li>
<li>若该位置没有元素，则将该元素直接放入即可。</li>
<li>若该位置有元素，则使用新元素与已有元素依次比较<em>哈希值</em>，若哈希值不相同，则将该元素直接放  入。</li>
<li>若新元素与已有元素的哈希值相同，则使用新元素调用<em>equals方法</em>与已有元素依次比较。  </li>
<li>若相等则添加元素失败，否则将元素直接放入即可。</li>
</ul>
<p>思考：为什么要求重写equals方法后要重写hashCode方法呢？</p>
<p>解析：<br>当两个元素调用equals方法相等时证明这两个元素相同，重写hashCode方法后保证这两个元    素得到的哈希码值相同，由同一个哈希算法生成的索引位置相同，此时只需要与该索引位置已有元  素比较即可，从而提高效率并避免重复元素的出现。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li>二叉树主要指每个节点最多只有两个子节点的树形结构。</li>
<li>满足以下3个特征的二叉树叫做有序二叉树。<br>a.左子树中的任意节点元素都小于根节点元素值；<br>b.右子树中的任意节点元素都大于根节点元素值；<br>c.左子树和右子树的内部也遵守上述规则；</li>
<li>由于TreeSet集合的底层采用红黑树进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定新元素的合理位置。</li>
<li>比较元素大小的规则有两种方式：<br>a.使用元素的自然排序规则进行比较并排序，让元素类型实现java.lang.Comparable接口；<br>b.使用比较器规则进行比较并排序，构造TreeSet集合时传入java.util.Comparator接口；</li>
<li>自然排序的规则比较单一，而比较器的规则比较多元化，而且比较器优先于自然排序；</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TreeSet()</td>
<td>构造一个新的空树集，根据其元素的自然顺序进行排序。</td>
</tr>
<tr>
<td>TreeSet(Comparator&lt;? super E&gt; comparator)</td>
<td>构造一个新的空树集，根据指定的比较器进行排序。</td>
</tr>
</tbody></table>
<p>TreeSet集合中放入String数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(set);   <span class="comment">//[abc, hello, nihao]</span></span><br><span class="line"><span class="comment">//String类型放入TreeSet不需要添加排序，因为String类中官方已经实现了comparable接口。</span></span><br></pre></td></tr></table></figure>

<p>TreeSet集合中放入其他数据需要定义排序规则：</p>
<p>自然排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;   <span class="comment">//元素类型实现java.lang.Comparable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用对象this表示新增的对象，this和o进行比较。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o：Object o 表示集合中已有的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>：0表示相同，丢弃；正数表示大于，放后面；负数表示小于，放前面。（从小到大）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义排序规则：</span></span><br><span class="line">        <span class="comment">//age从小到大，年龄相同按name排序</span></span><br><span class="line">        <span class="keyword">int</span> ia = <span class="keyword">this</span>.age - ((Person)o).age;</span><br><span class="line">        <span class="keyword">int</span> ib = <span class="keyword">this</span>.name.compareTo( ((Person)o).name );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>!=ia ? ia : ib ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">&quot;guanyu&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&quot;zhangfei&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&quot;Li&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">35</span>, <span class="string">&quot;liubei&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<p>比较器排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用匿名内部类创建比较器</span></span><br><span class="line">Comparator  comparetor1 = <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o, Object t1)</span> </span>&#123;  <span class="comment">//o是新增对象，t1是集合中已有对象。</span></span><br><span class="line">        <span class="keyword">int</span> ia = ((Person)o).age - ((Person)t1).age;</span><br><span class="line">        <span class="keyword">int</span> ib = ((Person)o).name.compareTo( ((Person)t1).name );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>!=ia ? ia : ib ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//java8支持Lambda表达式</span></span><br><span class="line">Comparator comparetor2 = (Object o, Object t1) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> ia = ((Person)o).age - ((Person)t1).age;</span><br><span class="line">    <span class="keyword">int</span> ib = ((Person)o).name.compareTo( ((Person)t1).name );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>!=ia ? ia : ib ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(comparetor1);</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">&quot;guanyu&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&quot;zhangfei&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&quot;Li&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">35</span>, <span class="string">&quot;liubei&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure>

<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/TfqsJ0"><img src="https://s4.ax1x.com/2021/12/31/TfqsJ0.png" alt="TfqsJ0.png"></a></p>
<ul>
<li>java.util.Map&lt;K,V&gt;集合中存取元素的基本单位是：单对元素，其中类型参数如下：<br>K - 此映射所维护的键(Key)的类型，相当于目录。<br>V - 映射值(Value)的类型，相当于内容。</li>
<li>该集合中key是不允许重复的，而且一个key只能对应一个value。</li>
</ul>
<p>实现类：HashMap类、TreeMap类、LinkedHashMap类、Hashtable类、Properties类。</p>
<ul>
<li>其中HashMap类的底层是采用哈希表进行数据管理的。 </li>
<li>其中TreeMap类的底层是采用红黑树进行数据管理的。</li>
<li>其中LinkedHashMap类与HashMap类的不同之处在于内部维护了一个双向链表，链表中记录了元素的迭代顺序，也就是元素插入集合中的先后顺序，因此便于迭代。</li>
<li>其中Hashtable类是古老的Map实现类，与HashMap类相比属于线程安全的类，且不允许null作为key或者value的数值。</li>
<li>其中Properties类是Hashtable类的子类，该对象用于处理属性文件，key和value都是String类型的。</li>
</ul>
<p>Map集合是面向查询优化的数据结构, 在大数据量情况下有着优良的查询性能。经常用于根据key检索value的业务场景。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key, V value)</td>
<td>将Key-Value对存入Map，若集合中已经包含该Key，则替换该Key所对应的Value，返回值为该Key原来所对应的Value，若没有则返回null</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据参数指定的key进行删除</td>
</tr>
<tr>
<td>V get(Object key)</td>
<td>返回与参数Key所对应的Value对象，如果不存在则返回null</td>
</tr>
<tr>
<td>boolean containsKey(Object key);</td>
<td>判断集合中是否包含指定的Key</td>
</tr>
<tr>
<td>boolean containsValue (Object value);</td>
<td>判断集合中是否包含指定的Value</td>
</tr>
<tr>
<td>Set keySet()</td>
<td>返回此映射中包含的键的Set视图</td>
</tr>
<tr>
<td>Collection values()</td>
<td>返回此映射中包含的值的Set视图</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td>
<td>返回此映射中包含的映射的Set视图</td>
</tr>
</tbody></table>
<p>基本操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; m1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增改。  无则添加，有则修改</span></span><br><span class="line">m1.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">m1.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Word&quot;</span>);</span><br><span class="line">m1.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">m1.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">System.out.println(m1);   <span class="comment">//&#123;1=nihao, 2=Word&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除。  有则删，无则不删</span></span><br><span class="line">m1.remove(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">System.out.println(m1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">String s1 = m1.get(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(s1);   <span class="comment">//nihao</span></span><br><span class="line"><span class="keyword">boolean</span> b = m1.containsKey(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(b);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>map的三种遍历方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key的视图</span></span><br><span class="line">Set&lt;String&gt; set1 = m1.keySet();</span><br><span class="line">System.out.println(set1);   <span class="comment">//[1, 3]</span></span><br><span class="line"><span class="keyword">for</span>(String s: set1)&#123;</span><br><span class="line">    System.out.println(s + <span class="string">&quot;对应的值是：&quot;</span> + m1.get(s));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//value的视图</span></span><br><span class="line">Collection&lt;String&gt; co1 = m1.values();</span><br><span class="line">System.out.println(co1);   <span class="comment">//[nihao, abc]</span></span><br><span class="line"><span class="keyword">for</span>(String s: co1)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//键值映射的视图</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; set2 = m1.entrySet();</span><br><span class="line">System.out.println(set2);   <span class="comment">//[1=nihao, 3=abc]</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; me: set2)&#123;</span><br><span class="line">    System.out.println(me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元素放入HashMap集合原理</strong></p>
<ul>
<li>使用元素的key调用hashCode方法获取对应的<em>哈希码值</em>，再由某种哈希算法计算在数组中的索引位置。</li>
<li>若该位置没有元素，则将该键值对直接放入即可。</li>
<li>若该位置有元素，则使用key与已有元素依次比较<em>哈希值</em>，若哈希值不相同，则将该元素直接放入。</li>
<li>若key与已有元素的哈希值相同，则使用key调用<em>equals方法</em>与已有元素依次比较。  </li>
<li>若相等则将对应的value修改，否则将键值对直接放入即可</li>
</ul>
<p><strong>相关常量</strong></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量是16。</li>
<li>DEFAULT_LOAD_FACTOR：HashMap 的默认加载因子是 0.75 。                    </li>
<li>threshold： 扩 容 的 临 界 值 ， 该 数 值 为 ： 容 量 * 填 充 因 子 ， 也 就 是 12 。 </li>
<li>TREEIFY_THRESHOLD：若Bucket中链表长度大于该默认值则转化为红黑树存储，该数值是8。</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，该数值是64。</li>
</ul>
<h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p>java.util.Collections类主要提供了对集合操作或者返回集合的静态方法。</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</td>
<td>根据元素的自然顺序返回给定集合的最大元素</td>
</tr>
<tr>
<td>static T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td>
<td>根据指定比较器引发的顺序返回给定集合的最大元素</td>
</tr>
<tr>
<td>static &lt;T extends Object &amp; Comparable&lt;?super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll)</td>
<td>根据元素的自然顺序返回给定集合的最小元素</td>
</tr>
<tr>
<td>static T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</td>
<td>根据指定比较器引发的顺序返回给定集合的最小元素</td>
</tr>
<tr>
<td>static void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</td>
<td>将一个列表中的所有元素复制到另一个列表中</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static void reverse(List&lt;?&gt; list)</td>
<td>反转指定列表中元素的顺序</td>
</tr>
<tr>
<td>static void shuﬄe(List&lt;?&gt; list)</td>
<td>使用默认的随机源随机置换指定的列表</td>
</tr>
<tr>
<td>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list)</td>
<td>根据其元素的自然顺序将指定列表按升序排序</td>
</tr>
<tr>
<td>static void sort(List list, Comparator&lt;? super T&gt; c)</td>
<td>根据指定比较器指定的顺序对指定列表进行排序</td>
</tr>
<tr>
<td>static void swap(List&lt;?&gt; list, int i, int j)</td>
<td>交换指定列表中指定位置的元素</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lt1 = Arrays.asList(<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">Integer ia = Collections.max(lt1);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值是&quot;</span> + ia);</span><br><span class="line">ia = Collections.min(lt1);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值是&quot;</span> + ia);</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy将lt1复制到lt2中</span></span><br><span class="line">List&lt;Integer&gt; lt2 = Arrays.asList(<span class="keyword">new</span> Integer[<span class="number">10</span>]);</span><br><span class="line">Collections.copy(lt2, lt1);</span><br><span class="line">System.out.println(lt2);    <span class="comment">//[9, 1, 2, 5, 3, 11, null, null, null, null]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse反转操作</span></span><br><span class="line">Collections.reverse(lt1);</span><br><span class="line">System.out.println(lt1);    <span class="comment">//[11, 3, 5, 2, 1, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort升序</span></span><br><span class="line">Collections.sort(lt1);</span><br><span class="line">System.out.println(lt1);    <span class="comment">//[1, 2, 3, 5, 9, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//swap交换指定下标元素</span></span><br><span class="line">Collections.swap(lt1, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(lt1);    <span class="comment">//[5, 2, 3, 1, 9, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shuffle随机打乱</span></span><br><span class="line">Collections.shuffle(lt1);</span><br><span class="line">System.out.println(lt1);    <span class="comment">//每次都随机打乱顺序</span></span><br></pre></td></tr></table></figure>

<h1 id="Java核心类库-下"><a href="#Java核心类库-下" class="headerlink" title="Java核心类库(下)"></a>Java核心类库(下)</h1><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/7w6SW8"><img src="https://s4.ax1x.com/2022/01/18/7w6SW8.png" alt="7w6SW8.png"></a></p>
<p>异常就是”不正常”的含义，在Java语言中主要指程序执行中发生的不正常情况。</p>
<ul>
<li>java.lang.Throwable类：是Java语言中错误(Error)和异常(Exception)的超类。</li>
<li>Error类：主要用于描述Java虚拟机无法解决的严重错误，通常无法编码解决，如：JVM挂掉了    等。</li>
<li>Exception类：主要用于描述因编程错误或偶然外在因素导致的轻微错误，通常可以编码解决， 如：0作为除数等。</li>
</ul>
<h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p>java.lang.Exception类是所有异常的超类，主要分为以下两种： </p>
<ul>
<li>RuntimeException ： 运行时异常，也叫作非检测性异常</li>
<li>IOException和其它异常 ： 其它异常，也叫作检测性异常，所谓检测性异常就是指在编译阶段都能被编译器检测出来的异常。</li>
</ul>
<p>其 中 RuntimeException 类 的 主 要 子 类 ： </p>
<ul>
<li>ArithmeticException类 - 算术异常</li>
<li>ArrayIndexOutOfBoundsException类 - 数组下标越界异常</li>
<li>NullPointerException - 空指针异常</li>
<li>ClassCastException - 类型转换异常</li>
<li>NumberFormatException - 数字格式异常</li>
</ul>
<p><strong>注意：</strong><br>当程序执行过程中发生异常但又没有手动处理时，则由Java虚拟机采用默认方式处理异常，而默认处理方式就是：打印异常的名称、异常发生的原因、异常发生的位置以及终止程序。</p>
<p>在以后的开发中尽量使用if条件判断来避免异常的发生。<br>但是过多的if条件判断会导致程序的代码加长、臃肿，可读性差。</p>
<h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><ul>
<li><p>语法格式：<br>try {</p>
<pre><code>编写可能发生异常的代码;
</code></pre>
<p>}<br>catch(异常类型 引用变量名) {</p>
<pre><code>编写针对该类异常的处理代码；
</code></pre>
<p>}<br>…可以有多个catch<br>ﬁnally {</p>
<pre><code>编写无论是否发生异常都要执行的代码；
</code></pre>
<p>}</p>
</li>
<li><p>注意事项<br>a. 当需要编写多个catch分支时，切记小类型应该放在大类型的前面；<br>b. 懒人的写法：catch(Exception e) {}<br>c. ﬁnally通常用于进行善后处理，如：关闭已经打开的文件等。</p>
</li>
<li><p>执行流程<br>try { </p>
<pre><code>a;
b; - 可能发生异常的语句
c;
</code></pre>
<p>}catch(Exception ex) { </p>
<pre><code>d;
</code></pre>
<p>}ﬁnally { </p>
<pre><code>e;
</code></pre>
<p>}<br>当没有发生异常时的执行流程：a b c e;<br>当发生异常时的执行流程：a b d e;</p>
</li>
</ul>
<p><strong>考点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义如下方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//......可能出错代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法，无论有没有异常，show()的返回值都是3</span></span><br><span class="line"><span class="keyword">int</span> ia = show();</span><br><span class="line">System.out.println(<span class="string">&quot;ia = &quot;</span> + ia);   <span class="comment">//ia = 3</span></span><br></pre></td></tr></table></figure>

<h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><p>异常的抛出：在某些特殊情况下有些异常不能处理或者不便于处理时，就可以将该异常转移给该方法的调用者。<br>当方法执行时出现异常，则底层生成一个异常类对象抛出，此时异常代码后续的代码就不再执行</p>
<ul>
<li>语法格式<br>访问权限 返回值类型 方法名称(形参列表) throws 异常类型1,异常类型2,…{ 方法体; }<br>如：<pre><code>public void show() throws IOException&#123;&#125;
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在main中抛出异常相当于交给jvm虚拟机处理</span></span><br><span class="line"><span class="comment">//不建议在main中抛出异常，jvm的负担很重</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="comment">/*throws ArithmeticException*/</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法重写的原则<br>a. 要求方法名相同、参数列表相同以及返回值类型相同，从jdk1.5开始支持返回子类类型；<br>b. 要求方法的访问权限不能变小，可以相同或者变大；<br>c. 要求方法<strong>不能抛出更大的异常</strong>；</li>
</ul>
<p>注意：<br>子类重写的方法不能抛出更大的异常、不能抛出平级不一样的异常，但可以抛出一样的异常、更小的异常以及不抛出异常。</p>
<p>经验分享：<br>若父类中被重写的方法没有抛出异常时，则子类中重写的方法只能进行异常的捕获处理。<br>若一个方法内部又以递进方式分别调用了好几个其它方法，则建议这些方法内可以使用抛出 的方法处理到最后一层进行捕获方式处理。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当需要在程序中表达年龄不合理的情况时，而Java官方又没有提供这种针对性的异常，此时就需要程序员自定义异常加以描述。</p>
<ul>
<li>实现流程<br>a. 自定义名为“xxxException”异常类，并继承Exception类或者其子类。<br>b.提供两个版本的构造方法，一个是无参构造方法，另外一个是字符串作为参数的构造方法。 </li>
<li>异常的产生<br>throw new 异常类型(实参);</li>
</ul>
<p>自定义异常类AgeException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7516993124229948L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装Person类，当年龄不合理时抛出AgeException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> AgeException</span>&#123;<span class="comment">//抛出异常</span></span><br><span class="line">        setAge(age);</span><br><span class="line">        setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> AgeException</span>&#123;<span class="comment">//抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(age&gt;=<span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//抛出自定义的异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AgeException(<span class="string">&quot;年龄不合理哦！&quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhang&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(AgeException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;p1 = &quot;</span> + p1);</span><br><span class="line">    <span class="comment">//对于自己抛出的异常，需要异常处理，</span></span><br><span class="line">    <span class="comment">//假如在抛出自定义异常时，立马try,catch处理，结果将是：p1 = Person&#123;name=&#x27;zhang&#x27;, age=0&#125;</span></span><br><span class="line">    <span class="comment">//假如如上代码，抛出自定义异常时，再利用throws抛出外面处理，结果将是：null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java采用的异常处理机制是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>java.io.File类主要用于描述文件或目录路径的抽象表示信息，可以获取文件或目录的特征信息， 如：大小等。</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能概述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>根据参数指定的路径名来构造对象</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>根据参数指定的父路径和子路径信息构造对象</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td>根据参数指定的父抽象路径和子路径信息构造对象</td>
</tr>
<tr>
<td>boolean exists()</td>
<td>测试此抽象路径名表示的文件或目录是否存在</td>
</tr>
<tr>
<td>String getName()</td>
<td>用于获取文件的名称</td>
</tr>
<tr>
<td>long length()</td>
<td>返回由此抽象路径名表示的文件的长度</td>
</tr>
<tr>
<td>long lastModiﬁed()</td>
<td>用于获取文件的最后一次修改时间</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>用于获取绝对路径信息</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>用于删除文件，当删除目录时要求是空目录</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>用于创建新的空文件</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>用于创建目录</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>用于创建多级目录</td>
</tr>
<tr>
<td>File[] listFiles()</td>
<td>获取该目录下的所有内容</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断是否为文件</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断是否为目录</td>
</tr>
<tr>
<td>File[] listFiles(FileFilter ﬁlter)</td>
<td>获取目录下满足筛选器的所有内容</td>
</tr>
</tbody></table>
<p>文件操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造File类型的对象和“d:/a.txt”相关联</span></span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:/a.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(f1.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称是&quot;</span> + f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度是&quot;</span> + f1.length());</span><br><span class="line">        <span class="keyword">long</span> l = f1.lastModified();</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(l);</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日，HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最后一次修改日期&quot;</span> + sdf.format(date));</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径是&quot;</span> + f1.getAbsolutePath());</span><br><span class="line">        System.out.println(f1.delete() ? <span class="string">&quot;删除成功&quot;</span> : <span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(f1.createNewFile() ? <span class="string">&quot;创建成功&quot;</span> : <span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f1.exists())&#123;</span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        System.out.println(f1.delete() ? <span class="string">&quot;删除成功&quot;</span> : <span class="string">&quot;删除失败&quot;</span>);<span class="comment">//目录为空时才能删除</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(f1.mkdirs() ? <span class="string">&quot;创建成功&quot;</span> : <span class="string">&quot;创建失败&quot;</span>);<span class="comment">//mkdirs()创建多级目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(f1.exists())&#123;</span><br><span class="line">    File[] f1Array = f1.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File f : f1Array)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f.isDirectory())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + f.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用筛选器遍历目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义筛选器，筛选出以.docx结尾的文件</span></span><br><span class="line">FileFilter ff1 = <span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//返回true筛选出来, 返回false不筛选</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file.getName().endsWith(<span class="string">&quot;docx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda表达式定义筛选器</span></span><br><span class="line">FileFilter ff2 = (File file) -&gt; &#123; <span class="keyword">return</span> file.getName().endsWith(<span class="string">&quot;.docx&quot;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);</span><br><span class="line">File[] f1Array = f1.listFiles(ff1);</span><br><span class="line"><span class="keyword">for</span>(File f : f1Array)&#123;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历目录及其子目录，可以利用方法的递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印某目录下及其子目录所有的.docx文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String pathName)</span></span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(pathName);</span><br><span class="line">    File[] f1Array = f1.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(f1Array != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f : f1Array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f.isFile() &amp;&amp; f.getName().endsWith(<span class="string">&quot;.docx&quot;</span>))&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory())&#123;</span><br><span class="line">                show(f.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试，打印d盘下的所有.docx文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    show(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>IO就是Input和Output的简写，也就是输入和输出的含义。</p>
<p>IO流就是指读写数据时像流水一样从一端流到另外一端，因此得名为“流”。</p>
<h3 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h3><ul>
<li>按照读写数据的基本单位不同，分为 字节流 和 字符流。<br>字节流主要指以字节为单位进行数据读写的流，可以读写任意类型的文件。<br>字符流主要指以字符(2个字节)为单位进行数据读写的流，只能读写文本文件。</li>
<li>按照读写数据的方向不同，分为 输入流 和 输出流（站在程序的角度）。<br>输入流主要指从文件中读取数据内容输入到程序中，也就是读文件。<br>输出流主要指将程序中的数据内容输出到文件中，也就是写文件。</li>
<li>按照流的角色不同分为节点流和处理流。<br>节点流主要指直接和输入输出源对接的流。<br>处理流主要指需要建立在节点流的基础之上的流。</li>
</ul>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/74xkgf"><img src="https://s4.ax1x.com/2022/01/23/74xkgf.png" alt="74xkgf.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/74xXin"><img src="https://s4.ax1x.com/2022/01/23/74xXin.png" alt="74xXin.png"></a></p>
<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p>java.io.FileWriter类主要用于将文本内容写入到文本文件。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>FileWriter(String fileName)</td>
<td>根据参数指定的文件名构造对象</td>
</tr>
<tr>
<td>FileWriter(String fileName, boolean append)</td>
<td>以追加的方式根据参数指定的文件名来构造对象</td>
</tr>
<tr>
<td>void write(int c)</td>
<td>写入单个字符</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>将指定字符数组中从偏移量off开始的len个字符写入此文件输出流</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>将cbuf.length个字符从指定字符数组写入此文件输出流中</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1,创建FileWriter类型引用与“d:/aaa.a.txt”相关联</span></span><br><span class="line">    fw= <span class="keyword">new</span> FileWriter(<span class="string">&quot;d:/aaa/a.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//2,通过输出流写入字符</span></span><br><span class="line">    fw.write(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    fw.write(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//3,关闭资源</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != fw)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p>java.io.FileReader类主要用于从文本文件读取文本数据内容。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>FileReader(String fileName)</td>
<td>根据参数指定的文件名构造对象</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字符的数据并返回，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf, int offset, int length)</td>
<td>从输入流中将最多len个字符的数据读入一个字符数组中，返回读取到的字符个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>从此输入流中将最多 cbuf.length 个字符的数据读入字符数组中，返回读取到的字符个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1,创建FileReader类型的引用和“d:/aaa/a.txt”相关联</span></span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;d:/aaa/a.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//2,从输入流中读取数据</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">while</span>((result = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取结果：&quot;</span> + (<span class="keyword">char</span>)result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//3,关闭资源</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != fr)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fr.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><p>java.io.FileOutputStream类主要用于将图像数据之类的原始字节流写入到输出流中。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>FileOutputStream(String name)</td>
<td>根据参数指定的文件名来构造对象</td>
</tr>
<tr>
<td>FileOutputStream(String name, boolean append)</td>
<td>以追加的方式根据参数指定的文件名来构造对象</td>
</tr>
<tr>
<td>void write(int b)</td>
<td>将指定字节写入此文件输出流</td>
</tr>
<tr>
<td>void write(byte[] b, int off, int len)</td>
<td>将指定字节数组中从偏移量off开始的len个字节写入此文件输出流</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>将 b.length 个字节从指定字节数组写入此文件输出流中</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制写出任何缓冲的输出字节</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p>java.io.FileInputStream类主要用于从输入流中以字节流的方式读取图像数据等。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>FileInputStream(String name)</td>
<td>根据参数指定的文件路径名来构造对象</td>
</tr>
<tr>
<td>int read()</td>
<td>从输入流中读取单个字节的数据并返回，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(byte[] b, int off, int len)</td>
<td>从此输入流中将最多len个字节的数据读入字节数组中，返回读取到的字节个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>int read(byte[] b)</td>
<td>从此输入流中将最多 b.length 个字节的数据读入字节数组中，返回读取到的字节个数，返回-1表示读取到末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
<tr>
<td>int available()</td>
<td>获取输入流所关联文件的大小</td>
</tr>
</tbody></table>
<p><strong>FileOutputStream</strong>类和<strong>FileInputStream</strong>类的用法与<strong>FileWriter</strong>类和<strong>FileReader</strong>类的用法差不多</p>
<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:/aaa/a.png&quot;</span>);</span><br><span class="line">    fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:/aaa/b.png&quot;</span>);</span><br><span class="line">    <span class="comment">/*拷贝方式一：读一个写一个*/</span></span><br><span class="line">    <span class="comment">//int result;</span></span><br><span class="line">    <span class="comment">//while((result = fis.read()) != -1)&#123;</span></span><br><span class="line">    	<span class="comment">//fos.write(result);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">/*拷贝方式二：一次性全部读出来，再全部写进去*/</span></span><br><span class="line">    <span class="comment">//byte[] arr = new byte[fis.available()];</span></span><br><span class="line">    <span class="comment">//fis.read(arr);</span></span><br><span class="line">    <span class="comment">//fos.write(arr);</span></span><br><span class="line">    <span class="comment">/*拷贝方式三：设定合理缓冲区（推荐）*/</span></span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(arr)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != fos)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != fis)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedOutputStream类"><a href="#BufferedOutputStream类" class="headerlink" title="BufferedOutputStream类"></a>BufferedOutputStream类</h3><p>java.io.BufferedOutputStream类主要用于描述缓冲输出流，此时不用为写入的每个字节调用底层系统。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedOutputStream(OutputStream out)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>BufferedOutputStream(OutputStream out, int size)</td>
<td>根据参数指定的引用和缓冲区大小来构造对象</td>
</tr>
<tr>
<td>void write(int b)</td>
<td>写入单个字节</td>
</tr>
<tr>
<td>void write(byte[] b, int off, int len)</td>
<td>写入字节数组中的一部分数据</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>写入参数指定的整个字节数组</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="BufferedInputStream类"><a href="#BufferedInputStream类" class="headerlink" title="BufferedInputStream类"></a>BufferedInputStream类</h3><p>java.io.BufferedInputStream类主要用于描述缓冲输入流。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedInputStream(InputStream in)</td>
<td>根据参数指定的引用构造对象</td>
</tr>
<tr>
<td>BufferedInputStream(InputStream in, int size)</td>
<td>根据参数指定的引用和缓冲区大小构造对象</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字节</td>
</tr>
<tr>
<td>int read(byte[] b, int off, int len)</td>
<td>读取len个字节</td>
</tr>
<tr>
<td>int read(byte[] b)</td>
<td>读取b.length个字节</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<p>以后开发中推荐使用这类带有(Buffered)缓冲区的输入输出流，用法和上面差不多</p>
<p>拷贝文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:/aaa/a.png&quot;</span>));</span><br><span class="line">    bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:/aaa/b.png&quot;</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = bis.read(arr)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        bos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bos != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bis !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在代码开头和结尾利用<code>System.currentTimeMillis()</code>测试运行速度，的确快了不少。</p>
<h3 id="BufferedWriter类"><a href="#BufferedWriter类" class="headerlink" title="BufferedWriter类"></a>BufferedWriter类</h3><p>java.io.BufferedWriter类主要用于写入单个字符、字符数组以及字符串到输出流中。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedWriter(Writer out)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>BufferedWriter(Writer out, int sz)</td>
<td>根据参数指定的引用和缓冲区大小来构造对象</td>
</tr>
<tr>
<td>void write(int c)</td>
<td>写入单个字符到输出流中</td>
</tr>
<tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>将字符数组cbuf中从下标off开始的len个字符写入输出流中</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>将字符串数组cbuf中所有内容写入输出流中</td>
</tr>
<tr>
<td>void write(String s, int off, int len)</td>
<td>将参数s中下标从off开始的len个字符写入输出流中</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>将参数指定的字符串内容写入输出流中</td>
</tr>
<tr>
<td>void newLine()</td>
<td>用于写入行分隔符到输出流中</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="BufferedReader类"><a href="#BufferedReader类" class="headerlink" title="BufferedReader类"></a>BufferedReader类</h3><p>java.io.BufferedReader类用于从输入流中读取单个字符、字符数组以及字符串。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedReader(Readerin)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>BufferedReader(Readerin, int sz)</td>
<td>根据参数指定的引用和缓冲区大小来构造对象</td>
</tr>
<tr>
<td>int read()</td>
<td>从输入流读取单个字符，读取到末尾则返回-1，否则返回实际读取到的字符内容</td>
</tr>
<tr>
<td>int read(char[] cbuf, int off, int len)</td>
<td>从输入流中读取len个字符放入数组cbuf中下标从off开始的位置上，若读取到末尾则返回-1，否则返回实际读取到的字符个数</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>从输入流中读满整个数组cbuf</td>
</tr>
<tr>
<td>String readLine()</td>
<td>读取一行字符串并返回，返回null表示读取到末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<p>拷贝文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;d:/aaa/a.txt&quot;</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:/aaa/b.txt&quot;</span>));</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>)&#123;  <span class="comment">//注意放回null才是末尾，而不是-1</span></span><br><span class="line">        bw.write(s);</span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != bw)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != br)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><p>java.io.PrintStream类主要用于更加方便地打印各种数据内容。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>PrintStream(OutputStream out)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>void print(String s)</td>
<td>用于将参数指定的字符串内容打印出来</td>
</tr>
<tr>
<td>void println(String x)</td>
<td>用于打印字符串后并终止该行</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭输出流并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="PrintWriter类"><a href="#PrintWriter类" class="headerlink" title="PrintWriter类"></a>PrintWriter类</h3><p>java.io.PrintWriter类主要用于将对象的格式化形式打印到文本输出流。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter(Writer out)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>void print(String s)</td>
<td>将参数指定的字符串内容打印出来</td>
</tr>
<tr>
<td>void println(String x)</td>
<td>打印字符串后并终止该行</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流对象并释放有关的资源</td>
</tr>
</tbody></table>
<ul>
<li>案例题目<br>不断地提示用户输入要发送的内容，若发送的内容是”bye”则聊天结束，否则将用户输入的内容写入到文件d:/a.txt中。<br>要求使用PrintStream类负责将数据写入文件 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = <span class="keyword">null</span>;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> who = <span class="keyword">true</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;d:/aaa/c.txt&quot;</span>, <span class="keyword">true</span>)); <span class="comment">//追加模式</span></span><br><span class="line">    <span class="comment">//聊天开始</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请&quot;</span> + (who?<span class="string">&quot;张三&quot;</span>:<span class="string">&quot;李四&quot;</span>) + <span class="string">&quot;输入聊天内容：&quot;</span>);</span><br><span class="line">        s = sc.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(s))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;聊天结束！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        pw.println(sdf.format(d) + (who?<span class="string">&quot;张三&quot;</span>:<span class="string">&quot;李四&quot;</span>) + <span class="string">&quot;说：&quot;</span> + s);</span><br><span class="line">        who = !who;</span><br><span class="line">    &#125;</span><br><span class="line">    pw.println();</span><br><span class="line">    pw.println();</span><br><span class="line">    pw.println();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != pw)&#123;</span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p>java.io.OutputStreamWriter类主要用于实现从字符流到字节流的转换。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>OutputStreamWriter(OutputStream out)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>OutputStreamWriter(OutputStream out, String charsetName)</td>
<td>根据参数指定的引用和编码构造对象</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>将参数指定的字符串写入</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭输出流并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p>java.io.InputStreamReader类主要用于实现从字节流到字符流的转换。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>InputStreamReader(InputStream in)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>InputStreamReader(InputStream in, String charsetName)</td>
<td>根据参数指定的引用和编码来构造对象</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>读取字符数据到参数指定的数组</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭输出流并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p><strong>由来</strong></p>
<p>计算机只能识别二进制数据，早期就是电信号。为了方便计算机可以识别各个国家的文字，就需要将各个国家的文字采用数字编号的方式进行描述并建立对应的关系表，该表就叫做编码表。</p>
<p><strong>常见字符编码</strong></p>
<ul>
<li>ASCII：美国标准信息交换码， 使用一个字节的低7位二位进制进行表示。 </li>
<li>ISO8859-1：拉丁码表，欧洲码表，使用一个字节的8位二进制进行表示。</li>
<li>GB2312：中国的中文编码表，最多使用两个字节16位二进制为进行表示。</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号，最多使用两个字节16位二进制位表示。</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符，为每个字符分配唯一的字符码。所有的文字都用两个字节16位二进制位来表示。</li>
</ul>
<p><strong>发展</strong></p>
<ul>
<li>面向传输的众多 UTF（UCS Transfer Format）标准出现了，UTF-8就是每次8个位传输数据，而<br>UTF-16就是每次16个位。这是为传输而设计的编码并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ul>
<h3 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h3><p>java.io.DataOutputStream类主要用于以适当的方式将基本数据类型写入输出流中。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DataOutputStream(OutputStream out)</td>
<td>根据参数指定的引用构造对象 OutputStream类是个抽象类，实参需要传递子类对象</td>
</tr>
<tr>
<td>void writeInt(int v)</td>
<td>用于将参数指定的整数一次性写入输出流，优先写入高字节</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭文件输出流并释放有关的资源</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:/aaa/d.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    dos.writeInt(num);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != dos)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h3><p>java.io.DataInputStream类主要用于从输入流中读取基本数据类型的数据。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DataInputStream(InputStream in)</td>
<td>根据参数指定的引用来构造对象 InputStream类是抽象类，实参需要传递子类对象</td>
</tr>
<tr>
<td>int readInt()</td>
<td>用于从输入流中一次性读取一个整数数据并返回</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭文件输出流并释放有关的资源</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:/aaa/d.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> result = dis.readInt();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != dis)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p>java.io.ObjectOutputStream类主要用于将一个对象的所有内容整体写入到输出流中。</p>
<ul>
<li>只能将支持 java.io.Serializable 接口的对象写入流中。</li>
<li>类通过实现 java.io.Serializable 接口以启用其序列化功能。</li>
<li>所谓<strong>序列化</strong>主要指将一个<strong>对象</strong>需要存储的相关信息有效组织成<strong>字节序列</strong>的转化过程。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectOutputStream(OutputStream out)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>void writeObject(Object obj)</td>
<td>用于将参数指定的对象整体写入到输出流中</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭输出流并释放有关的资源</td>
</tr>
</tbody></table>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>java.io.ObjectInputStream类主要用于从输入流中一次性将对象整体读取出来。</p>
<p>所谓<strong>反序列化</strong>主要指将有效组织的<strong>字节序列</strong>恢复为一个<strong>对象</strong>及相关信息的转化过程。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectInputStream(InputStream in)</td>
<td>根据参数指定的引用来构造对象</td>
</tr>
<tr>
<td>Object readObject()</td>
<td>主要用于从输入流中读取一个对象并返回 无法通过返回值来判断是否读取到文件的末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭输入流并释放有关的资源</td>
</tr>
</tbody></table>
<ul>
<li>案例：<br>自定义Person类，将Person的一个实例对象写入文件中，再从文件读取出来</li>
</ul>
<p>自定义Person类，需要实现Serializable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8693454448435568461L</span>;  <span class="comment">//提供一个版本号</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/*transient*/</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:/aaa/h.txt&quot;</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;zhang&quot;</span>,<span class="number">18</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != oos)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:/aaa/h.txt&quot;</span>));</span><br><span class="line">    Object obj = ois.readObject();</span><br><span class="line">    System.out.println(obj);   <span class="comment">//结果：Person&#123;name=&#x27;zhang&#x27;, age=18&#125;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != ois)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong></p>
<p>（1）序列化版本号<br>序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。<br>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，<br>如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</p>
<p>（2）transient关键字<br>transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。<br>当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。<br>（即被transient修饰的成员不进行序列化，也就是不保存。假设对Person中的age变量用transient修饰，则age变量不会被保存到文件中，读取的时候，age变量也是默认值0。）</p>
<p>（3）经验的分享<br>当希望将多个对象写入文件时，通常建议将多个对象放入一个集合中，<br>然后将集合这个整体看做一个对象写入输出流中，此时只需要调用一次readObject方法就可以将整个集合的数据读取出来，<br>从而避免了通过返回值进行是否达到文件末尾的判断。</p>
<h3 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h3><p>java.io.RandomAccessFile类主要支持对随机访问文件的读写操作。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>RandomAccessFile(String name, String mode)</td>
<td>根据参数指定的名称和模式构造对象，r: 以只读方式打开，rw：打开以便读取和写入，rwd:打开以便读取和写入，同步文件内容的更新，rws:打开以便读取和写入，同步文件内容和元数据的更新</td>
</tr>
<tr>
<td>int read()</td>
<td>读取单个字节的数据</td>
</tr>
<tr>
<td>void seek(long pos)</td>
<td>用于设置从此文件的开头开始测量的文件指针偏移量</td>
</tr>
<tr>
<td>void write(int b)</td>
<td>将参数指定的单个字节写入</td>
</tr>
<tr>
<td>void close()</td>
<td>用于关闭流并释放有关的资源</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:/aaa/a.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    raf.seek(<span class="number">2</span>);   <span class="comment">//光标偏移两个位置</span></span><br><span class="line">    <span class="keyword">int</span> res = raf.read();</span><br><span class="line">    System.out.println((<span class="keyword">char</span>) res);</span><br><span class="line">    raf.write(<span class="string">&#x27;Q&#x27;</span>);   <span class="comment">//相当于改写，覆盖</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != raf)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>程序和进程</strong></p>
<ul>
<li><p>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。</p>
</li>
<li><p>进程：主要指运行在内存中的可执行文件。</p>
</li>
</ul>
<p>目前主流的操作系统都支持多进程，为了让操作系统同时可以执行多个任务，但进程是重量级的，也就是新建一个进程会消耗CPU和内存空间等系统资源，因此进程的数量比较局限。</p>
<p>  <strong>线程</strong></p>
<ul>
<li>为了解决上述问题就提出线程的概念，线程就是进程内部的程序流，也就是说操作系统内部支持多进程的，而每个进程的内部又是支持多线程的，线程是轻量的，新建线程会共享所在进程的系统资源，因此目前主流的开发都是采用多线程。</li>
<li>多线程是采用时间片轮转法来保证多个线程的并发执行，所谓并发就是指宏观并行微观串行的机制。</li>
</ul>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul>
<li>java.lang.Thread类代表线程，任何线程对象都是Thread类（子类）的实例。</li>
<li>Thread类是线程的模板，封装了复杂的线程开启等操作，封装了操作系统的差异性。</li>
</ul>
<p><strong>相关方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Thread()</td>
<td>使用无参的方式构造对象</td>
</tr>
<tr>
<td>Thread(String name)</td>
<td>根据参数指定的名称来构造对象</td>
</tr>
<tr>
<td>Thread(Runnable target)</td>
<td>根据参数指定的引用来构造对象，其中Runnable是个接口类型</td>
</tr>
<tr>
<td>Thread(Runnable target, String name)</td>
<td>根据参数指定引用和名称来构造对象</td>
</tr>
<tr>
<td>void run()</td>
<td>若使用Runnable引用构造了线程对象，调用该方法时最终调用接口中的版本若没有使用Runnable引用构造线程对象，调用该方法时则啥也不做</td>
</tr>
<tr>
<td>void start()</td>
<td>用于启动线程，Java虚拟机会自动调用该线程的run方法</td>
</tr>
</tbody></table>
<p><strong>创建线程方法</strong></p>
<ul>
<li>自定义类继承Thread类并重写run方法，然后创建该类的对象调用start方法。</li>
<li>自定义类实现Runnable接口并重写run方法，创建该类的对象作为实参来构造Thread类型的对象，然后使用Thread类型的对象调用start方法。</li>
</ul>
<p>继承Thread类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">    <span class="comment">//直接调用run()方法，和普通的方法一样，应该调用start()方法，才会启动线程。</span></span><br><span class="line">    <span class="comment">//rt.run();   </span></span><br><span class="line">    tt.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---主线程&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RunnableTest rt = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(rt);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---主线程&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行流程</strong></p>
<ul>
<li>执行main方法的线程叫做主线程，执行run方法的线程叫做新线程/子线程。</li>
<li>main方法是程序的入口，对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功后线程的个数由1个变成了2个，新启动的线程去执行run方法的代码，主线程继续向下执行，两个线程各自独立运行互不影响。</li>
<li>当run方法执行完毕后子线程结束，当main方法执行完毕后主线程结束。</li>
<li>两个线程执行没有明确的先后执行次序，由操作系统调度算法来决定。</li>
</ul>
<p><strong>两种创建方式的比较</strong></p>
<p>继承Thread类的方式代码简单，但是若该类继承Thread类后则无法继承其它类，<br>而实现Runnable接口的方式代码复杂，但不影响该类继承其它类以及实现其它接口，<br>因此以后的开发中推荐使用第二种方式。</p>
<p><strong>匿名内部类的方式创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1,继承Thread方式，的匿名内部类</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">//简化写法</span></span><br><span class="line">    <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2,实现Runnable接口的，匿名内部类</span></span><br><span class="line">    Runnable r1  = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="comment">//lambda表达式</span></span><br><span class="line">    Runnable r2 = () -&gt; &#123;System.out.println(<span class="string">&quot;子线程4&quot;</span>);&#125;;</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">    t3.start();</span><br><span class="line">    <span class="comment">//再简化写法</span></span><br><span class="line">    <span class="keyword">new</span> Thread( () -&gt; &#123;System.out.println(<span class="string">&quot;子线程5&quot;</span>);&#125; ).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/HSA0TP"><img src="https://s4.ax1x.com/2022/01/29/HSA0TP.png" alt="HSA0TP.png"></a></p>
<ul>
<li>新建状态：使用new关键字创建之后进入的状态，此时线程并没有开始执行。</li>
<li>就绪状态：调用start方法后进入的状态，此时线程还是没有开始执行。</li>
<li>运行状态：使用线程调度器调用该线程后进入的状态，此时线程开始执行，当线程的时间片执行完毕但任务没有完成时回到就绪状态</li>
<li>消亡状态：当线程的任务执行完成后进入的状态，此时线程已经终止。</li>
<li>阻塞状态：当线程执行的过程中发生了阻塞事件进入的状态，如：sleep方法。<br>阻塞状态解除后进入就绪状态。</li>
</ul>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>线程的编号和名称</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>long getId()</td>
<td>获取调用对象所表示线程的编号</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取调用对象所表示线程的名称</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>设置/修改线程的名称为参数指定的数值</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>获取当前正在执行线程的引用</td>
</tr>
</tbody></table>
<ul>
<li>案例题目<br>自定义线程类，在run方法中先打印当前线程的编号和名称，然后将线程的名称修改为”zhangfei”后再次打印编号和名称。<br>要求在main方法中也要打印主线程的编号和名称。</li>
</ul>
<p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);     <span class="comment">//Thread(String name)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程，编号：&quot;</span> + getId() + <span class="string">&quot;，名称：&quot;</span> + getName());</span><br><span class="line">        setName(<span class="string">&quot;zhangfei&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程，编号：&quot;</span> + getId() + <span class="string">&quot;，名称：&quot;</span> + getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test1 t = <span class="keyword">new</span> Test1(<span class="string">&quot;guanyu&quot;</span>);  <span class="comment">//设定线程名称，</span></span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    Thread t1 = Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;---主线程，编号：&quot;</span> + t1.getId() + <span class="string">&quot;，名称&quot;</span> + t1.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();  <span class="comment">//需要获取当前线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程，编号&quot;</span> + t.getId() + <span class="string">&quot;，名称：&quot;</span> + t.getName());</span><br><span class="line">        t.setName(<span class="string">&quot;zhangfei&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程，编号&quot;</span> + t.getId() + <span class="string">&quot;，名称：&quot;</span> + t.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test2 t2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(t2, <span class="string">&quot;guanyu&quot;</span>);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    Thread t1 = Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;---主线程，编号&quot;</span> + t1.getId() + <span class="string">&quot;，名称：&quot;</span> + t1.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static void yield()</td>
<td>当前线程让出处理器（离开Running状态），使当前线程进入Runnable 状态等待</td>
</tr>
<tr>
<td>static void sleep(times)</td>
<td>使当前线程从 Running 放弃处理器进入Block状态, 休眠times毫秒, 再返回到Runnable如果其他线程打断当前线程的Block(sleep), 就会发生InterruptedException。</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>获取线程的优先级</td>
</tr>
<tr>
<td>void setPriority(int newPriority)</td>
<td>修改线程的优先级。 优先级越高的线程不一定先执行，但该线程获取到时间片的机会会更多一些</td>
</tr>
<tr>
<td>void join()</td>
<td>等待该线程终止</td>
</tr>
<tr>
<td>void join(long millis)</td>
<td>等待参数指定的毫秒数</td>
</tr>
<tr>
<td>boolean isDaemon()</td>
<td>用于判断是否为守护线程</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>用于设置线程为守护线程</td>
</tr>
</tbody></table>
<p><strong>sleep方法的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">            System.out.println( sdf.format(d1) );  <span class="comment">//打印当前时间</span></span><br><span class="line">            <span class="comment">//休眠1秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test3 t = <span class="keyword">new</span> Test3();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程等待5秒后结束子线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始等待。。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程优先级管理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程优先级：&quot;</span> + getPriority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test4 t = <span class="keyword">new</span> Test4();</span><br><span class="line">        <span class="comment">//设置优先级：1到10之间</span></span><br><span class="line">        <span class="comment">//Thread.MAX_PRIORITY(相当于10)</span></span><br><span class="line">        <span class="comment">//Thread.MIN_PRIORITY(相当于1)</span></span><br><span class="line">        <span class="comment">//Thread.NORM_PRIORITY(相当于5)</span></span><br><span class="line">        t.setPriority(<span class="number">10</span>);    <span class="comment">//优先级：1到10之间</span></span><br><span class="line">        t.start();</span><br><span class="line">        Thread  t1 = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程优先级：&quot;</span> + t1.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程的等待</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        Test5 t = <span class="keyword">new</span> Test5();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当前线程（主线程）等待调用线程（子线程）结束，才继续执行下去。</span></span><br><span class="line">            t.join();</span><br><span class="line">            <span class="comment">//t.join(2000);  //最多等指定的毫秒数。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>守护线程</strong></p>
<p>守护线程会随着主线程的结束而结束，默认线程不是守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(isDaemon() ? <span class="string">&quot;是守护线程&quot;</span> : <span class="string">&quot;不是守护线程&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">        Test6 t = <span class="keyword">new</span> Test6();</span><br><span class="line">        <span class="comment">//子线程设为守护线程：随着主线程的结束而结束。</span></span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><ul>
<li>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对线程之间进行通信和协调，该机制就叫做线程的同步机制。</li>
<li>多个线程并发读写同一个临界资源时会发生线程并发安全问题。</li>
<li>异步操作:多线程并发的操作，各自独立运行。</li>
<li>同步操作:多线程串行的操作，先后执行的顺序。</li>
</ul>
<p><strong>问题的产生</strong></p>
<p>当两个线程同时对同一个账户进行取款时，导致最终的账户余额不合理。</p>
<p>引发原因：线程一执行取款时还没来得及将取款后的余额写入后台，线程二就已经开始取款。</p>
<p><strong>解决</strong></p>
<p>在Java语言中使用synchronized关键字来实现同步/对象锁机制从而保证线程执行的原子性，具体方式如下：</p>
<ul>
<li>使用同步代码块的方式实现部分代码的锁定，格式如下：<br>synchronized(类类型的引用) {<pre><code>      编写所有需要锁定的代码；
</code></pre>
 }  </li>
<li>使用同步方法的方式实现所有代码的锁定。<br>直接使用synchronized关键字来修饰整个方法即可该方式等价于:<br>synchronized(this) { 整个方法体的代码 }   </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> Deom d = <span class="keyword">new</span> Deom();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span> <span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程：&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;启动中&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(d<span class="comment">/*this*/</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tem = money;</span><br><span class="line">            <span class="keyword">if</span>(tem&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取款中。。 &quot;</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                tem -= <span class="number">200</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            money = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;卡内金额：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deom</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Account a = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态方法是锁定</strong></p>
<p>当我们对一个静态方法加锁，如:<br>public synchronized static void xxx(){….}<br>那么该方法锁的对象是类对象。每个类都有唯一的一个类对象。获取类对象的方式:类名.class。</p>
<p>静态方法与非静态方法同时使用了synchronized后它们之间是非互斥关系的。<br>原因在于：静态方法锁的是类对象而非静态方法锁的是当前方法所属对象。</p>
<p><strong>注意事项</strong></p>
<p>使用synchronized保证线程同步应当注意: 多个需要同步的线程在访问同步块时，看到的应该是同一个锁对象引用。<br>在使用同步块时应当尽量减少同步范围以提高并发的执行效率。</p>
<p><strong>线程安全和线程不安全</strong></p>
<p>线程安全就是有了锁住代码的特点，串行的操作，虽然变安全了，但是效率降低。</p>
<ul>
<li>StringBuffer类是线程安全的类，但StringBuilder类不是线程安全的类。</li>
<li>Vector类和 Hashtable类是线程安全的类，但ArrayList类和HashMap类不是线程安全的类。</li>
<li>Collections.synchronizedList() 和 Collections.synchronizedMap()等方法实现安全。</li>
</ul>
<p><strong>死锁的概念</strong></p>
<ul>
<li>线程一执行的代码：<br>public void run(){<pre><code>synchronized(a)&#123;    //持有对象锁a，等待对象锁b
   synchronized(b)&#123;
       编写锁定的代码;
   &#125;
&#125;
</code></pre>
}</li>
<li>线程二执行的代码：<br>public void run(){<pre><code>synchronized(b)&#123;    //持有对象锁b，等待对象锁a
   synchronized(a)&#123;
       编写锁定的代码;
   &#125;
&#125;
</code></pre>
}</li>
</ul>
<p>注意：在以后的开发中尽量减少同步的资源，减少同步代码块的嵌套结构的使用！</p>
<p><strong>使用Lock锁实现线程同步</strong></p>
<ul>
<li>从Java5开始提供了更强大的线程同步机制—使用显式定义的同步锁对象来实现。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。</li>
<li>该接口的主要实现类是ReentrantLock类，该类拥有与synchronized相同的并发性，在以后的线程安全控制中，经常使用ReentrantLock类显式加锁和释放锁。</li>
</ul>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ReentrantLock()</td>
<td>使用无参方式构造对象</td>
</tr>
<tr>
<td>void lock()</td>
<td>获取锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">//获取Lock锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account3</span> <span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程：&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;启动中&quot;</span>);</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();   </span><br><span class="line">        <span class="keyword">int</span> tem = money;</span><br><span class="line">        <span class="keyword">if</span>(tem&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;取款中。。 &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            tem -= <span class="number">200</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        money = tem;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();   </span><br><span class="line">        System.out.println(<span class="string">&quot;卡内金额：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lock锁与synchronized方式的比较</strong></p>
<ul>
<li>Lock是显式锁，需要手动实现开启和关闭操作，而synchronized是隐式锁，执行锁定代码后自动释放。</li>
<li>Lock只有同步代码块方式的锁，而synchronized有同步代码块方式和同步方法两种锁。</li>
</ul>
<p>使用Lock锁方式时，Java虚拟机将花费较少的时间来调度线程，因此性能更好。</p>
<h3 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h3><p><strong>Object的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>用于使得线程进入等待状态，直到其它线程调用notify()或notifyAll()方法</td>
</tr>
<tr>
<td>void wait(long timeout)</td>
<td>用于进入等待状态，直到其它线程调用方法或参数指定的毫秒数已经过去为止</td>
</tr>
<tr>
<td>void notify()</td>
<td>用于唤醒等待的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>用于唤醒等待的所有线程</td>
</tr>
</tbody></table>
<ul>
<li>案例：<br>两个线程打印0到20，要求：有序的一人打印一下来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=<span class="number">20</span>) &#123;</span><br><span class="line">                    notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; : &quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        wait();   <span class="comment">//进入阻塞状态</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    notify();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/HSKQPI"><img src="https://s4.ax1x.com/2022/01/29/HSKQPI.png" alt="HSKQPI.png"></a></p>
<p>生产者输入数据到仓库中，消费者从仓库中输出数据。<br>每次操作或访问仓库时应该锁住仓库。<br>当仓库满了，生产者应该停止生产。<br>当仓库空了，消费者应该停止消费。</p>
<p><strong>代码实现如下：</strong></p>
<p>仓库类StoreHouse</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreHouse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;  <span class="comment">//仓库存储量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者线程正在生产第&quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者线程正在消费第&quot;</span> + i + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者线程类ProduceThread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//声明一个仓库类型的引用作为成员变量，是为了能调用仓库类中的生产方法</span></span><br><span class="line">    <span class="comment">//合成复用原则</span></span><br><span class="line">    <span class="keyword">private</span> StoreHouse s;</span><br><span class="line">    <span class="comment">//为了确保两个线程公用用一个仓库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProduceThread</span><span class="params">(StoreHouse s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        s.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者线程类ConsumerThread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StoreHouse s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(StoreHouse s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        s.consumer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建仓库</span></span><br><span class="line">    StoreHouse sh = <span class="keyword">new</span> StoreHouse();</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    ProduceThread pt = <span class="keyword">new</span> ProduceThread(sh);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(pt);</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    ConsumerThread ct = <span class="keyword">new</span> ConsumerThread(sh);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ct);</span><br><span class="line">    <span class="comment">//开始模拟</span></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable接口创建线程"><a href="#Callable接口创建线程" class="headerlink" title="Callable接口创建线程"></a>Callable接口创建线程</h3><p><strong>Callable接口</strong></p>
<p>从Java5开始新增加创建线程的第三种方式为实现java.util.concurrent.Callable接口。</p>
<p>线程实现Callable接口，重写call()方法，call()方法有返回值。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>V call()</td>
<td>计算结果并返回</td>
</tr>
</tbody></table>
<p><strong>FutureTask类</strong></p>
<p>java.util.concurrent.FutureTask类用于描述可取消的异步计算，该类提供了Future接口的基本实现，包括启动和取消计算、查询计算是否完成以及检索计算结果的方法，也可以用于获取方法调用后的返回结果。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>FutureTask(Callable callable)</td>
<td>根据参数指定的引用来创建一个未来任务</td>
</tr>
<tr>
<td>V get()</td>
<td>获取call方法计算的结果</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CallableTest c = <span class="keyword">new</span> CallableTest();</span><br><span class="line">    FutureTask ft = <span class="keyword">new</span> FutureTask(c);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    t.start();</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = ft.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>由来</strong></p>
<ul>
<li>在服务器编程模型的原理，每一个客户端连接用一个单独的线程为之服务，当与客户端的会话结束时，线程也就结束了，即每来一个客户端连接，服务器端就要创建一个新线程。</li>
<li>如果访问服务器的客户端很多，那么服务器要不断地创建和销毁线程，这将严重影响服务器的性能。</li>
</ul>
<p><strong>原理</strong></p>
<ul>
<li>线程池的概念：首先创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池中。</li>
<li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，任务是提交给整个线程池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</li>
</ul>
<p><strong>相关类和方法</strong></p>
<p>从Java5开始提供了线程池的相关类和接口：java.util.concurrent.Executors类和 java.util.concurrent.ExecutorService接口。</p>
<p>其中<strong>Executors</strong>是个工具类和线程池的工厂类，可以创建并返回不同类型的线程池，常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static ExecutorService newCachedThreadPool()</td>
<td>创建一个可根据需要创建新线程的线程池</td>
</tr>
<tr>
<td>static ExecutorService newFixedThreadPool(int nThreads)</td>
<td>创建一个可重用固定线程数的线程池</td>
</tr>
<tr>
<td>static ExecutorService newSingleThreadExecutor()</td>
<td>创建一个只有一个线程的线程池</td>
</tr>
</tbody></table>
<p>其中<strong>ExecutorService</strong>接口是真正的线程池接口，主要实现类是ThreadPoolExecutor，常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务和命令，通常用于执行Runnable</td>
</tr>
<tr>
<td>Future submit(Callable task)</td>
<td>执行任务和命令，通常用于执行Callable</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>启动有序关闭</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1，创建线程池</span></span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2，向线程池布置任务</span></span><br><span class="line">    Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line">    pool.execute(t);</span><br><span class="line">    pool.execute(t);</span><br><span class="line">    <span class="comment">//3，关闭线程池</span></span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络常识"><a href="#网络常识" class="headerlink" title="网络常识"></a>网络常识</h3><p><strong>七层网络模型</strong>：</p>
<ul>
<li>OSI（Open System Interconnect）即开放式系统互联，是ISO（国际标准化组织）在1985年研究的网络互联模型。</li>
<li>OSI七层模型和TCP/IP五层模型的划分如下：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Hme9fK"><img src="https://s4.ax1x.com/2022/02/05/Hme9fK.png" alt="Hme9fK.png"></a></p>
<ul>
<li>当发送数据时，需要对发送的内容按照上述七层模型进行层层加包后发送出去。</li>
<li>当接收数据时，需要对接收的内容按照上述七层模型相反的次序层层拆包并显示出来。</li>
</ul>
<p><strong>相关协议</strong>：</p>
<p>计算机在网络中实现通信就必须有一些约定或者规则，这种约定和规则就叫做通信协议，通信协议可以对速率、传输代码、代码结构、传输控制步骤、出错控制等制定统一的标准。</p>
<p>（1）TCP协议</p>
<ul>
<li>传输控制协议(Transmission Control Protocol)，是一种面向连接的协议，类似于打电话。 </li>
<li>建立连接 =&gt; 进行通信 =&gt; 断开连接在传输前采用”三次握手”方式。</li>
<li>在通信的整个过程中全程保持连接，形成数据传输通道。</li>
<li>保证了数据传输的<strong>可靠性和有序性</strong>。</li>
</ul>
<p>是一种全双工的字节流通信方式，可以进行大数据量的传输。传输完毕后需要释放已建立的连接，发送数据的<strong>效率比较低</strong>。</p>
<p>（2）UDP协议</p>
<ul>
<li>用户数据报协议(User Datagram Protocol)，是一种非面向连接的协议，类似于写信。</li>
<li>在通信的整个过程中不需要保持连接，其实是不需要建立连接。</li>
<li><strong>不保证数据传输的可靠性和有序性。</strong></li>
<li>是一种全双工的数据报通信方式，每个数据报的大小限制在64K内。</li>
</ul>
<p>发送数据完毕后无需释放资源，开销小，发送数据的<strong>效率比较高，速度快</strong>。</p>
<p><strong>IP地址：</strong></p>
<ul>
<li><p>192.168.1.1  - 是绝大多数路由器的登录地址，主要配置用户名和密码以及Mac过滤。</p>
</li>
<li><p>IP地址是互联网中的唯一地址标识，本质上是由32位二进制组成的整数，叫做IPv4，当然也有128 位二进制组成的整数，叫做IPv6，目前主流的还是IPv4。</p>
</li>
<li><p>日常生活中采用点分十进制表示法来进行IP地址的描述，将每个字节的二进制转化为一个十进制整数，不同的整数之间采用小数点隔开。<br>  如：0x01020304 =&gt; 1.2.3.4   </p>
</li>
<li><p>查看IP地址的方式：<br>Windows系统：在dos窗口中使用ipconfig或ipconfig/all命令即可<br>Unix/linux系统：在终端窗口中使用ifconfig或/sbin/ifconfig命令即可   特殊的地址<br>本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost</p>
</li>
</ul>
<p><strong>端口号：</strong></p>
<ul>
<li>IP地址 - 可以定位到具体某一台设备。</li>
<li>端口号 - 可以定位到该设备中具体某一个进程。</li>
<li>端口号本质上是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间的端口号通常被系统占用，建议编程从1025开始使用。</li>
<li>特殊的端口：<pre><code>HTTP:80       FTP:21       Oracle:1521       MySQL:3306       Tomcat:8080
</code></pre>
</li>
<li>网络编程需要提供：IP地址 + 端口号，组合在一起叫做网络套接字：Socket。</li>
</ul>
<h3 id="TCP协议的编程模型"><a href="#TCP协议的编程模型" class="headerlink" title="TCP协议的编程模型"></a>TCP协议的编程模型</h3><h4 id="C-S架构介绍"><a href="#C-S架构介绍" class="headerlink" title="C/S架构介绍"></a>C/S架构介绍</h4><ul>
<li>在C/S模式下客户向服务器发出服务请求，服务器接收请求后提供服务。</li>
<li>例如：在一个酒店中，顾客找服务员点菜,服务员把点菜单通知厨师，厨师按点菜单做好菜后让服务员端给客户，这就是一种C/S工作方式。如果把酒店看作一个系统，服务员就是客户端，厨师就是服务器。这种系统分工和协同工作的方式就是C/S的工作方式。</li>
<li>客户端部分：为每个用户所专有的，负责执行前台功能。</li>
<li>服务器部分：由多个用户共享的信息与功能，招待后台服务。</li>
</ul>
<h4 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h4><p>服务器：</p>
<ul>
<li>创建ServerSocket类型的对象并提供端口号；</li>
<li>等待客户端的连接请求，调用accept()方法；</li>
<li>使用输入输出流进行通信；</li>
<li>关闭Socket；</li>
</ul>
<p>客户端：</p>
<ul>
<li>创建Socket类型的对象并提供服务器的IP地址和端口号；</li>
<li>使用输入输出流进行通信；</li>
<li>关闭Socket；</li>
</ul>
<h4 id="相关类和方法"><a href="#相关类和方法" class="headerlink" title="相关类和方法"></a>相关类和方法</h4><p><strong>ServerSocket类</strong></p>
<p>java.net.ServerSocket类主要用于描述服务器套接字信息（大插排）。常用的方法如</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ServerSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>Socket accept()</td>
<td>侦听并接收到此套接字的连接请求</td>
</tr>
<tr>
<td>void   close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><strong>Socket类</strong></p>
<p>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点（小插排）。常用的方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Socket(String host, int port)</td>
<td>根据指定主机名和端口来构造对象</td>
</tr>
<tr>
<td>InputStream getInputStream()</td>
<td>用于获取当前套接字的输入流</td>
</tr>
<tr>
<td>OutputStream   getOutputStream()</td>
<td>用于获取当前套接字的输出流</td>
</tr>
<tr>
<td>void   close()</td>
<td>用于关闭套接字</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ul>
<li>客户端 Socket 与服务器端 Socket 对应, 都包含输入和输出流。</li>
<li>客户端的socket.getInputStream() 连接于服务器socket.getOutputStream()。</li>
<li>客户端的socket.getOutputStream()连接于服务器socket.getInputStream()</li>
</ul>
<p>案例：<br>客户端可以发送消息给服务器，服务器接收后回复消息给客户端，直到客户端发送bye时，结束。</p>
<p>服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1，创建ServerSocket类型的对象并提供端口号；</span></span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">3333</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2，等待客户端的连接请求，调用accept()方法；</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待客户端连接..&quot;</span>);</span><br><span class="line">            s = ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3，使用输入输出流进行通信；</span></span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String s1 = br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到客户端的消息是：&quot;</span> + s1);</span><br><span class="line">                <span class="comment">//如果是bye，取消循环</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(s1)) <span class="keyword">break</span>;</span><br><span class="line">                ps.println(<span class="string">&quot;收到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4，关闭Socket；</span></span><br><span class="line">            <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1, 创建Socket类型的对象并提供服务器的IP地址和端口号；</span></span><br><span class="line">            s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">3333</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功连接服务器&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2, 使用输入输出流进行通信；</span></span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入内容：&quot;</span>);</span><br><span class="line">                String s1 = sc.next();</span><br><span class="line">                ps.println(s1);</span><br><span class="line">                <span class="comment">//如果是bye，取消循环</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(s1)) <span class="keyword">break</span>;</span><br><span class="line">                String s2 = br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到服务器的消息是：&quot;</span> + s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//3, 关闭Socket；</span></span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于上面案例，利用多线程，服务器应该如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1，创建ServerSocket类型的对象并提供端口号；</span></span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">3333</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//2，等待客户端的连接请求，调用accept()方法；</span></span><br><span class="line">                System.out.println(<span class="string">&quot;等待客户端连接..&quot;</span>);</span><br><span class="line">                s = ss.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                <span class="comment">//启动线程</span></span><br><span class="line">                <span class="keyword">new</span> ServerThread(s).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//4，关闭Socket；</span></span><br><span class="line">            <span class="keyword">if</span>(s != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3，使用输入输出流进行通信；</span></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String s1 = br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到客户端的消息是：&quot;</span> + s1 );</span><br><span class="line">                <span class="comment">//如果是bye，取消循环</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(s1)) <span class="keyword">break</span>;</span><br><span class="line">                ps.println(<span class="string">&quot;收到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UDP协议的编程模型"><a href="#UDP协议的编程模型" class="headerlink" title="UDP协议的编程模型"></a>UDP协议的编程模型</h3><h4 id="编程模型-1"><a href="#编程模型-1" class="headerlink" title="编程模型"></a>编程模型</h4><p>接收方：</p>
<ul>
<li>创建DatagramSocket类型的对象并提供端口号；</li>
<li>创建DatagramPacket类型的对象并提供缓冲区；</li>
<li>通过Socket接收数据内容存放到Packet中，调用receive方法；</li>
<li>关闭Socket；</li>
</ul>
<p>发送方：</p>
<ul>
<li>创建DatagramSocket类型的对象；</li>
<li>创建DatagramPacket类型的对象并提供接收方的通信地址；</li>
<li>通过Socket将Packet中的数据内容发送出去，调用send方法；</li>
<li>关闭Socket；</li>
</ul>
<h4 id="相关类和方法-1"><a href="#相关类和方法-1" class="headerlink" title="相关类和方法"></a>相关类和方法</h4><p><strong>DatagramSocket</strong></p>
<p>java.net.DatagramSocket类主要用于描述发送和接收数据报的套接字(邮局)。换句话说，该类就是包裹投递服务的发送或接收点。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramSocket()</td>
<td>使用无参的方式构造对象</td>
</tr>
<tr>
<td>DatagramSocket(int port)</td>
<td>根据参数指定的端口号来构造对象</td>
</tr>
<tr>
<td>void   receive(DatagramPacket p)</td>
<td>用于接收数据报存放到参数指定的位置</td>
</tr>
<tr>
<td>void   send(DatagramPacket p)</td>
<td>用于将参数指定的数据报发送出去</td>
</tr>
<tr>
<td>void   close()</td>
<td>关闭Socket并释放相关资源</td>
</tr>
</tbody></table>
<p><strong>DatagramPacket</strong></p>
<p>java.net.DatagramPacket类主要用于描述数据报，数据报用来实现无连接包裹投递服务。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DatagramPacket(byte[] buf, int length)</td>
<td>根据参数指定的数组来构造对象，用于接收长度为length的数据报</td>
</tr>
<tr>
<td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>
<td>根据参数指定数组来构造对象，将数据报发送到指定地址和端口</td>
</tr>
<tr>
<td>InetAddress   getAddress()</td>
<td>用于获取发送方或接收方的通信地址</td>
</tr>
<tr>
<td>int   getPort()</td>
<td>用于获取发送方或接收方的端口号</td>
</tr>
<tr>
<td>int   getLength()</td>
<td>用于获取发送数据或接收数据的长度</td>
</tr>
</tbody></table>
<p><strong>InetAddress类</strong></p>
<p>java.net.InetAddress类主要用于描述互联网通信地址信息。</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static InetAddress getLocalHost()</td>
<td>用于获取当前主机的通信地址</td>
</tr>
<tr>
<td>static InetAddress getByName(String host)</td>
<td>根据参数指定的主机名获取通信地址</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1,创建DatagramSocket类型的对象并提供端口号；</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(<span class="number">3333</span>);</span><br><span class="line">            <span class="comment">//2,创建DatagramPacket类型的对象并提供缓冲区；</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待接收数据。。&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bArr1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            DatagramPacket dp1 = <span class="keyword">new</span> DatagramPacket(bArr1, bArr1.length);</span><br><span class="line">            <span class="comment">//3,通过Socket接收数据内容存放到Packet中，调用receive方法；</span></span><br><span class="line">            ds.receive(dp1);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收的数据：&quot;</span> + <span class="keyword">new</span> String(bArr1, <span class="number">0</span>, dp1.getLength()));</span><br><span class="line">            <span class="comment">//回复数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] bArr2 = <span class="string">&quot;收到！&quot;</span>.getBytes();</span><br><span class="line">            DatagramPacket dp2 = <span class="keyword">new</span> DatagramPacket(bArr2, bArr2.length, dp1.getAddress(), dp1.getPort());</span><br><span class="line">            ds.send(dp2);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SocketException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//4,关闭Socket；</span></span><br><span class="line">            <span class="keyword">if</span>(ds != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送方</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1,创建DatagramSocket类型的对象；</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            <span class="comment">//2,创建DatagramPacket类型的对象并提供接收方的通信地址；</span></span><br><span class="line">            <span class="keyword">byte</span>[] bArr1 = <span class="string">&quot;hello&quot;</span>.getBytes();</span><br><span class="line">            DatagramPacket dp1 = <span class="keyword">new</span> DatagramPacket(bArr1, bArr1.length, InetAddress.getLocalHost(), <span class="number">3333</span>);</span><br><span class="line">            <span class="comment">//3,通过Socket将Packet中的数据内容发送出去，调用send方法；</span></span><br><span class="line">            ds.send(dp1);</span><br><span class="line">            System.out.println(<span class="string">&quot;发送数据成功！&quot;</span>);</span><br><span class="line">            <span class="comment">//接收回复</span></span><br><span class="line">            <span class="keyword">byte</span>[] bArr2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            DatagramPacket dp2 = <span class="keyword">new</span> DatagramPacket(bArr2, bArr2.length);</span><br><span class="line">            ds.receive(dp2);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的内容是：&quot;</span> + <span class="keyword">new</span> String(bArr2, <span class="number">0</span>, dp2.getLength()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4,关闭Socket；</span></span><br><span class="line">            <span class="keyword">if</span>(ds != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><ul>
<li>java.net.URL（Uniform Resource Identifier）类主要用于表示统一的资源定位器，也就是指向万维网上“资源”的指针。这个资源可以是简单的文件或目录，也可以是对复杂对象的引用，例如对数据库或搜索引擎的查询等。</li>
<li>通过URL可以访问万维网上的网络资源，最常见的就是www和ftp站点，浏览器通过解析给定的</li>
<li>URL可以在网络上查找相应的资源。<br>URL的基本结构如下：<br>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;资源地址&gt;</li>
</ul>
<p>URL类的相关方法：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>URL(String spec)</td>
<td>根据参数指定的字符串信息构造对象</td>
</tr>
<tr>
<td>String getProtocol()</td>
<td>获取协议名称</td>
</tr>
<tr>
<td>String getHost()</td>
<td>获取主机名称</td>
</tr>
<tr>
<td>int getPort()</td>
<td>获取端口号</td>
</tr>
<tr>
<td>String getPath()</td>
<td>获取路径信息</td>
</tr>
<tr>
<td>String getFile()</td>
<td>获取文件名</td>
</tr>
<tr>
<td>URLConnection openConnection()</td>
<td>获取URLConnection类的实例</td>
</tr>
</tbody></table>
<p><strong>URLConnection类</strong></p>
<p>java.net.URLConnection类是个抽象类，该类表示应用程序和URL之间的通信链接的所有类的超类，主要实现类有支持HTTP特有功能的HttpURLConnection类。</p>
<p><strong>HttpURLConnection类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream getInputStream()</td>
<td>获取输入流</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>断开连接</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        URL url = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.lagou.com&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;url的协议是：&quot;</span> + url.getProtocol());</span><br><span class="line">        System.out.println(<span class="string">&quot;url的主机是：&quot;</span> + url.getHost());</span><br><span class="line">        System.out.println(<span class="string">&quot;url的端口号是：&quot;</span> + url.getPort());</span><br><span class="line">        System.out.println(<span class="string">&quot;url的路径信息是：&quot;</span> + url.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;url的文件名是：&quot;</span> + url.getFile());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HttpURLConnection con = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = (HttpURLConnection)url.openConnection();</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            con.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><ul>
<li>通常情况下编写代码都是固定的，无论运行多少次执行的结果也是固定的，在某些特殊场合中编写代码时不确定要创建什么类型的对象，也不确定要调用什么样的方法，这些都希望通过运行时传递的参数来决定，该机制叫做动态编程技术，也就是反射机制。</li>
<li>通俗来说，反射机制就是用于动态创建对象并且动态调用方法的机制。</li>
<li>目前主流的框架底层都是采用反射机制实现的。</li>
<li>如：<br>Person p = new Person();  - 表示声明Person类型的引用指向Person类型的对象<br>p.show();                              - 表示调用Person类中的成员方法show</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ul>
<li>java.lang.Class类的实例可以用于描述Java应用程序中的类和接口，也就是一种数据类型。</li>
<li>该类没有公共构造方法，该类的实例由Java虚拟机和类加载器自动构造完成，本质上就是加载到内存中的运行时类。</li>
</ul>
<p><strong>获取Class对象的方式</strong></p>
<ul>
<li>使用数据类型.class的方式可以获取对应类型的Class对象（掌握）。</li>
<li>使用引用/对象.getClass()的方式可以获取对应类型的Class对象。</li>
<li>使用包装类.TYPE的方式可以获取对应基本数据类型的Class对象。</li>
<li>使用Class.forName()的方式来获取参数指定类型的Class对象（掌握）。</li>
<li>使用类加载器ClassLoader的方式获取指定类型的Class对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//1,使用数据类型.class的方式可以获取对应类型的Class对象（掌握）</span></span><br><span class="line">    Class c1 = <span class="keyword">int</span>.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 = &quot;</span>+ c1);    <span class="comment">//int</span></span><br><span class="line">    c1 = String.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);   <span class="comment">//class java.lang.String</span></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2,使用引用/对象.getClass()的方式可以获取对应类型的Class对象</span></span><br><span class="line">    String s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    c1 = s.getClass();</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);   <span class="comment">//class java.lang.String</span></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,使用包装类.TYPE的方式可以获取对应基本数据类型的Class对象</span></span><br><span class="line">    c1 = Integer.TYPE;</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);    <span class="comment">//int</span></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4,使用Class.forName()的方式来获取参数指定类型的Class对象（掌握）。</span></span><br><span class="line">    c1 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5,使用类加载器ClassLoader的方式获取指定类型的Class对象。</span></span><br><span class="line">    ClassLoader classLoader = ClassTest.class.getClassLoader();</span><br><span class="line">    c1 = classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);    <span class="comment">//class java.lang.String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Class&lt;?&gt; forName(String className)</td>
<td>用于获取参数指定类型对应的Class对象并返回</td>
</tr>
<tr>
<td>T newInstance()</td>
<td>用于创建该Class对象所表示类的新实例，过时</td>
</tr>
</tbody></table>
<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>
<p><strong>Class方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor getConstructor(Class&lt;?&gt;…parameterTypes)</td>
<td>用于获取此Class对象所表示类型中参数指定的公共构造方法</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[] getConstructors()</td>
<td>用于获取此Class对象所表示类型中所有的公共构造方法</td>
</tr>
</tbody></table>
<p><strong>Constructor方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>T newInstance(Object…initargs)</td>
<td>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的访问修饰符</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取方法所有参数的类型</td>
</tr>
</tbody></table>
<p>获取单个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  <span class="comment">//测试阶段暂时抛出异常给jvm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常规使用构造方法，即创建对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangfei&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用反射机制调用构造方法，创建对象</span></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;org.de3.Test_11.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取无参构造方法,并创建对象</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor1 = c1.getConstructor();</span><br><span class="line">    Person p3 = constructor1.newInstance();</span><br><span class="line">    <span class="comment">//获取有参构造方法,并创建对象</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor2 = c1.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p4 = constructor2.newInstance(<span class="string">&quot;zhangfei&quot;</span>, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取所有构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入类名称：&quot;</span>);</span><br><span class="line">    String s = sc.next();</span><br><span class="line">    Class c1 = Class.forName(s);</span><br><span class="line">    <span class="comment">//获取所有构造方法</span></span><br><span class="line">    Constructor[] constructors = c1.getConstructors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Constructor constructor : constructors)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法的访问修饰符是：&quot;</span> + constructor.getModifiers());</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法的名称是：&quot;</span> + constructor.getName());</span><br><span class="line">        System.out.print(<span class="string">&quot;构造方法的参数类型是：&quot;</span>);</span><br><span class="line">        Class[] cArr = constructor.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Class c: cArr)&#123;</span><br><span class="line">            System.out.print(c+ <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n======================================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>
<p><strong>Class方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Field getDeclaredField(String name)</td>
<td>用于获取此Class对象所表示类中参数指定的单个成员变量信息</td>
</tr>
<tr>
<td>Field[] getDeclaredFields()</td>
<td>用于获取此Class对象所表示类中所有成员变量信息</td>
</tr>
</tbody></table>
<p><strong>Field方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Object get(Object obj)</td>
<td>获取参数对象obj中此Field对象所表示成员变量的数值</td>
</tr>
<tr>
<td>void set(Object obj, Object value)</td>
<td>将参数对象obj中此Field对象表示成员变量的数值修改为参数 value的数值</td>
</tr>
<tr>
<td>void setAccessible(boolean flag)</td>
<td>当实参传递true时，则反射对象在使用时应该取消 Java 语言访问检查</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取成员变量的访问修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getType()</td>
<td>获取成员变量的数据类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取成员变量的名称</td>
</tr>
</tbody></table>
<p>获取单个成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常规访问成员变量</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhang&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    System.out.println(p1.name);</span><br><span class="line">    p1.name = <span class="string">&quot;guanyu&quot;</span>;</span><br><span class="line">    System.out.println(p1.name);</span><br><span class="line">    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用反射访问成员变量</span></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;org.de3.Test_11.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//创建实例对象p2</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = c1.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p2 = constructor.newInstance(<span class="string">&quot;zhang&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取成员变量Field，即name</span></span><br><span class="line">    Field field = c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);   <span class="comment">//是否取消检测访问权限，即可以访问private的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印对象p2的成员变量field，即name</span></span><br><span class="line">    System.out.println( field.get(p2) );  <span class="comment">//zhang</span></span><br><span class="line">    <span class="comment">//修改对象p2的成员变量field，即name</span></span><br><span class="line">    field.set(p2, <span class="string">&quot;guanyu&quot;</span>);</span><br><span class="line">    System.out.println( field.get(p2) );  <span class="comment">//guanyu</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取所有成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;org.de3.Test_11.Person&quot;</span>);</span><br><span class="line">    Field[] fArr = c1.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Field field: fArr)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量的访问权限是：&quot;</span> + field.getModifiers());</span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量的数据类型是：&quot;</span> + field.getType());</span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量的名称是：&quot;</span> + field.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;\n=======================================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>
<p><strong>Class方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>用于获取该Class对象表示类中名字为name参数为 parameterTypes的指定公共成员方法</td>
</tr>
<tr>
<td>Method[] getMethods()</td>
<td>用于获取该Class对象表示类中所有公共成员方法</td>
</tr>
</tbody></table>
<p><strong>Method方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Object invoke(Object obj, Object… args)</td>
<td>使用对象obj来调用此Method对象所表示的成员方法，实参传递args</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的访问修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getReturnType()</td>
<td>获取方法的返回值类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取方法所有参数的类型</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getExceptionTypes()</td>
<td>获取方法的异常信息</td>
</tr>
</tbody></table>
<p>获取单个成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常规调用成员方法</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhang&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    p1.show(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用反射机制调用成员方法</span></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;org.de3.Test_11.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor =  c1.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person p2 = constructor.newInstance(<span class="string">&quot;zhang&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//获取成员方法method， 即show()</span></span><br><span class="line">    Method method = c1.getMethod(<span class="string">&quot;show&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//调用对象p2的成员方法method,即show();</span></span><br><span class="line">    method.invoke(p2, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取所有成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;org.de3.Test_11.Person&quot;</span>);</span><br><span class="line">    Method[] methods = c1.getMethods();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Method method: methods)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成员方法的修饰符是：&quot;</span> + method.getModifiers());</span><br><span class="line">        System.out.println(<span class="string">&quot;成员方法的返回值类型是：&quot;</span> + method.getReturnType());</span><br><span class="line">        System.out.println(<span class="string">&quot;成员方法的名称是：&quot;</span> + method.getName());</span><br><span class="line">        System.out.print(<span class="string">&quot;成员方法的参数类型是： &quot;</span>);</span><br><span class="line">        Class[] cArr = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Class c: cArr)&#123;</span><br><span class="line">            System.out.print(c + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;成员方法的异常类型是： &quot;</span>);</span><br><span class="line">        Class[] cArr2 = method.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span>(Class c: cArr2)&#123;</span><br><span class="line">            System.out.print(c + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==================================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他结构信息"><a href="#其他结构信息" class="headerlink" title="其他结构信息"></a>其他结构信息</h3><p><strong>Class方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Package getPackage()</td>
<td>获取所在的包信息</td>
</tr>
<tr>
<td>Class&lt;? super T&gt; getSuperclass()</td>
<td>获取继承的父类信息</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getInterfaces()</td>
<td>获取实现的所有接口</td>
</tr>
<tr>
<td>Annotation[] getAnnotations()</td>
<td>获取注解信息</td>
</tr>
<tr>
<td>Type[] getGenericInterfaces()</td>
<td>获取泛型信息</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class c1 = Class.forName(<span class="string">&quot;org.de3.Test_11.Person&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;类的包信息：&quot;</span> + c1.getPackage());</span><br><span class="line">    System.out.println(<span class="string">&quot;类的父类：&quot;</span> + c1.getSuperclass());</span><br><span class="line">    System.out.println(<span class="string">&quot;类的接口：&quot;</span> + c1.getInterfaces());</span><br><span class="line">    System.out.println(<span class="string">&quot;类的注解：&quot;</span> + c1.getAnnotations());</span><br><span class="line">    System.out.println(<span class="string">&quot;类的泛型：&quot;</span> + c1.getGenericInterfaces());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>代理模式：</strong></p>
<p>当一个对象不能直接使用，可以在客户和目标中间直接创建一个中介，这个中介就是代理。</p>
<p>例：<br>    A类不能直接访问C类，可创建B类为中介，<br>    A类访问B类，B类访问C类，<br>    A类是客户，B类是代理，C类是目标。</p>
<p><strong>作用：</strong></p>
<ul>
<li>控制访问，在代理中，控制是否可以调用目标对象的方法。</li>
<li>功能增强，可以在完成目标方法的调用时，附加一些额外的功能。</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>代理类是手工实现的java文件，代理的目标对象是固定的</p>
<p><strong>优点</strong>：容易理解，使用方便</p>
<p><strong>缺点</strong>：在目标类比较多时，会产生大量的代理类。</p>
<p>案例：<br>某人到商家买U盘，商家到厂家买U盘。某人是客户，商家是代理，厂家是目标。</p>
<p>销售U盘的接口UsbCell</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UsbCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cell</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标类：厂家，UsbFactory1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbFactory1</span> <span class="keyword">implements</span> <span class="title">UsbCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cell</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标类中的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">85.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类：商家，TaoBao1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBao1</span> <span class="keyword">implements</span> <span class="title">UsbCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UsbFactory1 factory = <span class="keyword">new</span> UsbFactory1();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cell</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，访问目标类方法</span></span><br><span class="line">        <span class="keyword">float</span> price = factory.cell(num);</span><br><span class="line">        <span class="comment">//2，功能增强</span></span><br><span class="line">        price = price + <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;送一张优惠券！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试，客户买U盘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TaoBao1 taoBao = <span class="keyword">new</span> TaoBao1();</span><br><span class="line">        <span class="keyword">float</span> price = taoBao.cell(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb的价格是：&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>使用反射机制，在程序执行中，创建代理类对象。</p>
<p>特点：不用创建类文件，代理的目标类是活动的，可设置的</p>
<p><strong>动态代理的实现</strong></p>
<p>jdk动态代理：使用java.lang.reflect包里的三个类：</p>
<p>InvocationHandler，Method， Proxy</p>
<p><strong>InvocationHandler</strong>接口（调用处理器）：接口中就一个invoke()方法，</p>
<ul>
<li>invoke()：表示代理对象要执行的功能代码。代理类要完成的功能就写在invoke方法中。</li>
<li>代理类完成的功能：调用目标类方法，功能增强</li>
</ul>
<p>方法原型：</p>
<p>public Object invoke(Object proxy, Method method, Object[] args)</p>
<p>参数：<br>Object proxy：jdk创建的代理对象，无需赋值<br>Method method：目标类中的方法，jdk提供method对象<br>Object[] args：目标类中的方法的参数</p>
<p>用法：</p>
<p>创建类实现InvocationHandler接口，重写invoke()方法，把代理内容写invoke()方法中。</p>
<p><strong>Proxy</strong>类：中有静态方法 newProxyInstance()，创建代理对象</p>
<p>方法原型：</p>
<p>public static Object newProxyInstance（ClassLoader loader，Class&lt;&gt;[] interfaces, InvocationHandler h）</p>
<p>参数：</p>
<p>ClassLoader loader：类加载器，<br>Class&lt;&gt;[] interfaces：类的接口，<br>InvocationHandler h：我们自己写的，代理类要完成的功能</p>
<p>返回值：就是代理对象</p>
<p><strong>实现动态代理步骤</strong></p>
<p>1，创建接口，定义目标类要完成的功能</p>
<p>2，创建目标类，并实现接口</p>
<p>3，创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能：<br>        调用目标方法，增强功能</p>
<p>4，使用Proxy类的静态方法newProxyInstance()，创建代理对象，并发返回值转化成接口类型</p>
<p>5，使用代理对象调用需要的方法。</p>
<p>案例：<br>以静态代理为例，编写动态代码：</p>
<p>销售U盘的接口：UsbCell</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UsbCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cell</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标类：厂家，UsbFactory1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsbFactory1</span> <span class="keyword">implements</span> <span class="title">UsbCell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cell</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标类中的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">85.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建InvocationHandler接口的实现类：重写invoke方法，写代理内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标类</span></span><br><span class="line">    <span class="keyword">private</span> UsbCell target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(UsbCell target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理的内容写在invoke方法中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o :代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method：需要执行的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects：参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//1, 访问目标类的方法，</span></span><br><span class="line">        <span class="comment">// 动态，因为此时(方法method)，(目标类target)，(参数objects)都还没有确定</span></span><br><span class="line">        Object price = method.invoke(target, objects);</span><br><span class="line">        <span class="comment">//2, 功能增强</span></span><br><span class="line">        <span class="keyword">if</span>(price != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Float f = (<span class="keyword">float</span>)price;</span><br><span class="line">            price = f + <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;赠送一张优惠券！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试，买U盘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UsbCell uc = <span class="keyword">new</span> UsbFactory1();</span><br><span class="line">        <span class="comment">//创建invocationHandler对象，目标类target确定为uc</span></span><br><span class="line">        MyInvocationHandler invocationHandler = <span class="keyword">new</span> MyInvocationHandler(uc);</span><br><span class="line">        <span class="comment">//创建动态代理对象</span></span><br><span class="line">        UsbCell proxy = (UsbCell)Proxy.newProxyInstance(uc.getClass().getClassLoader(),</span><br><span class="line">                uc.getClass().getInterfaces(),</span><br><span class="line">                invocationHandler);</span><br><span class="line">        <span class="comment">//方法method确定为cell, 参数objects确定为1</span></span><br><span class="line">        Object price = proxy.cell(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;价格为：&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理实际作用</strong></p>
<p>可以在不改变原来的目标方法功能的前提下，在代理中增强自己的功能代码。</p>
<p>比如：在项目中，有一个功能是其他人写好的，我可以使用。但是发现这个功能不能完全满足我的需求，需要增强自己的代码，就可以使用代理，在代理中访问目标类的方法，并且增加自己的代码(增强功能)。</p>
<p>例如：现有接口Hello如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能类GongNeng，实现了Hello接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GongNeng</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以使用该GongNeng类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello h1 = <span class="keyword">new</span> GongNeng();</span><br><span class="line">h1.print(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//abc</span></span><br></pre></td></tr></table></figure>

<p>假如现在不满足我的需求，我需要在打印后，再打印字符串“bye”，可以添加代理：</p>
<p>创建InvocationHandler接口的实现类：重写invoke方法，写代理内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hello target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Hello target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用目标类方法</span></span><br><span class="line">        method.invoke(target, objects);</span><br><span class="line">        <span class="comment">//功能增强，增加自己的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Hello h2 = <span class="keyword">new</span> GongNeng();</span><br><span class="line">    MyInvocationHandler invocationHandler = <span class="keyword">new</span> MyInvocationHandler(h2);</span><br><span class="line">    Hello proxy = (Hello)Proxy.newProxyInstance( h2.getClass().getClassLoader(),</span><br><span class="line">                                                h2.getClass().getInterfaces(),</span><br><span class="line">                                                invocationHandler);</span><br><span class="line">    proxy.print(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//结果：</span></span><br><span class="line">    <span class="comment">//abc</span></span><br><span class="line">    <span class="comment">//bye</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用设计原则和设计模式"><a href="#常用设计原则和设计模式" class="headerlink" title="常用设计原则和设计模式"></a>常用设计原则和设计模式</h1><h2 id="常用设计原则"><a href="#常用设计原则" class="headerlink" title="常用设计原则"></a>常用设计原则</h2><p><strong>软件开发流程</strong></p>
<p>需求分析文档、概要设计文档、详细设计文档、编码和测试、安装和调试、维护和升级</p>
<p><strong>常用的设计原则</strong></p>
<ul>
<li>开闭原则（Open Close Principle）<br>对扩展开放对修改关闭，为了使程序的扩展性好，易于维护和升级。</li>
<li>里氏代换原则（Liskov Substitution Principle）<br>任何基类可以出现的地方，子类一定可以出现，多使用多态的方式。</li>
<li>依赖倒转原则（Dependence Inversion Principle）<br>尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li>
<li>接口隔离原则（Interface Segregation Principle）<br>尽量多使用小接口而不是大接口，避免接口的污染，降低类之间耦合度。</li>
<li>迪米特法则（ 少知道原则）（Demeter Principle）<br>一个实体应当尽量少与其他实体之间发生相互作用，使系统功能模块相对独立。<br>高内聚，低耦合。</li>
<li>合成复用原则（Composite Reuse Principle）<br>尽量多使用合成/聚合的方式，而不是继承的方式。</li>
</ul>
<h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
<p>设计模式就是一种用于固定场合的固定套路。</p>
<p><strong>基本分类</strong></p>
<ul>
<li>创建型模式 ： 单例设计模式、工厂方法模式、抽象工厂模式、…</li>
<li>结构型模式 ： 装饰器模式、代理模式、…</li>
<li>行为型模式 ： 模板设计模式、…</li>
</ul>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>主要分为：饿汉式 和 懒汉式，懒汉式需要对多线程进行同步处理。</p>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2,创建本类类型的引用指向本类类型的对象，private static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//1,私有化构造方法，private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3,提供共有的成员方法，将本类对象返回出去，public static</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2,创建本类类型的引用指向本类类型的对象，private static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1,私有化构造方法，private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3,提供共有的成员方法，将本类对象返回出去，public static。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的懒汉式会有线程不安全的情况，优化后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2,创建本类类型的引用指向本类类型的对象，private static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1,私有化构造方法，private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3,提供共有的成员方法，将本类对象返回出去，public static。由于线程不安全原因，加上锁synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>普通工厂模式</strong></p>
<p> 普通工厂方法模式就是建立一个工厂类，对实现了同一接口的不同实现类进行实例的创建。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/HgIISg"><img src="https://s4.ax1x.com/2022/02/15/HgIISg.png" alt="HgIISg.png"></a></p>
<p>某发送消息的接口Sender：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*public abstract */</span><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口Sender的实现类MailSender：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮件发送消息。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口Sender的实现类SmsSender：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;短信发送消息。。。 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通工厂类SendFactory，专门用来创建Sender接口实现类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;SmsSender&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;MailSender&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//正常创建对象</span></span><br><span class="line">    Sender s = <span class="keyword">new</span> SmsSender();</span><br><span class="line">    s.send();</span><br><span class="line">    System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">    <span class="comment">//利用工厂类创建对象</span></span><br><span class="line">    SendFactory sf = <span class="keyword">new</span> SendFactory();</span><br><span class="line">    Sender s1 = sf.produce(<span class="string">&quot;SmsSender&quot;</span>);</span><br><span class="line">    s1.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<p>在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，并且可能出现空指针异常。</p>
<p><strong>多个工厂方法模式</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/HgHfBj"><img src="https://s4.ax1x.com/2022/02/15/HgHfBj.png" alt="HgHfBj.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<p>在多个工厂方法模式中，为了能够正确创建对象，先需要创建工厂类的对象才能调用工厂类中的生产方法。</p>
<p><strong>静态工厂方法模式</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Hgb4MD"><img src="https://s4.ax1x.com/2022/02/15/Hgb4MD.png" alt="Hgb4MD.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>意义</strong>：</p>
<p>工厂方法模式适合：凡是出现了大量的产品需要创建且具有共同的接口时，可以通过工厂方法模式进行创建。</p>
<p><strong>缺点：</strong></p>
<p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序生产新的产品，就必须对工厂类的代码进行修改，这就违背了开闭原则。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/HgqolT"><img src="https://s4.ax1x.com/2022/02/15/HgqolT.png" alt="HgqolT.png"></a></p>
<p>创建对象的工厂类的接口Provider：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sender工厂类的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sender <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建MailSender对象的工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建SmsSender对象的工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此后假如Sender接口有了新的实现类，为该类添加工厂方法时，可以不用修改原来的代码，直接创建一个新的工厂类，实现工厂类的接口即可。符合了开闭原则。</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式就是给一个对象动态的增加一些新功能，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/HgO7dJ"><img src="https://s4.ax1x.com/2022/02/15/HgO7dJ.png" alt="HgO7dJ.png"></a></p>
<p>某接口Sourceable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口的实现类Source：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现了某个功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要给该实现类添加其他的功能，但是又不能改变原来的代码，创建修饰器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>  <span class="keyword">implements</span> <span class="title">Sourceable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sourceable source;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Sourceable source)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        source.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;修饰器又添加了一些其他功能！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正常使用</span></span><br><span class="line">    Sourceable s = <span class="keyword">new</span> Source();</span><br><span class="line">    s.method();      <span class="comment">//实现了某个功能</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用修饰器</span></span><br><span class="line">    Decorator d = <span class="keyword">new</span> Decorator(<span class="keyword">new</span> Source());</span><br><span class="line">    d.method();      </span><br><span class="line">    <span class="comment">//实现了某个功能</span></span><br><span class="line">    <span class="comment">//修饰器又添加了一些其他功能！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际意义</strong></p>
<ul>
<li>可以实现一个类功能的扩展。</li>
<li>可以动态的增加功能，而且还能动态撤销（继承不行）。</li>
<li>缺点：产生过多相似的对象，不易排错。</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li>代理模式就是找一个代理类替原对象进行一些操作。</li>
<li>比如我们在租房子的时候找中介，再如我们打官司需要请律师，中介和律师在这里就是我们的代理。</li>
<li><a target="_blank" rel="noopener" href="https://imgtu.com/i/HgjwDS"><img src="https://s4.ax1x.com/2022/02/15/HgjwDS.png" alt="HgjwDS.png"></a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sourceable source = <span class="keyword">new</span> Source();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//访问控制，访问了目标方法</span></span><br><span class="line">        source.method();</span><br><span class="line">        <span class="comment">//增强功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理增加了一些功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//正常使用</span></span><br><span class="line">    Sourceable s = <span class="keyword">new</span> Source();</span><br><span class="line">    s.method();      <span class="comment">//实现了某个功能</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用代理</span></span><br><span class="line">    Proxy p = <span class="keyword">new</span> Proxy();</span><br><span class="line">    p.method();      </span><br><span class="line">    <span class="comment">//实现了某个功能</span></span><br><span class="line">    <span class="comment">//代理增加了一些功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际意义</strong>     </p>
<ul>
<li>如果在使用的时候需要对原有的方法进行改进，可以采用一个代理类调用原有方法，并且对产生的结果进行控制，这种方式就是代理模式。</li>
<li>使用代理模式，可以将功能划分的更加清晰，有助于后期维护。</li>
</ul>
<p><strong>代理模式和装饰器模式的比较</strong>     </p>
<ul>
<li>装饰器模式通常的做法是将原始对象作为一个参数传给装饰者的构造器，而代理模式通常在一个代理类中创建一个被代理类的对象。</li>
<li>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式主要指一个抽象类中封装了一个固定流程，流程中的具体步骤可以由不同子类进行不同的实现，通过抽象类让固定的流程产生不同的结果。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/H2S8qf"><img src="https://s4.ax1x.com/2022/02/15/H2S8qf.png" alt="H2S8qf.png"></a></p>
<p>抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将字符串exp，按照op分割，返回计算结果。如,参数&quot;1+1&quot;,&quot;+&quot;,返回2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitExpression</span><span class="params">(String exp, String op)</span></span>&#123;</span><br><span class="line">        String[] sArr = exp.split(op);</span><br><span class="line">        <span class="keyword">return</span> calculate(Integer.parseInt(sArr[<span class="number">0</span>]), Integer.parseInt(sArr[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> ia, <span class="keyword">int</span> ib)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某一子类，加法运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> ia, <span class="keyword">int</span> ib)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ia + ib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某一子类，减法运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> ia, <span class="keyword">int</span> ib)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ia - ib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    AbstractCalculator ac = <span class="keyword">new</span> Plus();</span><br><span class="line">    <span class="keyword">int</span> ia = ac.splitExpression(<span class="string">&quot;1+2&quot;</span>, <span class="string">&quot;\\+&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ia = &quot;</span> + ia);    <span class="comment">//ia = 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ac = <span class="keyword">new</span> Minus();</span><br><span class="line">    ia = ac.splitExpression(<span class="string">&quot;5-1&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ia = &quot;</span> + ia);    <span class="comment">//ia = 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java新特性"><a href="#Java新特性" class="headerlink" title="Java新特性"></a>Java新特性</h1><h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><p>Java8是 Java 语言的一个重要版本，该版本于2014年3月发布，是自Java5以来 具革命性的版本，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>函数式接口主要指只包含一个抽象方法的接口，如：java.lang.Runnable、java.util.Comparator 接口等。    </li>
<li>Java8提供@FunctionalInterface注解来定义函数式接口，若定义的接口不符合函数式的规范便会报错。</li>
<li>Java8中增加了java.util.function包，该包包含了常用的函数式接口，具体如下：</li>
</ul>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>void accept(T t)</td>
<td>根据指定的参数执行操作</td>
</tr>
<tr>
<td>Supplier</td>
<td>T get()</td>
<td>得到一个返回值</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>根据指定的参数执行操作并返回</td>
</tr>
<tr>
<td>Predicate</td>
<td>boolean test(T t)</td>
<td>判断指定的参数是否满足条件</td>
</tr>
</tbody></table>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><ul>
<li>Lambda 表达式是实例化<strong>函数式接口</strong>的重要方式，使用 Lambda 表达式可以使代码变的更加简洁紧凑。</li>
<li>lambda表达式：参数列表、箭头符号-&gt;和方法体组成，而方法体中可以是表达式，也可以是语句块。</li>
<li>语法格式：(参数列表) -&gt; { 方法体; }      </li>
<li>其中()、参数类型、{} 以及return关键字 可以省略。</li>
</ul>
<h3 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h3><ul>
<li>方法引用主要指通过方法的名字来指向一个方法而不需要为方法引用提供方法体，该方法的调用交给函数式接口执行。</li>
<li>方法引用使用一对冒号  :: 将类或对象与方法名进行连接，通常使用方式如下：<ul>
<li>对象的非静态方法引用    ObjectName :: MethodName</li>
<li>类的静态方法引用              ClassName :: StaticMethodName</li>
<li>类的非静态方法引用          ClassName :: MethodName </li>
<li>构造器的引用                      ClassName :: new </li>
<li>数组的引用                        TypeName[] :: new</li>
</ul>
</li>
<li>方法引用是在特定场景下lambda表达式的一种简化表示，可以进一步简化代码的编写使代码更加紧凑简洁，从而减少冗余代码。</li>
</ul>
<p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,Runnable,抽象方法run无参无返回值</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Runnable Runnable1 = () -&gt; System.out.println();</span><br><span class="line"><span class="comment">//方法引用</span></span><br><span class="line">Runnable Runnable2 = System.out::println;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2,Consumer,抽象方法accept有参无返回值</span></span><br><span class="line">Consumer consumer  = <span class="keyword">new</span> Consumer() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Consumer consumer1 = o -&gt; System.out.println(o);</span><br><span class="line"><span class="comment">//方法引用</span></span><br><span class="line">Consumer consumer2 = System.out::println;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3,Supplier，抽象方法get无参有返回值</span></span><br><span class="line">Supplier supplier = <span class="keyword">new</span> Supplier()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Supplier supplier1 = () -&gt; <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//方法引用</span></span><br><span class="line">Supplier supplier2 = Person::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4, Function, 抽象方法apply有参有返回值</span></span><br><span class="line">Function&lt;String, Integer&gt; function = <span class="keyword">new</span> Function&lt;&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Function&lt;String, Integer&gt; function1 = s -&gt; Integer.parseInt(s);</span><br><span class="line"><span class="comment">//方法引用</span></span><br><span class="line">Function&lt;String, Integer&gt; functioin2 = Integer::parseInt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5,Predicate, 抽象方法test有参有boolean类型返回值</span></span><br><span class="line">Predicate&lt;Integer&gt; predicate = <span class="keyword">new</span> Predicate&lt;&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Predicate&lt;Integer&gt; predicate1 = age -&gt; age&gt;=<span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>1，实现接口，可以创建实现类，但是麻烦，可以利用匿名内部类。</p>
<p>2，在接口是函数式接口的条件下，可以使用lambda表达式。</p>
<p>3，在lambda的特定条件下可以再简化，使用方法引用。<br>      特定条件：重写方法的返回值和参数，跟返回的方法的返回值和参数一致。</p>
<h3 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h3><ul>
<li>案例题目：<br>准备一个List集合并放入Person类型的对象，将集合中所有age&gt;=18过滤出来放到另外一个集合并打印出来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备List</span></span><br><span class="line">List&lt;Person&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Person&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1,list1添加元素Person</span></span><br><span class="line">list1.add(<span class="keyword">new</span> Person(<span class="string">&quot;zhang&quot;</span>, <span class="number">30</span>));</span><br><span class="line">list1.add(<span class="keyword">new</span> Person(<span class="string">&quot;li&quot;</span>, <span class="number">16</span>));</span><br><span class="line">list1.add(<span class="keyword">new</span> Person(<span class="string">&quot;wang&quot;</span>, <span class="number">10</span>));</span><br><span class="line">list1.add(<span class="keyword">new</span> Person(<span class="string">&quot;liu&quot;</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，遍历list1，符合条件的添加到list2中</span></span><br><span class="line"><span class="keyword">for</span>(Person p:list1)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.getAge() &gt;= <span class="number">18</span>)&#123;</span><br><span class="line">        list2.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，遍历打印list2</span></span><br><span class="line"><span class="keyword">for</span>(Person p: list2)&#123;</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>概念</strong></p>
<ul>
<li>java.util.stream.Stream接口是对集合功能的增强，可以对集合元素进行复杂的查找、过滤、筛选等操作。</li>
<li>Stream接口借助于Lambda 表达式极大的提高编程效率和程序可读性，同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。</li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li>创建操作：创建Stream，通过一个数据源来获取一个流。</li>
<li>中间操作：转换Stream，每次转换返回一个新的Stream对象。</li>
<li>终止操作：对Stream进行聚合操作并产生结果。</li>
</ul>
<h4 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h4><p>创建流对象</p>
<ul>
<li>方式一：通过调用集合的默认方法来获取流，如：default Stream stream() </li>
<li>方式二：通过数组工具类中的静态方法来获取流，如：static IntStream stream(int[] array) </li>
<li>方式三：通过Stream接口的静态方法来获取流，如：static  Stream of(T… values) </li>
<li>方式四：通过Stream接口的静态方法来获取流，static  Stream generate(Supplier&lt;? extends T&gt; s)</li>
</ul>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>从某个流通过变换得到另一个流</p>
<p>筛选与切片的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream filter(Predicate&lt;? super T&gt; predicate)</td>
<td>返回一个包含匹配元素的流</td>
</tr>
<tr>
<td>Stream distinct()</td>
<td>返回不包含重复元素的流</td>
</tr>
<tr>
<td>Stream limit(long maxSize)</td>
<td>返回不超过给定元素数量的流</td>
</tr>
<tr>
<td>Stream skip(long n)</td>
<td>返回丢弃前n个元素后的流</td>
</tr>
</tbody></table>
<p>用Stream解决上面案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">list1.stream().filter(<span class="keyword">new</span> Predicate&lt;Person&gt;()&#123;  <span class="comment">//从流中，筛选年龄大于等于18</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getAge() &gt;= <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(<span class="keyword">new</span> Consumer&lt;Person&gt;() &#123;    <span class="comment">//从流中，筛选完后，遍历，添加到list2中，并打印</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        list2.add(p);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用lambda表达式写法</span></span><br><span class="line">list1.stream().filter(p -&gt; p.getAge()&gt;=<span class="number">18</span>)</span><br><span class="line">    		  .forEach(p -&gt; &#123;</span><br><span class="line">                  list2.add(p);</span><br><span class="line">                  System.out.println(p);</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>

<p>映射的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream map(Function&lt;? super T,? extends R&gt; mapper)</td>
<td>返回每个处理过元素组成的流</td>
</tr>
<tr>
<td>Stream flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</td>
<td>返回每个被替换过元素组成的流，并将所有流合成一个流</td>
</tr>
</tbody></table>
<p>将Person的age映射出来并打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list1.stream().map(<span class="keyword">new</span> Function&lt;Person, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  person.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">list1.stream().map(p -&gt; p.getAge()).forEach(age -&gt; System.out.println(age));</span><br><span class="line"></span><br><span class="line"><span class="comment">//特定条件，可以再简化，方法引用</span></span><br><span class="line">list1.stream().map(Person::getAge).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>排序的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Stream sorted()</td>
<td>返回经过自然排序后元素组成的流</td>
</tr>
<tr>
<td>Stream sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>返回经过比较器排序后元素组成的流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序</span></span><br><span class="line">Stream.of(<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义比较器排序</span></span><br><span class="line">list1.stream().sorted(<span class="keyword">new</span> Comparator&lt;Person&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge()!=p2.getAge() ?</span><br><span class="line">               p1.getAge()-p2.getAge() :</span><br><span class="line">        	   p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式,只按年龄排</span></span><br><span class="line">list1.stream().sorted((p1,p2) -&gt; p1.getAge()-p2.getAge()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h4><p> 匹配与查找的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Optional findFirst()</td>
<td>返回该流的第一个元素</td>
</tr>
<tr>
<td>boolean allMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>返回所有元素是否都匹配</td>
</tr>
<tr>
<td>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>返回所有元素是否都不匹配</td>
</tr>
<tr>
<td>Optional max(Comparator&lt;? super T&gt; comparator)</td>
<td>根据比较器返回 大元素</td>
</tr>
<tr>
<td>Optional min(Comparator&lt;? super T&gt; comparator)</td>
<td>根据比较器返回 小元素</td>
</tr>
<tr>
<td>long count()</td>
<td>返回元素的个数</td>
</tr>
<tr>
<td>void forEach(Consumer&lt;? super T&gt; action)</td>
<td>对流中每个元素执行操作</td>
</tr>
</tbody></table>
<p>规约的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Optional reduce(BinaryOperator accumulator)</td>
<td>返回结合后的元素值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有年龄累加和</span></span><br><span class="line">Optional&lt;Integer&gt; reduce = list1.stream().map(Person::getAge).reduce(<span class="keyword">new</span> BinaryOperator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer ia, Integer ib)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.sum(ia,ib);  <span class="comment">//相当于ia + ib</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">Optional&lt;Integer&gt; reduce1 = list1.stream().map(p -&gt; p.getAge()).reduce((ia,ib) -&gt; ia+ib);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化，方法引用</span></span><br><span class="line">Optional&lt;Integer&gt; reduce2 = list1.stream().map(Person::getAge).reduce(Integer::sum);</span><br></pre></td></tr></table></figure>

<p>收集的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</td>
<td>使用收集器对元素进行处理</td>
</tr>
</tbody></table>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><ul>
<li>java.util.Optional类可以理解为一个简单的容器，其值可能是null或者不是null，代表一个值存在或不存在。</li>
<li>该类的引入很好的解决空指针异常，不用显式进行空值检测。</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>static Optional ofNullable(T value)</td>
<td>根据参数指定数值来得到Optional类型的对象</td>
</tr>
<tr>
<td>Optional map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td>根据参数指定规则的结果来得到Optional类型的对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>若该值存在就返回，否则返回other的数值。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(s);</span><br><span class="line">System.out.println(optional.orElse(<span class="string">&quot;没有值&quot;</span>));  <span class="comment">//没有值</span></span><br></pre></td></tr></table></figure>

<h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><ul>
<li>Java9发布于2017年9月发布，带来了很多新特性，其中 主要的变化是模块化系统。</li>
</ul>
<p><strong>模块化</strong></p>
<ul>
<li><p>模块就是代码和数据的封装体，模块的代码被组织成多个包，每个包中包含Java类和接口，模块的数据则包括资源文件和其他静态信息。</p>
</li>
<li><p>语法格式：<br>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，具体如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ExamSystemClient &#123;</span><br><span class="line">    <span class="comment">//将org.de.model暴露出去</span></span><br><span class="line">    <span class="keyword">exports</span> org.de.Model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ExamSystemServer &#123;</span><br><span class="line">    <span class="comment">//需要该模块所暴露出来的东西</span></span><br><span class="line">    <span class="keyword">requires</span> ExamSystemClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>模块化的优势：</p>
<ul>
<li>减少内存的开销。 </li>
<li>可简化各种类库和大型应用的 开发和维护。</li>
<li>安全性，可维护性，提高性能。</li>
</ul>
<p><strong>砖石操作符</strong></p>
<p>在Java9中允许在匿名内部类的使用中使用钻石操作符。即泛型的菱形特性，可以在匿名内部类中使用。</p>
<p><strong>集合工厂方法</strong></p>
<ul>
<li>Java9的List、Set和Map集合中增加了静态工厂方法of实现不可变实例的创建。</li>
<li>不可变体现在无法添加、修改和删除它们的元素。</li>
<li>不允许添加null元素对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(list);   <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">//list.add(3);   //异常：java.lang.UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>意义：</p>
<ul>
<li>保证线程安全：在并发程序中既保证线程安全性，也大大增强了并发时的效率。</li>
<li>被不可信的类库使用时会很安全。</li>
<li>如果一个对象不需要支持修改操作，将会节省空间和时间的开销。</li>
<li>可以当作一个常量来对待，并且这个对象在以后也不会被改变。</li>
</ul>
<p><strong>InputStream的增强</strong></p>
<p>InputStream类中提供了transferTo方法实现将数据直接传输到OutputStream中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  实现d://a.txt拷贝到d://b.txtw</span></span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d://a.txt&quot;</span>);</span><br><span class="line">    fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d://b.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//将 输入流InputStream数据 直接传输到 输出流OutputStream 中。</span></span><br><span class="line">    fis.transferTo(fos); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java10新特性"><a href="#Java10新特性" class="headerlink" title="Java10新特性"></a>Java10新特性</h2><ul>
<li>Java10于2018年3月发布，改进的关键点包括一个本地类型推断、一个垃圾回收的增强。</li>
<li>Java10计划只是一个短期版本，因此公开更新将在六个月内结束，9月份发布的Java11将是Java的长期支持（LTS）版本，LTS版本的发布每三年发布一次。</li>
</ul>
<p><strong>局部变量类型推断</strong></p>
<ul>
<li>Java10可以使用var作为局部变量类型推断标识符，此符号仅适用于局部变量，增强for循环的索引，以及传统for循环的本地变量。</li>
<li>它<strong>不能使用于</strong>方法形式参数，构造函数形式参数，方法返回类型，字段，catch形式参数或任何其他类型的变量声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动推断类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;            <span class="comment">//a是int类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;        <span class="comment">//b是String类型</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Person(); <span class="comment">//c是Person类型</span></span><br></pre></td></tr></table></figure>

<p>意义：</p>
<ul>
<li>标识符var不是关键字，只是一个保留的类型名称。这意味着var用作变量，<br>方法名或包名的代码不会受到影响，但var不能作为类或则接口的名字。</li>
<li>避免了信息冗余。</li>
<li>对齐了变量名。</li>
<li>更容易阅读。</li>
</ul>
<h2 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h2><p>Java11于2018年9月正式发布，这是 Java 大版本周期变化 后的第一个长期支持版本，非常值得关注。</p>
<p><strong>简单的编译运行操作</strong></p>
<ul>
<li><p>正常的编译运行操作：<br>javac 文件名.java(将编写的java文件编译成字节码文件)    —&gt;    java 文件名(将编译好的字节码文件解释并运行)</p>
</li>
<li><p>在Java11中可以使用java命令一次性进行编译和运行操作。</p>
</li>
<li><p>执行源文件中的第一个类必须包含主方法。</p>
</li>
<li><p>不可以使用其它源文件中自定义的类。</p>
</li>
</ul>
<p><strong>String类新增方法</strong></p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isBlank()</td>
<td>判断字符串是否为空或只包含空白代码点</td>
</tr>
<tr>
<td>Optional map(Function&lt;? super T,? extends U&gt; mapper)</td>
<td>根据参数指定规则的结果来得到Optional类型的对象</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>若该值存在就返回，否则返回other的数值。</td>
</tr>
</tbody></table>
<h1 id="在线考试系统"><a href="#在线考试系统" class="headerlink" title="在线考试系统"></a>在线考试系统</h1><p>（无）</p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p><strong>IO回顾：</strong></p>
<ul>
<li>IO：Input OutPut（输入 输出）</li>
<li>IO技术的作用：解决设备和设备之间的数据传输问题</li>
<li>IO的应用场景：图片上传、下载、打印机打印信息表、解析XML…</li>
</ul>
<p><strong>NIO：</strong></p>
<ul>
<li>即 <code>Java New IO</code></li>
<li>是1个全新的、 <code>JDK 1.4</code>后提供的 <code>IO API</code></li>
<li>Java API中提供了两套NIO，一套是针对<code>标准输入输出NIO</code>，另一套就是<code>网络编程NIO</code></li>
</ul>
<p><strong>作用和区别：</strong></p>
<ul>
<li><code>NIO</code>和<code>IO</code>有相同的作用和目的，但实现方式不同</li>
<li>可替代 标准<code>Java IO</code> 的<code>IO API</code></li>
<li>IO是以<strong>流</strong>的方式处理数据，而NIO是以<strong>块</strong>的方式处理数据。</li>
</ul>
<p><strong>流和块的比较：</strong></p>
<ul>
<li><p>NIO和IO最大的区别是数据打包和传输方式。</p>
</li>
<li><p>IO是以<strong>流</strong>的方式处理数据，而NIO是以<strong>块</strong>的方式处理数据。</p>
</li>
</ul>
<p><strong>面向流</strong>的IO一次一个字节的处理数据，一个输入流产生一个字节，一个输出流就消费一个字节。</p>
<p><strong>面向块</strong>的IO系统以块的形式处理数据。每一个操作都在一步中产生或消费一个数据块。按块要比按流快的多</p>
<p>（举例：拿水龙头来比喻：流就像水龙头滴水，每次只有一滴；块就像水龙头往水壶放水，放满之后对一整个水壶的水进行操作）</p>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><code>Java NIO</code>的核心组件 包括：</p>
<ul>
<li><p>缓冲区（<code>Buffer</code>）</p>
</li>
<li><p>通道（<code>Channel</code>）</p>
</li>
<li><p>选择器（<code>Selector</code>）</p>
</li>
</ul>
<p>在NIO中并不是以流的方式来处理数据的，而是以buffer缓冲区和Channel管道<strong>配合使用</strong>来处理数据。</p>
<p>Selector是因为NIO可以使用异步的非阻塞模式才加入的东西</p>
<p>简单理解一下：</p>
<ul>
<li><p>Channel管道比作成铁路，buffer缓冲区比作成火车(运载着货物)<br>而我们的NIO就是<strong>通过Channel管道运输着存储数据的Buffer缓冲区的来实现数据的处理</strong>！</p>
</li>
<li><p>要时刻记住：Channel不与数据打交道，它只负责运输数据。与数据打交道的是Buffer缓冲区</p>
</li>
<li><p><strong>Channel–&gt;运输</strong><br><strong>Buffer–&gt;数据</strong></p>
</li>
</ul>
<p>相对于传统IO而言，<strong>流是单向的</strong>。对于NIO而言，有了Channel管道这个概念，我们的<strong>读写都是双向</strong>的(铁路上的火车能从广州去北京、自然就能从北京返还到广州)！</p>
<h2 id="Buffer缓存区"><a href="#Buffer缓存区" class="headerlink" title="Buffer缓存区"></a>Buffer缓存区</h2><p>作用：缓冲区，用来存放具体要被传输的数据，比如文件、scoket 等。这里将数据装入 Buffer 再通过通道进行传输。</p>
<p>Buffer 就是一个数组，用来保存不同数据类型的数据</p>
<p>在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer，最常用的就是 ByteBuffer，对于 Java 中的基本类型，基本都有一个具体 Buffer 类型与之相对应，它们之间的继承关系如下图所示</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b08ppd"><img src="https://s4.ax1x.com/2022/03/05/b08ppd.png" alt="b08ppd.png"></a></p>
<ul>
<li>ByteBuffer：存储字节数据到缓冲区</li>
<li>ShortBuffer：存储字符串数据到缓冲区</li>
<li>CharBuffer： 存储字符数据到缓冲区</li>
<li>IntBuffer：存储整数数据到缓冲区</li>
<li>LongBuffer：存储长整型数据到缓冲区</li>
<li>DoubleBuffer：存储小数到缓冲区</li>
<li>FloatBuffer：存储小数到缓冲区</li>
</ul>
<p>对于 Java 中的基本数据类型，都有一个 Buffer 类型与之相对应，最常用的自然是<strong>ByteBuffer</strong> 类（二进制数据）</p>
<h3 id="ByteBuffer的创建方式"><a href="#ByteBuffer的创建方式" class="headerlink" title="ByteBuffer的创建方式"></a>ByteBuffer的创建方式</h3><ul>
<li><p>在堆中创建缓冲区：allocate(int capacity)， 常用。</p>
</li>
<li><p>在系统内存创建缓冲区：allocateDirect(int capacity)</p>
</li>
<li><p>通过普通数组创建缓冲区：wrap(byte[] arr)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在堆中创建缓冲区：allocate(int capacity)，常用</span></span><br><span class="line">ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在系统内存创建缓冲区：allocateDirect(int capacity)</span></span><br><span class="line">ByteBuffer byteBuffer2 = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过普通数组创建缓冲区：wrap(byte[] arr)</span></span><br><span class="line"><span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">ByteBuffer byteBuffer3 = ByteBuffer.wrap(bArr);</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><p>拿到一个缓冲区我们往往会做什么？很简单，就是<strong>读取缓冲区的数据/写数据到缓冲区中</strong>。</p>
<p>所以，缓冲区的核心方法就是:</p>
<ul>
<li>put(byte b) : 给缓冲区添加元素</li>
<li>get() :从缓存区获取一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Buffer对象</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//put放数据，byte类型数据。</span></span><br><span class="line">byteBuffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);</span><br><span class="line">byteBuffer.put(<span class="string">&quot;nihao&quot;</span>.getBytes());</span><br><span class="line">byteBuffer.put((<span class="keyword">byte</span>)<span class="number">5.12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="keyword">byte</span>[] bArr = byteBuffer.array();</span><br><span class="line">System.out.println(Arrays.toString(bArr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//get取数据</span></span><br><span class="line"><span class="keyword">byte</span> b = byteBuffer.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(b);   <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="核心变量"><a href="#核心变量" class="headerlink" title="核心变量"></a>核心变量</h3><p>Buffer类维护了4个核心变量属性来提供<strong>关于其所包含的数组的信息</strong>。它们是：</p>
<ul>
<li>容量Capacity<br><strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</li>
</ul>
<ul>
<li><p>位置Position<br><strong>下一个要被读或写的元素的位置</strong>。Position会自动由相应的 <code>get( )</code>和 <code>put( )</code>函数更新。</p>
</li>
<li><p>界限Limit<br><strong>缓冲区中可以操作数据的大小</strong>，代表了当前缓冲区中一共有多少数据（从limit开始后面的位置不能操作）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上三个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity</span><br><span class="line">例：- 如果我们创建一个新的容量大小为20 的 ByteBuffer 对象，在初始化的时候，position 设置为 0，</span><br><span class="line"> limit 和 capacity 被设置为 10，在以后使用 ByteBuffer对象过程中，capacity 的值不会再发生变化，而其它两个个将会随着使用而变化。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心变量值的变化过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//初始化的各属性值</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity = &quot;</span> + byteBuffer.capacity());  <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit    = &quot;</span> + byteBuffer.limit());     <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//put放数据后各属性值的变化,position更新</span></span><br><span class="line"><span class="keyword">byte</span>[] bArr = <span class="string">&quot;javaSE&quot;</span>.getBytes();</span><br><span class="line">byteBuffer.put(bArr);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity = &quot;</span> + byteBuffer.capacity());  <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//6</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit    = &quot;</span> + byteBuffer.limit());     <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要get取数据时，应该调用flip()。使得limit=position=6， position=0</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line">System.out.println(<span class="string">&quot;capacity = &quot;</span> + byteBuffer.capacity());  <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit    = &quot;</span> + byteBuffer.limit());     <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bArr2 = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];  <span class="comment">//因为Buffer对象只有limit个数据</span></span><br><span class="line">byteBuffer.get(bArr2);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bArr2));   <span class="comment">//javaSE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//get取数据后，各属性值的变化，position更新</span></span><br><span class="line">System.out.println(<span class="string">&quot;capacity = &quot;</span> + byteBuffer.capacity());  <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//6</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit    = &quot;</span> + byteBuffer.limit());     <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时，需要put继续放数据，应该调用clear()。使得position=0, limit=capacity=10</span></span><br><span class="line">byteBuffer.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;capacity = &quot;</span> + byteBuffer.capacity());  <span class="comment">//10</span></span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="string">&quot;limit    = &quot;</span> + byteBuffer.limit());     <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>标记Mark<br>一个备忘位置。<strong>用于记录上一次读写的位置</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//put放数据，position更新</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;ni&quot;</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用mark()标记此时的position,即2</span></span><br><span class="line">byteBuffer.mark();</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续put放数据，position更新</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;hao&quot;</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用reset()，将position更新为上次mark()标记位置，即2。</span></span><br><span class="line">byteBuffer.reset();</span><br><span class="line">System.out.println(<span class="string">&quot;position = &quot;</span> + byteBuffer.position());  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="Channel通道"><a href="#Channel通道" class="headerlink" title="Channel通道"></a>Channel通道</h2><p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 </p>
<p>Channel 类似于传统的“<strong>流</strong>”。</p>
<p>标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中（白话: 就是数据传输用的通道，作用是打开到IO设备的连接，文件、套接字都行）</p>
<p>例：相当于一根管子，buffer中的数据可以通过管子写入被操作的资源当中，也可以将资源通过管子写入到buffer中去</p>
<h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p> Java 为 Channel 接口提供的最主要实现类如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b0GGrt"><img src="https://s4.ax1x.com/2022/03/05/b0GGrt.png" alt="b0GGrt.png"></a></p>
<ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。 </li>
<li>DatagramChannel：通过 UDP 读写网络中的数据通道。 </li>
<li>SocketChannel：通过 TCP 读写网络中的数据。 </li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来 的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="FileChannel的使用"><a href="#FileChannel的使用" class="headerlink" title="FileChannel的使用"></a>FileChannel的使用</h3><p>使用FileChannel完成，将D://a.txt文件复制到D://b.txt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException</span>&#123;</span><br><span class="line">    <span class="comment">//将D://a.txt文件复制到D://b.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输入输出流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将输入输出流转换成FileChannel通道</span></span><br><span class="line">    FileChannel fileChannel1 = fis.getChannel();</span><br><span class="line">    FileChannel fileChannel2 = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用Channel通道，缓冲区Buffer在里面传输数据</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环，读写</span></span><br><span class="line">    <span class="keyword">while</span>(fileChannel1.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//flip之后，才能从Buffer缓冲区取出数据</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        fileChannel2.write(byteBuffer);</span><br><span class="line">        <span class="comment">//clear之后，才能继续在Buffer缓冲区放数据</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    fos.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于TCP编程"><a href="#基于TCP编程" class="headerlink" title="基于TCP编程"></a>基于TCP编程</h3><p>服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务器对象</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定端口号</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为非阻塞，就不会在accept那里一直等待客户端连接</span></span><br><span class="line">    <span class="comment">//ssc.configureBlocking(false);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待客户端连接</span></span><br><span class="line">    SocketChannel sc = ssc.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Channel通道，利用Buffer缓冲区传输数据</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端数据</span></span><br><span class="line">    <span class="keyword">int</span> len = sc.read(byteBuffer);</span><br><span class="line">    <span class="comment">//处理数据</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反馈消息给客户端</span></span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    byteBuffer.put(<span class="string">&quot;收到！&quot;</span>.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    sc.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    sc.close();</span><br><span class="line">    ssc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建客户端对象</span></span><br><span class="line">    SocketChannel sc = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置连接的服务器的ip，端口</span></span><br><span class="line">    sc.connect(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Channel通道，利用Buffer缓冲区传输数据</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">&quot;哈哈哈哈哈&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出数据给服务器</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    sc.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收服务器的消息</span></span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    <span class="keyword">int</span> len = sc.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理数据</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h2><p><strong>多路复用</strong>：<br>一个选择器可以同时监听多个服务器端口, 帮多个服务器端口同时等待客户端的访问</p>
<p><strong>关系：</strong></p>
<p>Channel和Buffer比较好理解 ，联系也比较密切，他们的关系简单来说就是：数据总是从通道中读到buffer缓冲区内，或者从buffer写入到通道中。</p>
<p>选择器（Selector） 是 Channel（通道）的多路复用器，Selector 可以同时监控多个 通道的 IO（输入输出） 状况。</p>
<p><strong>作用</strong>：<br>选择器提供选择执行已经就绪的任务的能力。从底层来看，Selector提供了询问通道是否已经准备好执行每个I/O操作的能力。Selector 允许单线程处理多个Channel。仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道，这样会大量的减少线程之间上下文切换的开销。</p>
<p><strong>可选择通道</strong></p>
<p>注意：并不是所有的Channel，都是可以被Selector 复用的。比方说，FileChannel就不能被选择器复用。为什么呢？</p>
<p>判断一个Channel 能被Selector 复用，有一个前提：判断他是否继承了一个抽象类SelectableChannel。如果继承了SelectableChannel，则可以被复用，否则不能。</p>
<p>SelectableChannle 的结构如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b0YRgJ"><img src="https://s4.ax1x.com/2022/03/05/b0YRgJ.png" alt="b0YRgJ.png"></a></p>
<p>SelectableChannel类提供了实现通道的可选择性所需要的公共方法</p>
<p><strong>通道和选择器注册之后，他们是绑定的关系吗？</strong></p>
<p>答:不是。不是一对一的关系。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</p>
<p>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector对象上，在注册的时候，需要指定通道的哪些操作，是Selector感兴趣的。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b0Yq8e"><img src="https://s4.ax1x.com/2022/03/05/b0Yq8e.png" alt="b0Yq8e.png"></a></p>
<h3 id="Channel注册到Selector上"><a href="#Channel注册到Selector上" class="headerlink" title="Channel注册到Selector上"></a>Channel注册到Selector上</h3><p>使用Channel.register（Selector sel，int ops）方法，将一个通道注册到一个选择器时。</p>
<p>​                                         第一个参数：指定通道要注册的选择器是谁</p>
<p>​                                         第二个参数：指定选择器需要查询的通道操作</p>
<p>可以供选择器查询的通道操作，从类型来分，包括以下四种：</p>
<p>​                                        （1）可读 : SelectionKey.OP_READ</p>
<p>​                                        （2）可写 : SelectionKey.OP_WRITE</p>
<p>​                                        （3）连接 : SelectionKey.OP_CONNECT</p>
<p>​                                        （4）接收 : SelectionKey.OP_ACCEPT</p>
<p>如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将通道注册到选择器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1，创建Selector选择器</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2，创建ServerSocketeChannel通道</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">//绑定端口号</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3，将通道Channel注册到选择器Selector上，并指定监听的事件为“接收”事件</span></span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面通过调用通道的register()方法会将它注册到一个选择器上。</p>
<p>首先需要注意的是：</p>
<p>与Selector一起使用时，Channel<strong>必须处于非阻塞模式</strong>下，否则将抛出异常IllegalBlockingModeException</p>
<h3 id="选择键SelectionKey"><a href="#选择键SelectionKey" class="headerlink" title="选择键SelectionKey"></a>选择键SelectionKey</h3><p>Channel和Selector的关系确定好后（注册），并且一旦通道处于某种就绪的状态，就可以被选择器查询到。这个工作，使用选择器Selector的select（）方法完成。select方法的作用，对感兴趣的通道操作，进行就绪状态的查询。</p>
<p>Selector可以不断的查询Channel中发生的操作的就绪状态。并且挑选感兴趣的操作就绪状态。一旦通道有操作的就绪状态达成，并且是Selector感兴趣的操作，就会被Selector选中，放入选择键集合中。</p>
<ul>
<li><p>select()：选择器等待客户端连接的方法，<br>阻塞问题:</p>
<pre><code>    1.在开始没有客户访问的时候是阻塞的
    2.在有客户来访问的时候方法会变成非阻塞的
    3.如果客户的访问被处理结束之后,又会恢复成阻塞的
</code></pre>
</li>
<li><p>selectedKeys()：选择器会把被连接的服务端对象放在Set集合中,这个方法就是返回一个Set集合</p>
</li>
</ul>
<h3 id="轮询查询就绪操作"><a href="#轮询查询就绪操作" class="headerlink" title="轮询查询就绪操作"></a>轮询查询就绪操作</h3><p>注册完后，万事俱备，下一步是查询就绪的操作。</p>
<p>通过Selector的 select() 方法，可以查询出已经就绪的通道操作的个数，这些就绪的状态集合，包存在一个元素是SelectionKey对象的Set集合中。</p>
<p>1，select()方法返回的int值，表示有多少通道已经就绪</p>
<p>2，通过调用Selector的selectedKeys()方法来访问已选择键集合，然后迭代集合的每一个选择键元素，根据就绪操作的类型，完成对应的操作：</p>
<p>服务器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象1</span></span><br><span class="line">        ServerSocketChannel ssc1 = ServerSocketChannel.open();</span><br><span class="line">        ssc1.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">5555</span>));</span><br><span class="line">        ssc1.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象2</span></span><br><span class="line">        ServerSocketChannel ssc2 = ServerSocketChannel.open();</span><br><span class="line">        ssc2.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        ssc2.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象3</span></span><br><span class="line">        ServerSocketChannel ssc3 = ServerSocketChannel.open();</span><br><span class="line">        ssc3.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line">        ssc3.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建选择器对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将通道分别注册到选择器上，监听的操作都为“接收”事件</span></span><br><span class="line">        ssc1.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc2.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc3.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//selector.select()类监听的事件“准备就绪”的个数</span></span><br><span class="line">        <span class="keyword">while</span>(selector.select() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//准备就绪的事件，会存放在selectedKeys()返回的Set集合中</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(selectionKeys.hasNext())&#123;</span><br><span class="line">                SelectionKey selectionKey = selectionKeys.next();</span><br><span class="line">                <span class="comment">//判断就绪的事件是什么事件，根据不同的事件执行不同的操作，这里只以“接收”事件为例</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//获取ServerSocketChannel管道</span></span><br><span class="line">                    ServerSocketChannel ssc = (ServerSocketChannel)selectionKey.channel();</span><br><span class="line">                    <span class="comment">//等待客户端连接</span></span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    <span class="comment">//获取数据</span></span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span>((len = sc.read(byteBuffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>, len));</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移除选择建</span></span><br><span class="line">                selectionKeys.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，可以创建多个客户端来访问这个服务器，端口为5555，6666，7777，都可以同时连接得上。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>感谢老铁的支持！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="唧唧歪歪 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="唧唧歪歪 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2/" rel="prev" title="数据分析与挖掘(数据分析三剑客)">
                  <i class="fa fa-chevron-left"></i> 数据分析与挖掘(数据分析三剑客)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/09/MySQL/" rel="next" title="MySQL">
                  MySQL <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzYzOC8zMDExMQ=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唧唧歪歪</span>
</div>
<div class="busuanzi-count">
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
