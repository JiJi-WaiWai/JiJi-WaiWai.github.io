<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jiji-waiwai.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="JaveSE 这是一篇关于javaSE基础的笔记 其中包括java面向对象，java核心类库，java型特性和项目">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="https://jiji-waiwai.github.io/2021/12/11/JavaSE/index.html">
<meta property="og:site_name" content="De&#39;s Blog">
<meta property="og:description" content="JaveSE 这是一篇关于javaSE基础的笔记 其中包括java面向对象，java核心类库，java型特性和项目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/11/oTqXEq.png">
<meta property="og:image" content="https://s4.ax1x.com/2021/12/12/oq9Xb6.png">
<meta property="article:published_time" content="2021-12-11T06:41:56.000Z">
<meta property="article:modified_time" content="2021-12-25T16:22:32.362Z">
<meta property="article:author" content="唧唧歪歪">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2021/12/11/oTqXEq.png">


<link rel="canonical" href="https://jiji-waiwai.github.io/2021/12/11/JavaSE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jiji-waiwai.github.io/2021/12/11/JavaSE/","path":"2021/12/11/JavaSE/","title":"JavaSE"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaSE | De's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://GitHub.com/JiJi-WaiWai" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">De's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">Java面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">方法和封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.2.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">1.2.4.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.5.</span> <span class="nav-text">封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.</span> <span class="nav-text">static关键字和继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">构造块和静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%EF%BC%88Singleton%E7%B1%BB%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">单例设计模型（Singleton类）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.4.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">1.3.5.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E8%80%83%E7%82%B9"><span class="nav-number">1.3.6.</span> <span class="nav-text">构造块和静态代码块的考点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="nav-number">1.3.7.</span> <span class="nav-text">常用的访问控制符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package%E5%8C%85"><span class="nav-number">1.3.8.</span> <span class="nav-text">package包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.9.</span> <span class="nav-text">final关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%92%8C%E7%89%B9%E6%AE%8A%E7%B1%BB-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">多态和特殊类(抽象类,接口)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.1.</span> <span class="nav-text">多态特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">引用数据类型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">多态的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.4.4.</span> <span class="nav-text">抽象方法和抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.5.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">特殊类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">普通内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.5.2.</span> <span class="nav-text">枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">自定义枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">用enum定义枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enum%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Enum类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E9%87%8D%E5%86%99%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">枚举类重写接口方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.5.3.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">定义和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%84%E5%88%B6%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">常见的预制注解</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93-%E4%B8%8A"><span class="nav-number">2.</span> <span class="nav-text">Java核心类库(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">常用类的概述和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="nav-number">2.1.1.</span> <span class="nav-text">常用的包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">equals()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">hashCode()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString-NaN"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">toString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getClass"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">getClass()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">2.1.3.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">Integer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bouble"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">Bouble</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boolean"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">Boolean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Character"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">Character</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%A4%84%E7%90%86%E7%B1%BB"><span class="nav-number">2.1.4.</span> <span class="nav-text">数学处理类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigDecimal"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">BigDecimal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigInteger"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">BigInteger</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">String类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.1.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">常用构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">常用成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.2.4.</span> <span class="nav-text">正则表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93-%E4%B8%8B"><span class="nav-number">3.</span> <span class="nav-text">Java核心类库(下)</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="唧唧歪歪"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">唧唧歪歪</p>
  <div class="site-description" itemprop="description">踏上新征程----go！！！</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JiJi-WaiWai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JiJi-WaiWai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1753645532@qq.com" title="E-Mail → mailto:1753645532@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://tool.gljlw.com/qq/?qq=1753645532" title="http:&#x2F;&#x2F;tool.gljlw.com&#x2F;qq&#x2F;?qq&#x3D;1753645532" rel="noopener" target="_blank">加qq</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiji-waiwai.github.io/2021/12/11/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="唧唧歪歪">
      <meta itemprop="description" content="踏上新征程----go！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="De's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-11 14:41:56" itemprop="dateCreated datePublished" datetime="2021-12-11T14:41:56+08:00">2021-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-26 00:22:32" itemprop="dateModified" datetime="2021-12-26T00:22:32+08:00">2021-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jave/" itemprop="url" rel="index"><span itemprop="name">jave</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>JaveSE</p>
<p>这是一篇关于javaSE基础的笔记</p>
<p>其中包括java面向对象，java核心类库，java型特性和项目</p>
<span id="more"></span>

<h1 id="Java面向对象编程"><a href="#Java面向对象编程" class="headerlink" title="Java面向对象编程"></a>Java面向对象编程</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>定义类：class 类名{ 类体 }。<br><code>class Person&#123;&#125;</code></p>
<p>创建对象：new 类名();<br><code>Person p = new Person();</code></p>
<p>成员变量的定义：数据类型 变量名 = 初始值;<br><code>int age;</code></p>
<p>成员方法的定义：返回值类型 方法名（参数）{ 方法体 }<br><code>void setAge(int age)&#123; &#125;</code></p>
<p>成员方法的可变长参数，即该参数长度是0~~n个，最多定义一个，而且放在最后一个参数。使用时，相当于一维数组。<br>可变长参数定义<code>void xiaoName(String... args)&#123; &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;, 今年&quot;</span> + age + <span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">xiaoName</span><span class="params">(String... args)</span><span class="comment">/*可变参数*/</span> </span>&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个参数是：&quot;</span> + args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建Person类型引用指向Person类型对象</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.setName(<span class="string">&quot;李&quot;</span>);</span><br><span class="line">		p.age = <span class="number">18</span>;</span><br><span class="line">		p.show();</span><br><span class="line">		p.xiaoName(<span class="string">&quot;德&quot;</span>, <span class="string">&quot;昭的&quot;</span>, <span class="string">&quot;得得&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>1）基本数据类型：byte、short、char、int、long、float、double、boolean 八个。</p>
<p>这些基本数据类型定义变量时，内存中的栈区会申请一个存储单元用来存储数据。</p>
<p>如 int a = 10;  内存中的栈区申请一个名为a的存储单元，大小为4个字节，里面存放着数据10。</p>
<p>2）引用数据类型：数组、类、接口、枚举、标注</p>
<p>用引用数据类型（数组、类、接口、枚举、标注）定义的变量叫做引用型变量，简称<strong>引用</strong>。如<code>Person p</code></p>
<p>引用数据类型在定义时，如<code>Person p = new Person();</code> ，内存中的栈区申请一个名为p的存储单元，用来存放地址。而new Person()这部分存放在内存中的堆区，有数据。假设new Person()在堆区中的地址是0x10，而p中存放的就是这个地址0x10。</p>
<p>如图，变量a为int类型，在栈区中存放的是数据10。引用型变量（引用）p为Person类型（类），在栈区中存放的是一个地址（0x10），该地址指向堆区中的new Person()，而new Person()中才有数据。</p>
<p>基本数据类型变量中存放的是数据，而引用数据类型变量中存放的是地址。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oTqXEq"><img src="https://s4.ax1x.com/2021/12/11/oTqXEq.png" alt="oTqXEq.png" border="0" /></a></p>
<p><strong>注意</strong>：</p>
<p>基本数据类型的变量，作为方法的参数传递时，形参不会影响到实参，因为这两个变量存放的是各自的数据，虽然数据一样。</p>
<p>引用数据类型的变量，作为方法的参数传递时，形参可能会影响到实参，因为这两个变量存放的是同一个地址。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>其实创建对象是<code>new Person();</code>,此时内存堆区会申请一块空间存放对象，但是由于没有引用型变量（引用）指向该对象的地址，就会被当作垃圾回收。所以创建对象时使用<code>Person p = new Person();</code>,含义是“创建Person类型引用p指向Person类型对象”。引用型变量p存放着对象的地址，因此不会被回收。</p>
<h2 id="方法和封装"><a href="#方法和封装" class="headerlink" title="方法和封装"></a>方法和封装</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>使用new关键字创建对象时，会自动调用构造方法。一般用于对象的初始化工作</p>
<p>定义：</p>
<ul>
<li><p>不用写返回值类型</p>
</li>
<li><p>构造方法名和类名一致</p>
</li>
</ul>
<p>当用户没有定义构造方法时，系统会默认定义一个无参无内容的构造方法，如Person类，<code>Person()&#123;&#125;</code></p>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>重载：方法名可以相同，但是参数个数，或类型，或顺序不一样。</p>
<p>例如：一般我们定义构造方法时，会定义一个有参的构造方法，同时再定义一个无参的构造方法，这就属于重载。</p>
<p>意义：调用用一个方法名，参数不一样可以实现不同的功能。例如println()方法，调用该方法我们传参可以是多种数据类型，但是依然可以打印出来，是因为官方写好了许多个println()同名不同参数方法。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>在类中使用this关键字表示，创建的该对象本身。</p>
<p>用法：</p>
<ul>
<li>this.成员变量、this.成员方法：当成员变量和局部变量重名时，系统会就近原则。变量前加上this.前缀，就表明是成员变量。（成员方法相同）</li>
<li>this还可以当作返回值，表示该对象本身。返回值类型就是该类名的类型。</li>
<li><code>this();</code>用在构造方法的第一行，可以调用本类的其他构造方法</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归：定义 方法时，该方法会调用该方法自己</p>
<p>例如：计算费氏数列：1，1，2，3，5，8，13，21，第一项和第二项是1，之后的每一项的前两项和。下面分别使用递归和递推(循环)实现。传入第n项，返回第n项的数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FengShi</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">diGui</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//用递归的方法计算</span></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span> || n ==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> diGui(n-<span class="number">1</span>) + diGui(n-<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">diTui</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//用递推的方法计算</span></span><br><span class="line">		<span class="keyword">int</span> ia = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ib = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ic;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			ic = ia + ib;</span><br><span class="line">			ia = ib;</span><br><span class="line">			ib = ic;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ib;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，使用递归代码简单明了，而递推复杂。但是递归代码的执行速度慢许多。</p>
<p><strong>递归注意事项</strong></p>
<ul>
<li>使用递归必须有递归规律以及退出条件</li>
<li>使用递归是把问题变得简单化而不是复杂化</li>
<li>若递归影响到程序的执行性能，则不推荐。建议使用递推取代之。</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常情况下测试类给成员变量赋值一些合法但不合理的数值，程序不会报错，但是与现实不符。例如age赋值负数等。</p>
<p>为避免这一现象，需要对成员变量进行密封包装处理，保证成员变量的合理性，该机制就叫封装。</p>
<p>步骤：</p>
<ul>
<li><p>私有化成员变量，用private关键字修饰。如<code>private int age;</code></p>
</li>
<li><p>提供公有的set和get成员方法来访问成员变量，在方法中对合理值进行判断</p>
</li>
<li><p>构造方法中也调用set方法进行合理值判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1,私有化成员变量。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3,构造方法也调用成员方法来初始化成员变量。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		setAge(age);</span><br><span class="line">		setName(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2,提供我们写成员方法来访问成员变量，成员方法会判断参数是否正确。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;age不能小于0岁。&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义show()来打印对象的特征</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>案例</strong></em>：使用上面定义的类完成。提示用户输入人数，然后输入学生信息：姓名，年龄，最后打印出来。</p>
<p>提示：Student[] arr = new Student[num];</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入学生人数：&quot;</span>);</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">		<span class="comment">//根据输入的人数，创建Student引用类型的一维数组</span></span><br><span class="line">		Student[] arr = <span class="keyword">new</span> Student[num];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入name和age：&quot;</span>);</span><br><span class="line">			arr[i] = <span class="keyword">new</span> Student(sc.next(), sc.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">			arr[i].show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student[] arr = new Student[num];</code>，表示创建一个一维数组，数组类型是自己定义的Student引用类型。数组中的每个元素都是Student引用类型变量，里面存放的只是地址，指向后面创建的对象。如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oq9Xb6"><img src="https://s4.ax1x.com/2021/12/12/oq9Xb6.png" alt="oq9Xb6.png" border="0" /></a></p>
<h2 id="static关键字和继承"><a href="#static关键字和继承" class="headerlink" title="static关键字和继承"></a>static关键字和继承</h2><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>在类中正常定义的成员方法或变量隶属于<strong>对象层级</strong>，即创建对象时才拥有。且每个对象独有一份，互不影响，需要通过 <code>引用.成员</code> 的方式调用。</p>
<p>在定义成员时，加上static关键字修饰，就变成了静态成员，由原来的<strong>对象层级</strong>上升为<strong>类层级</strong>。即加载该类时就出现了，跟创不创建对象没有关系。类拥有一份，且被所有实例对象共享该同一份。不仅可通过 <code>引用.成员</code> 调用，还可以 <code>类名.成员</code> 调用。推荐 <code>类名.成员</code> 调用。</p>
<p><strong>static修饰成员变量</strong></p>
<p>例如：<code>public static String country;</code></p>
<p>变量由对象层级上升为类层级，叫做静态变量或者类变量。类和对象共享同一份该变量，所以一个改变该对象值，大家都跟着改变。不仅可通过 <code>引用.变量</code> 调用，还可以 <code>类名.变量</code> 调用。</p>
<p><strong>staitc修饰成员方法</strong></p>
<p>例如：<code>public static void show(参数) &#123;方法体&#125;</code></p>
<p>方法由对象层级上升为类层级，叫做静态方法或者类方法。不仅可通过 <code>引用.方法</code> 调用，还可以 <code>类名.方法</code> 调用。</p>
<p>由于方法是static修饰，属于类层级，所以在加载类时就已经被加载了，跟创建不创建对象无关。<br>而非静态的成员属于对象层级，必须要在创建对象后才出现。<br>所以在静态方法中只能访问静态成员，不可以访问非静态的成员，也不可以出现this之类跟对象有关的关键字（因为对象可能还没被创建）。</p>
<p>非静态方法即能访问非静态成员又可以访问静态成员。</p>
<p><strong>注意</strong>：</p>
<p>在开发中只有隶属于类层级并被所有对象共享的内容才可以使用static关键字修饰。（不能滥用static关键字）</p>
<h3 id="构造块和静态代码块"><a href="#构造块和静态代码块" class="headerlink" title="构造块和静态代码块"></a>构造块和静态代码块</h3><p>构造块：在类中直接大括号{}括起来的代码叫构造快，在每次创建对象时，构造方法之前执行。</p>
<p>静态代码块：在构造快前面加上static关键字。当类被加载时立马执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态代码块</span></span><br><span class="line">    <span class="comment">//需要在执行代码块之前随着类的加载做一些准备工作，比如，加载数据库的驱动包等。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//构造块。</span></span><br><span class="line">    <span class="comment">//需要在执行构造方法体之前做一些准备工作，比如，对成员变量经行统一初始化操作。</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是构造块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：当该类被加载时，就会立马调用一次”静态代码块“。此后，每次创建一个对象都会调用”构造块“，接着再调用”构造方法“。</p>
<h3 id="单例设计模型（Singleton类）"><a href="#单例设计模型（Singleton类）" class="headerlink" title="单例设计模型（Singleton类）"></a>单例设计模型（Singleton类）</h3><p>编程实现Singleton类，并且该类只能创建一个对象。</p>
<p>如下：</p>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//饿汉式，创建了引用 s 立马创建对象并指向，推荐</span></span><br><span class="line">    <span class="comment">//2,声明本类类型的引用指向本类类型的对象，配合private，static。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="comment">//1,私有化构造方法(private)，使得外面不能直接通过&quot;new 类名();&quot;的方式创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3,提供公有的get方法将类中定义的对象返回出去，配合public，static。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//懒汉式，创建了引用 s 并没有初始化,而是在后面方法里初始化。</span></span><br><span class="line">    <span class="comment">//2,声明本类类型的引用指向暂时为null，配合private，static。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">//1,私有化构造方法(private)，使得外面不能直接通过&quot;new 类名();&quot;的方式创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//3,提供公有的get方法将类中定义的对象返回出去，配合public，static。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">			s = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，可以外面只可以通过提供的共有的静态方法getSingleton()，即 <code>类名.静态方法（）</code> 的方法得到该类创建的对象。并且无论调用多少次方法，得到的都是同一个对象。</p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Singleton s1 = Singleton.getSingleton();</span><br><span class="line">        Singleton s2 = Singleton.getSingleton();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1 = &quot;</span> + s1);   <span class="comment">/*s1 = org.de.test_3.Singleton@312b1dae*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s2 = &quot;</span> + s2);   <span class="comment">/*s2 = org.de.test_3.Singleton@312b1dae*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p>当Singleton类被加载时，静态变量<code>private static Singleton s = new Singleton();</code>就被加载，栈区创建引用s指向堆区创建的对象。执行静态方法<code>getSingleton()</code>，返回引用s。即返回堆区对象的地址。而无论调用多少次<code>getSingleton()</code>方法，返回的都是同一个地址，即同一个对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>例如定义教师类、定义工人类、学生类等等，这些类都有些共同的特征，比如它们都有人的特征。每个类都重新定义有关人的特征的话，重复代码严重。所以可以定义一个人类，而这些类都继承人类。</p>
<p>使用extends关键字表示继承关系，例如：<code>public class Teach extends People&#123;&#125;</code><br>Teach类继承People类。其中<br>Person类叫做父类，超类，基类<br>Teach类叫做子类，派生类，孩子类<br>Teach类继承People类后，就可以继承People类的成员方法和变量。</p>
<p>意义：使用继承提高了代码的复用性，可维护性及扩展性，是多态的前提条件</p>
<p>继承的特点：</p>
<ul>
<li>子类不能继承父类的构造方法和私有方法，但私有成员变量可以被继承，只是不能直接访问</li>
<li>无论调用何种方法创建子类对象是都会调用父类的无参构造方法，来初始化从父类继承的成员变量，相当于在子类的构造方法的第一行增加代码super()的效果。</li>
<li>使用继承必须满足逻辑关系：子类 is a 父类，例如老师 是 一个 人。也就是继承不能滥用。</li>
<li>java语言只支持单继承。一个子类只能有一个父类，但一个父类可以有多个子类。</li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>从父类中继承下来的方法不满足子类的需求时，就需要在子类中重写一个新的和父类一样名字的方法，来覆盖从父类中继承下来的版本。该方式叫做方法的重写( Override )。</p>
<p>重写方法时，可以在方法上一行写<code>@Override</code>，有助于帮助我们检查该方法是不是重写。</p>
<p>重写原则：</p>
<ul>
<li>方法名相同、参数列表相同、返回值类型相同，从java5开始允许返回子类类型</li>
<li>方法的访问权限不能变小，可以相同或变大。</li>
<li>方法不能抛出更大的异常（异常机制）。</li>
</ul>
<p><strong>代码演示：</strong></p>
<p>封装了一个Animal类，有age、name私有变量，show()打印特征的成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        setAge(age);</span><br><span class="line">        setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是动物，我叫&quot;</span> + getName() + <span class="string">&quot;，今年&quot;</span> + getAge() + <span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装了一个Dog类，该类继承了Animal类。该类有tooth私有变量，还重写了父类的show()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tooth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">int</span> tooth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name);</span><br><span class="line">        setTooth(tooth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTooth</span><span class="params">(<span class="keyword">int</span> tooth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tooth = tooth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTooth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tooth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是狗狗有&quot;</span> + getTooth() +<span class="string">&quot;颗牙齿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装了一个Cat类，该类继承了Animal类。该类有color私有变量，还重写了父类的show()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> age, String name, String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age, name);</span><br><span class="line">        setColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是猫，我的颜色是&quot;</span> + getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造块和静态代码块的考点"><a href="#构造块和静态代码块的考点" class="headerlink" title="构造块和静态代码块的考点"></a>构造块和静态代码块的考点</h3><p>假设：父类有构造方法，构造块，静态代码块。子类继承了父类，子类中也有构造方法，构造块，静态代码块。<br>问：  执行流程。</p>
<p>刚开始父类比子类先加载出来，所以先执行父类的静态代码块，再执行子类的静态代码块（一次）。<br>（由于创建子类对象一定会调用父类的构造方法怎么一说）<br>所以然后每次创建一个子类的对象时，都会先执行父类的构造块—–&gt;父类的构造方法——&gt;再执行子类的构造块—–&gt;子类的构造方法</p>
<h3 id="常用的访问控制符"><a href="#常用的访问控制符" class="headerlink" title="常用的访问控制符"></a>常用的访问控制符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一个包中的类</th>
<th>子类</th>
<th>其他类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
</tr>
<tr>
<td>protected</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不能访问</td>
</tr>
<tr>
<td>默认，即不写</td>
<td>可以访问</td>
<td>可以访问</td>
<td>不能访问</td>
<td>不能访问</td>
</tr>
<tr>
<td>private</td>
<td>可以访问</td>
<td>不能访问</td>
<td>不能访问</td>
<td>不能访问</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>public修饰的成员可以在任意位置使用</li>
<li>private修饰的成员只能在本类内部使用</li>
<li>通常情况下，没有特殊要求，成员方法用public修饰，成员变量用private修饰。</li>
</ul>
<h3 id="package包"><a href="#package包" class="headerlink" title="package包"></a>package包</h3><p>定义类需要指定类名，仅仅将类名作为类的唯一标识，会出现命名冲突的问题。<br>java用包（package）的概念解决该问题</p>
<ul>
<li><p>定义类的时，还需要指定一个包，例如：<br>package 包名;<br>package 包名1.包名2.包名3…..包名n;</p>
</li>
<li><p>为实现项目管理、解决命名冲突以及权限控制的效果</p>
</li>
</ul>
<p>定义包规范：<br>例如：org.apache.commons.lang.StringUtil<br>其中StringUtil是类名，而org.apache.commons.lang是多层包名，含义：<br>org.apache表示公司或组织的信息，<br>commons表示项目的名称信息，<br>lang表示模块的名称信息。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final表示最终的、不可改变的。可以修饰类，成员方法和成员变量。</p>
<ul>
<li>final关键字修饰类，表示该类不能被继承。<br>主要用于防止滥用继承，如：java.lang.String类等。</li>
<li>final关键字修饰成员方法，表示该方法不能被重写，但可以被继承。<br>主要用于防止不经意间造成重写，如java.text.Dateformat类中的format方法等。</li>
<li>final关键字修饰成员变量，表示该变量必须初始化且不能被改变了。<br>初始化的三种方式：定义时直接加等于号“=”初始化，在构造方法中初始化，在构造块中初始化。<br>主要用于防止不经意间造成改写，如java.lang.Thread类中的MAX_PRIORITY等。</li>
</ul>
<p><strong>常量</strong>：</p>
<p>用final关键字修饰的成员变量一般叫做常量。<br>但是通常不会单独使用final关键字修饰，会配合public static final关键字一起修饰来表达常量的含义。<br>常量的命名规范：所有字母要大写，不同单词之间用下划线连接。</p>
<h2 id="多态和特殊类-抽象类-接口"><a href="#多态和特殊类-抽象类-接口" class="headerlink" title="多态和特殊类(抽象类,接口)"></a>多态和特殊类(抽象类,接口)</h2><p>多态是指同一种事物表现出来的多种形态</p>
<p>饮料：可乐、雪碧、红牛、旺仔·····<br>宠物：猫、狗、鱼······<br>人：学生、老师、工人、警察······</p>
<p>多态语法格式：<br><code>父类类型 引用变量名 = new 子类类型();</code><br>声明父类类型的引用指向子类类型对象。</p>
<p>如：创建了Animal类。再创建Dog类，其中Dog类继承Animal类。再创建Cat类，其中Cat类继承Animal类。<br>多态：<code>Animal a1 = new Dog();</code>  或 <code>Animal a2 = new Cat();</code></p>
<p>其实，父类引用指向子类对象的形式就叫做多态。</p>
<h3 id="多态特点"><a href="#多态特点" class="headerlink" title="多态特点"></a>多态特点</h3><ul>
<li>当父类类型的引用指向子类类型的对象时(多态)，父类类型的引用可以直接调用父类独有的方法</li>
<li>当父类类型的引用指向子类类型的对象时(多态)，父类类型的引用不能直接调用子类独有的方法。（强制类型转换成子类就可以解决）</li>
<li>对与父类和子类都有的非静态方法来说(重写)，编译阶段调用父类版本，运行阶段调用子类重写的版本。</li>
<li>对于父类和子类都有的静态方法来说，编译和运行阶段都调用父类版本。（因为静态成员跟创建不创建对象无关，所以和子类无关）</li>
</ul>
<h3 id="引用数据类型的转换"><a href="#引用数据类型的转换" class="headerlink" title="引用数据类型的转换"></a>引用数据类型的转换</h3><p>父类类型可以理解为较大的类型，子类类型可以理解为较小的类型。<br>引用数据类型的转换方式有：自动类型转换、强制类型转换<br>转换方法跟基本数据类型相似。</p>
<ul>
<li>自动类型转换：指小类型转换成大类型，即子类转父类，也叫向上转型。比如多态的语法格式：Animal a = new Dog();</li>
<li>强制类型转换：指大类型转换成小类型，即父类转子类，也叫向下转换。比如：将上面的Animal a转换一下成Dog类型，Dog d = (Dog) a;</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>引用数据类型的转换必须发生再父子类之间，否则编译报错</li>
<li>若强制转换的目标不是该引用真正指向的数据类型时，编译通过，但是运行异常。ClassCastException类型转换异常。案例如下：</li>
</ul>
<p>例如，有Animal类作为父类，有Dog类和Cat类都继承Animal类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line"> <span class="comment">//该代码在运行报错，ClassCastException类型转换异常</span></span><br><span class="line">Cat c = (Cat)a;   </span><br><span class="line">Dog d = (Dog)a;  <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>如上，a虽然是Animal类型，但是真正意义上却是Dog类型。所以即使通过强制转换也不能转换成Cat类型。</p>
<p>为了避免上述错误发生，应该在强制转之前进行判断，借助instanceof，格式：<br>if(引用变量 instanceof 数据类型){ 为真时执行 }</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;可以放心强制转换&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;不可以转换哦&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><p>例如，有Animal类作为父类，有Dog类和Cat类都继承Animal类。<br>要求：1，自定义方法实现，将参数指定的Dog对象的特征打印出来。<br>            2，自定义方法实现，将参数指定的Cat对象的特征打印出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//要求1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Dog d)</span></span>&#123;</span><br><span class="line">        d.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要求2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Cat c)</span> </span>&#123;</span><br><span class="line">        c.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试，调用</span></span><br><span class="line">        Test2.test(<span class="keyword">new</span> Dog(<span class="number">18</span>, <span class="string">&quot;WangCai&quot;</span>, <span class="number">27</span>));</span><br><span class="line">        Test2.test(<span class="keyword">new</span> Cat(<span class="number">10</span>, <span class="string">&quot;Baozi&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，Animal类中只有两个子类Dog和Cat。假如有n个子类，这类要求也是n个。代码冗余严重。<br>借助多态，可以完美解决该问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//形参是父类类型的引用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal a)</span> </span>&#123; </span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">        Test2.test(<span class="keyword">new</span> Animal());</span><br><span class="line">        <span class="comment">//实参是子类类型的对象。</span></span><br><span class="line">        Test2.test(<span class="keyword">new</span> Dog(<span class="number">18</span>, <span class="string">&quot;WangCai&quot;</span>, <span class="number">27</span>));</span><br><span class="line">        Test2.test(<span class="keyword">new</span> Cat(<span class="number">10</span>, <span class="string">&quot;Baozi&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态的使用场合之一：通过传参的方法，实现多态。形参是父类类型的引用，实参是子类类型的对象。</p>
<h3 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h3><p>抽象方法：在定义方法时，加上abstract关键字。抽象方法没有方法体。如：<br><code> public abstract void show(参数);</code></p>
<p>抽象类：在定义时，加上abstract关键字。如：<br><code>public abstract class 类名&#123; 类体 &#125;</code></p>
<ul>
<li>抽象方法一定要定义在抽象类中。</li>
<li>抽象类中可以有或着没有，成员变量，成员方法，构造方法，抽象方法等。</li>
<li>抽象类不可以实例化对象（万一实例化了对象，而对象又调用了没有方法体的抽象方法怎么办！！）。</li>
</ul>
<p><strong>意义</strong></p>
<ul>
<li>抽象类的实际意义不在于创建对象，而在与被继承。</li>
<li>并且继承了抽象类的子类，必须重写抽象类的所有抽象方法，否者也定义成抽象类。<br>也就是说，抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>
</ul>
<p><strong>注意</strong>：</p>
<p>虽然只要是满足abstract关键字修饰的类是抽象类，但是真正意义上的抽象类还应该有抽象方法。</p>
<p><strong>案例</strong>：银行有 定期账户 和 活期账户 ，都继承自 账户类。</p>
<p>定义 账户类Account，该类定义成抽象类，获取利息的方法也定义成抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        setMoney(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取利息的抽象方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getLiXing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义定期账户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DingQiAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DingQiAccount</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLiXing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMoney() * <span class="number">0.03</span> * <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义活期账户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuoQiAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuoQiAccount</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getLiXing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMoney() * <span class="number">0.01</span> * <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.de.test_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多态场景之一</span></span><br><span class="line">        Account a = <span class="keyword">new</span> <span class="comment">/*DingQi*/</span>HuoQiAccount(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;利息是&quot;</span> + a.getLiXing() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>考点</strong></p>
<p>abstract关键字不能和private、static、final关键字一起使用。原因：</p>
<ul>
<li>abstract 和 private： private是私有的，子类访问不到，就更不用说重写了。而abstract就是需要重写，互相矛盾。</li>
<li>abstract 和 static：用static修饰的方法隶属于类层级，可以用“类名.方法”来调用，而此时抽象方法没有方法体，错误。</li>
<li>abstract 和 final：final修饰的方法表示不能被重写，而abstract就是需要重写，互相矛盾。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是一种比抽象类还抽象的类。体现接口中在只有常量和抽象方法。</p>
<p>定义时接口时，把class关键字改成interface。如<code>public interface 接口名&#123; 接口体 &#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口只有常量和抽象方法（型特性除外）,注释中的关键字可以省略。</span></span><br><span class="line">    <span class="comment">/*public static final*/</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//常量</span></span><br><span class="line">    <span class="comment">/*public abstract*/</span> <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;    <span class="comment">//抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8版本之后的新特性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;    <span class="comment">//非抽象方法，子类自由选择重写不重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;     <span class="comment">//静态方法，子类不能重写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//9版本的新特性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show4</span><span class="params">()</span></span>&#123;&#125;           <span class="comment">//私有方法，子类不能重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，接口只有常量和抽象方法。但是Java8版本之后的新特性可以有非抽象方法，静态方法；Java9版本的新特性可以有私有方法。</p>
<p><strong>意义</strong></p>
<p>接口出现可以弥补Java中类不能多继承的不足。</p>
<p>例如：黄金即属于金属，又属于货币。如果用类描述关系的话，很难描述。而接口可以。<br>定义金属接口，定义货币接口，再定义黄金类。黄金类继承金属接口又继承货币接口。<br><em>注意</em>：类继承接口，叫做类实现接口，不用extends关键字，而用implements关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//金属接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Metal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//货币接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Money</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//黄金类Gold，实现(继承)了金属接口Metal和货币接口Money。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gold</span> <span class="keyword">implements</span> <span class="title">Metal</span>, <span class="title">Money</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>      <span class="comment">//重写金属接口Metal的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;黄金闪闪发光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>      <span class="comment">//重写货币接口Money的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买买买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口和类的关系</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>关键字</th>
<th>关系</th>
</tr>
</thead>
<tbody><tr>
<td>类和类之间</td>
<td>用extends关键字表示继承</td>
<td>单继承</td>
</tr>
<tr>
<td>类和接口之间</td>
<td>用implements关键字表示实现</td>
<td>多实现</td>
</tr>
<tr>
<td>接口和接口之间</td>
<td>用extends关键字表示继承</td>
<td>多继承</td>
</tr>
</tbody></table>
<p><em>注意</em>：</p>
<ul>
<li>类可以实现(继承)接口，而接口不能继承类。</li>
<li>子接口a继承了父接口b，某个类实现子接口a的话，该类必须重写接口a和接口b的所有抽象方法，否则将该类变成抽象类。</li>
</ul>
<p>想要即继承父类又实现接口的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1, 接口2, 接口3 </span>&#123; 类体 &#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><em>概念</em><br>当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类（Inner），而这个内部类所在的类叫做外部类（Outer）。</p>
<p>类中的内容可以有：成员变量、成员方法、构造方法、静态方法、构造块、静态代码块、内部类。<br>由此可见内部类和其他成员是平级关系。</p>
<p><em>作用：</em><br>当一个类的存在价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为服务类中的内部类，这样可以隐藏该类的现实细节并且可以方便的访问外部类的私有成员。</p>
<p><em>内部类的分类</em></p>
<ul>
<li>普通（成员）内部类：直接将一个类定义在另一个类的类体中</li>
<li>静态内部类：使用static关键字修饰的内部类，隶属于类层级</li>
<li>局部内部类：直接将一个类定义在方法体的内部</li>
<li>匿名内部类：就是指没有名字的内部类（重要）</li>
</ul>
<h4 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h4><p>又叫成员内部类，直接将一个类定义在另一个类的类体中，写法和普通的类一样。<br>内部类可以直接访问外部类的成员。出现同名成员，可以用<code>外部类名.this.成员</code>访问外部类的成员。<br>测试中想要创建内部类，必须先创建外部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//定义普通内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Innter</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;形参a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;普通内部类的成员变量a = &quot;</span> + <span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类的成员变量a = &quot;</span> + Outer1.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer1 o = <span class="keyword">new</span> Outer1();</span><br><span class="line">        Outer1.Innter i = o.<span class="function">new <span class="title">Innter</span><span class="params">()</span></span>;</span><br><span class="line">        i.show(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>使用static关键字修饰的内部类，隶属于类层级<br>由于静态内部类隶属于类层级，可以用类名.的方式直接调用。<br>并且静态内部类里面不可以访问外部类的非静态成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//该静态内部类里面不能访问外部类的非静态成员。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnter</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;形参a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类的成员变量b = &quot;</span> + <span class="keyword">this</span>.b);</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类的静态变量a = &quot;</span> + StaticInnter.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类的静态变量a = &quot;</span> + Outer2.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer2.StaticInnter si = <span class="keyword">new</span> Outer2.StaticInnter();</span><br><span class="line">        si.show(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>直接将一个类定义在方法体的内部。<br>只能在该方法体中使用。<br>和局部变量一样，定义局部内部类时不用加public等关键字修饰。<br>局部内部类中访问外部方法体的变量时，应该把该变量当作常量一样使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ia = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ib = <span class="number">2</span>;   <span class="comment">//对于局部内部类来说，该外部方法体的变量ib相当于常量。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在方法体中定义局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AreaInner</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> ic = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ia = &quot;</span> + ia);</span><br><span class="line">                System.out.println(<span class="string">&quot;ib = &quot;</span> + ib);<span class="comment">//外部方法体的变量ib相当于常量。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ic = &quot;</span> + ic);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只能在所在的方法体中调用。</span></span><br><span class="line">        AreaInner ai = <span class="keyword">new</span> AreaInner();</span><br><span class="line">        ai.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer3 o = <span class="keyword">new</span> Outer3();</span><br><span class="line">        o.show1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><strong>回调模式的概念</strong></p>
<p>回调模式：指如果一个方法的形参是接口类型，则调用该方法时，实参就要是该接口类型的实现类创建的对象。而该方法在运行时会调用到参数对象中所重写的方法。</p>
<p>例如：定义一个接口MyInterface。接口中有抽象方法show();<br>定义一个方法如下，符合回调模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参是接口类型引用。注意：而接口有不能创建对象，只能利用多态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">huiDiao</span><span class="params">(MyInterface i)</span></span>&#123;</span><br><span class="line">    i.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法，实参是接口的某个实现类(子类)创建的对象。所以我们又需要为接口MyInterface定义一个实现类(子类)Sub。实现类Sub要重写接口的抽象方法。<br>然后可以如下调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,实参是接口的某个实现类(子类)创建的对象</span></span><br><span class="line">huiDiao( <span class="keyword">new</span> Sub() );</span><br></pre></td></tr></table></figure>

<p>假如该方法只要调用一次就没有用了，所以实现类Sub只会用到一次就没用了。相当于是临时定义出来的类，为了方便，我们可以使用匿名内部类。</p>
<p><strong>匿名内部类</strong></p>
<p>接口/父类 引用名 = new 接口/父类（）{ 匿名内部类的方法体(注意要重写方法) };</p>
<p>根据上面的代码，调用huiDiao()方法传实参时，我们可以不用定义临时的实现类Sub了。<br>采用匿名内部类，为接口MyInterface 临时创建一个没有名字实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2,实参是利用匿名内部类创建的对象</span></span><br><span class="line">MyInterface i = <span class="keyword">new</span> MyInterface()&#123; <span class="comment">//类体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;临时创建出来的匿名内部类重写接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;   <span class="comment">//注意最后的分号;</span></span><br><span class="line">huiDiao(i);</span><br></pre></td></tr></table></figure>

<p>从java8开始提出型特性lamda表达式可以简化上述代码，<br>格式为：(参数列表) -&gt; {方法体}，后面会讲。</p>
<p><strong>开发经验</strong></p>
<p>当  接口/父类  类型的引用作为方法的形参时，实参的传递方式有两种：</p>
<ul>
<li>自定义类来  实现接口/继承父类，并重写方法。然后创建该类的对象作为实参传递。</li>
<li>使用上述匿名内部类的语法格式，得到  接口/类  类型的引用即可。</li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>定义季节类，对象只有：春夏秋冬<br>定义性别类，对象只有：男女</p>
<p>例如：定义一个枚举类，枚举类只能创建指定的几个对象。</p>
<h4 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h4><p>编程实现方向枚举类，该类只能创建对象：向上，向下，向左，向右。（定义方法跟之前的单例设计模型类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String direc;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *2，声明本类类型的引用指向本类类型的对象，配合public static final关键字</span></span><br><span class="line"><span class="comment">     *   使得外部只能得到这4个引用（类名.引用名），而且不能修改。外部不能创建别的对象了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction UP = <span class="keyword">new</span> Direction(<span class="string">&quot;向上&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction DOWN = <span class="keyword">new</span> Direction(<span class="string">&quot;向下&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction LEFT = <span class="keyword">new</span> Direction(<span class="string">&quot;向左&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Direction RIGHT = <span class="keyword">new</span> Direction(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line">    <span class="comment">//1,私有化构造方法，使得外部不能通过new的方法创建对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction</span><span class="params">(String derec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direc = derec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方向是&quot;</span> + <span class="keyword">this</span>.direc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部只能得到这4个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Direction d1 = Direction.UP;</span><br><span class="line">Direction d2 = Direction.DOWN;</span><br><span class="line">Direction d3 = Direction.LEFT;</span><br><span class="line">Direction d4 = Direction.RIGHT;</span><br></pre></td></tr></table></figure>

<h4 id="用enum定义枚举类"><a href="#用enum定义枚举类" class="headerlink" title="用enum定义枚举类"></a>用enum定义枚举类</h4><p>使用上述public static final配合表示有点繁琐，Java5以后有了新的引用数据类型：<em>枚举类型</em>，用enum关键字。<br>定义枚举类时，将class替换成enum表示枚举类类型。</p>
<p>Java5后建议如下这样定义枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction2</span></span>&#123;</span><br><span class="line">    <span class="comment">//public static final Direction UP = new Direction(&quot;向上&quot;);</span></span><br><span class="line">    <span class="comment">//在枚举类中简写成： UP(&quot;向上&quot;);   且放在第一行。</span></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>), DOWN(<span class="string">&quot;向下&quot;</span>), LEFT(<span class="string">&quot;向左&quot;</span>), RIGHT(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String deric;</span><br><span class="line">    <span class="comment">//1,私有化构造方法，使得外部不能通过new的方法创建对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction2</span><span class="params">(String deric)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deric = deric;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.deric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Direction2 d1 = Direction2.UP;</span><br><span class="line">Direction2 d2 = Direction2.DOWN;</span><br><span class="line">Direction2 d3 = Direction2.LEFT;</span><br><span class="line">Direction2 d4 = Direction2.RIGHT;</span><br></pre></td></tr></table></figure>

<p>在switch结构中支持采用enum关键字定义的枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Direction2 d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(d)&#123;</span><br><span class="line">            <span class="keyword">case</span> UP: System.out.println(<span class="string">&quot;贪吃蛇向上走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN: System.out.println(<span class="string">&quot;贪吃蛇向下走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT: System.out.println(<span class="string">&quot;贪吃蛇向左走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT: System.out.println(<span class="string">&quot;贪吃蛇向右走&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Test2.test2(Direction2.UP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enum类的方法"><a href="#Enum类的方法" class="headerlink" title="Enum类的方法"></a>Enum类的方法</h4><p>用enum关键字定义的枚举类天生继承自java.lang.Enum类，所以也继承父类的方法。<br><em>注意</em>：由于继承Enum父类。枚举类不能再继承其他类了，但是可以实现接口。</p>
<p>继承的常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>static T[] values()</td>
<td>返回当前枚举类中所有对象</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回当前枚举类对象名称</td>
</tr>
<tr>
<td>int ordinal()</td>
<td>获取枚举类对象在枚举中的索引位置</td>
</tr>
<tr>
<td>static T valueOf(String str)</td>
<td>将参数指定的字符串转换为当前枚举类的对象</td>
</tr>
<tr>
<td>ing compareTo(E o)</td>
<td>比较当前枚举类对象和参数枚举类对象的顺序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Direction2[] arr = Direction2.values();   <span class="comment">//values()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前对象的名称是：&quot;</span> + arr[i].toString());   <span class="comment">//toString()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前对象的索引值是：&quot;</span> + arr[i].ordinal());  <span class="comment">//ordinal()</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意细节，print打印“引用”或者是“引用.toString()”的结果是一样的。</span></span><br><span class="line">    Direction2 d = Direction2.valueOf(<span class="string">&quot;LEFT&quot;</span>);     <span class="comment">//valueOf()</span></span><br><span class="line">    System.out.println(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//compareTo()是将当前对象索引值减去参数对象索引值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ia = d.compareTo(arr[i]);                      <span class="comment">//compareTo()</span></span><br><span class="line">        System.out.println(d.toString() + <span class="string">&quot;和&quot;</span> + arr[i].toString() + <span class="string">&quot;比的结果是&quot;</span> + ia);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举类重写接口方法"><a href="#枚举类重写接口方法" class="headerlink" title="枚举类重写接口方法"></a>枚举类重写接口方法</h4><p>上面说过，由于继承Enum父类。枚举类不能再继承其他类了，但是可以实现接口。</p>
<p>枚举类实现了某个接口，就需要重写接口的方法。重写方法有两种方式：</p>
<ul>
<li>所有枚举类对象共享同一个重写方法。</li>
<li>每个枚举类对象各自重写方法，利用匿名内部类的方式。</li>
</ul>
<p>假设定义一个接口MyInterface，有抽象方法show()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction3</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>), DOWN(<span class="string">&quot;向下&quot;</span>), LEFT(<span class="string">&quot;向左&quot;</span>), RIGHT(<span class="string">&quot;向右&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String direc;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction3</span><span class="params">(String direc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direc = direc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1,所有枚举类对象共享同一个重写方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction3</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2,每个枚举类对象各自重写方法，利用匿名内部类的方式。</span></span><br><span class="line">    <span class="comment">//匿名内部类：接口/父类 引用名 = new 接口/父类()&#123;类体&#125;;</span></span><br><span class="line">    <span class="comment">//public static finla Directioin3 UP = new Direction3(&quot;向上&quot;) &#123;类体中重写方法&#125;;</span></span><br><span class="line">    <span class="comment">//简化为：UP(&quot;向上&quot;)&#123;类体中重写方法&#125;, DOWN(&quot;向下&quot;)&#123;类体中重写方法&#125;, ......</span></span><br><span class="line">    UP(<span class="string">&quot;向上&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, DOWN(<span class="string">&quot;向下&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, LEFT(<span class="string">&quot;向左&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, RIGHT(<span class="string">&quot;向右&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String direc;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Direction3</span><span class="params">(String direc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.direc = direc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解(Annotation)又叫标注。是Java5开始增加的一种引用数据类型。是一种特殊的接口。</p>
<p>本质上就是给代码贴标签，特殊标记。通过这些标记可以在编译、类加载、以及运行时执行指定的处理。</p>
<h4 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h4><p><strong>定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">	注解成员;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解成员只有成员变量。注解的成员变量声明语法：<br><code>public 数据类型 变量名();</code>     或者<br><code>public 数据类型 变量名() default 默认值;</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//只能有成员变量。public 数据类型 变量名() /*default 默认值*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value2</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个注解没有任何成员，叫做标记注解/标识注解。</p>
<p><strong>使用</strong></p>
<p>在需要注解的代码上写上：@ 注解名(传参)</p>
<p>例如：注解标注Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=1, value2=2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>注解是标注在代码上面。<br>但是有些注解可以标注在注解上———叫做元注解。</p>
<p>元注解主要有：@retention、@Documented、@Target、@Inherited、@Repeatable</p>
<p><strong>@retention</strong></p>
<p>@retention应用(贴)在一个注解上，用于说明该注解的生命周期，取值如下：</p>
<ul>
<li><p>RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时</p>
<p>它将被丢弃忽视。java文件前有效</p>
</li>
<li><p>RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加</p>
<p>载到 JVM 中，默认方式。class文件前有效</p>
</li>
<li><p>RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载</p>
<p>进入到 JVM 中，所以在程序运行时可以获取到它们。</p>
</li>
</ul>
<p>java文件——–(javac.exe编译器编译阶段)——-&gt;class文件——(java.exe解释器解释运行阶段)———-&gt;结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定所修饰的注解MyAnnotation的生命周期在class文件前有效(默认)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;  <span class="comment">//自定义注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Documented</strong></p>
<p>使用Javadoc工具可以从程序源代码中抽取类、方法、成员等形成一个和源代码配套的API帮助文档。默认不包括注解内容。</p>
<p>例如写了如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=1, value2=2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//文档注释</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * age是描述年龄的成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * name是描述姓名的成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i:随便传的形参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:返回参数int i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用过IDEA演示，点击“Tools”—&gt;“Generate JavaDoc”，打开对话框，填写好相关信息后点击ok。然后会自动生成跟我们写的代码配套的API帮助文档。<br>文档注释/**    */会变成代码的功能说明。</p>
<p>生成的API帮助文档，里面默认不包括注解内容。<br>想要在API帮助文档包括注解内容的话，需要在定义注解时，贴上元注解@Documented。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所修饰的注解MyAnnotation可以被添加到API帮助文档中</span></span><br><span class="line"><span class="meta">@Documented</span>                     </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Target</strong></p>
<p>@Target用于指定被修饰的注解只能贴在哪些元素上。</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ElementType.ANNOTATION_TYPE</td>
<td>可以给一个注解进行注解</td>
</tr>
<tr>
<td>ElementType.CONSTRUCTOR</td>
<td>可以给构造方法进行注解</td>
</tr>
<tr>
<td>ElementType.FIELD</td>
<td>可以给属性进行注解</td>
</tr>
<tr>
<td>ElementType.LOCAL_VARIABLE</td>
<td>可以给局部变量进行注解</td>
</tr>
<tr>
<td>ElementType.METHOD</td>
<td>可以给方法进行注解</td>
</tr>
<tr>
<td>ElementType.PACKAGE</td>
<td>可以给一个包进行注解</td>
</tr>
<tr>
<td>ElementType.PARAMETER</td>
<td>可以给一个方法内的参数进行注解</td>
</tr>
<tr>
<td>ElementType.TYPE</td>
<td>可以给类型进行注解，比如类、接口、枚举</td>
</tr>
</tbody></table>
<p>从Java8开始对元注解@Target的参数类型ElementType枚举值增加了两个：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ElementType.TYPE_PARAMETER</td>
<td>该注解能写在类型变量的声明语句中，如：泛型。</td>
</tr>
<tr>
<td>中ElementType.TYPE_USE</td>
<td>该注解能写在使用类型的任何语句中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所修饰的注解MyAnnotation只可以贴在属性或类型上。</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Inherited</strong></p>
<p>默认子类继承父类时，不会把父类的注解也继承。</p>
<p>@Inherited所应用的注解可以被继承。</p>
<p>并不是说注解本身可以继承，而是说如果一个父类被该元注解(@Inherited)标记过的注解进行标记时，如果子类没有被任何注解应用时，则子类就继承父类的注解。</p>
<p><strong>@Repeatable</strong></p>
<p>表示自然可重复的含义</p>
<p>正常定义的注解不能对同一代码反复标注。</p>
<p>如果某一注解想要对同一代码反复标注，Java8以前的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManType &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManTypes &#123;</span><br><span class="line">    <span class="keyword">public</span> ManType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8以前是这样处理多个注解</span></span><br><span class="line"><span class="meta">@ManTypes(value=&#123;@ManType(value=&quot;超人&quot;), @ManType(value=&quot;父亲&quot;)&#125;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java8以后借助元注解@Repeatable可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(value=ManTypes.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManType &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManTypes &#123;</span><br><span class="line">    <span class="keyword">public</span> ManType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8以后借助元注解@Repeatable可以这样写</span></span><br><span class="line"><span class="meta">@ManType(value=&quot;超人&quot;)</span>    </span><br><span class="line"><span class="meta">@ManType(value=&quot;父亲&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是无论哪种写法，ManType注解想要反复使用的话，都需要定义ManTypes注解，里面的成员是ManType注解类型的数组。</p>
<h4 id="常见的预制注解"><a href="#常见的预制注解" class="headerlink" title="常见的预制注解"></a>常见的预制注解</h4><p>预制注解就是Java语言自身提供的注解，具体如下：</p>
<table>
<thead>
<tr>
<th>预制注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>标明开发该类模块的作者，多个作者之间使用,分割</td>
</tr>
<tr>
<td>@version</td>
<td>标明该类模块的版本</td>
</tr>
<tr>
<td>@see</td>
<td>参考转向，也就是相关主题</td>
</tr>
<tr>
<td>@since</td>
<td>从哪个版本开始增加的</td>
</tr>
<tr>
<td>@param</td>
<td>对方法中某参数的说明，如果没有参数就不能写</td>
</tr>
<tr>
<td>@return</td>
<td>对方法返回值的说明，如果方法的返回值类型是void就不能写</td>
</tr>
<tr>
<td>@exception</td>
<td>对方法可能抛出的异常进行说明</td>
</tr>
<tr>
<td>@Override</td>
<td>限定重写父类方法, 该注解只能用于方法</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>用于表示所修饰的元素(类, 方法等)已过时</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>抑制编译器警告</td>
</tr>
</tbody></table>
<h1 id="Java核心类库-上"><a href="#Java核心类库-上" class="headerlink" title="Java核心类库(上)"></a>Java核心类库(上)</h1><h2 id="常用类的概述和使用"><a href="#常用类的概述和使用" class="headerlink" title="常用类的概述和使用"></a>常用类的概述和使用</h2><p>这里开始学习官方提供的类和接口，需要借助API工具。</p>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ul>
<li><p>java.lang包 - 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。<br>如：System类、String类、… </p>
</li>
<li><p>java.util包 - 该包是Java语言的工具包，里面提供了大量工具类以及集合类等。<br>如：Scanner类、Random类、List集合、…</p>
</li>
<li><p>java.io包 - 该包是Java语言中的输入输出包，里面提供了大量读写文件相关的类等。<br>如：FileInputStream类、FileOutputStream类、…</p>
</li>
<li><p>java.net包 - 该包是Java语言中的网络包，里面提供了大量网络编程相关的类等。<br>如：ServerSocket类、Socket类、…</p>
</li>
<li><p>java.sql 包 - 该包是Java语言中的数据包，里面提供了大量操作数据库的类和接口等。<br>如：DriverManager类、Connection接口、…</p>
</li>
<li><p>… …</p>
</li>
</ul>
<p>Java程序员在编程时可以使用大量类库，因此Java编程时需要记的很多，对编程能力本身要求不是</p>
<p>特别的高。</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ul>
<li><p>java.lang.Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间<br>接子类。</p>
</li>
<li><p>如果定义一个Java类时没有使用extends关键字声明其父类，则其父类默认为 java.lang.Object 类。</p>
</li>
<li><p>Object类定义了“对象”的基本行为, 被子类默认继承。</p>
</li>
</ul>
<p><strong>Object类的常用方法如下：</strong>（被所有子类继承）</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>boolean equals(Object obj)：</p>
<p>用于判断调用对象是否与参数对象相等。默认是判断地址是否相等，和==运算符一样。<br>若希望比较两个对象的内容，则需要重写该方法。<br>若该方法被重写后，则应该重写hashCode方法来保证结果的一致性。</p>
<p><em>例如</em>，定义了student类，假如两个对象的id一样，则equals()就为true。重写如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数obj为空，或者参数和当前对象this不是同一类，直接返回false。</span></span><br><span class="line">    <span class="keyword">if</span>( obj == <span class="keyword">null</span> || obj.getClass()!= <span class="keyword">this</span>.getClass() ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//参数obj和当前对象this地址相同直接返回true。</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果id相同，直接返回true。</span></span><br><span class="line">    ObjectTest that = (ObjectTest)obj;</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>.getId() == that.getId() )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id不同返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是String name这种引用数据类型的话，条件如下(因为String类中重写了equals方法)</span></span><br><span class="line"><span class="comment">//if( this.getName().equals(that.getName()) )</span></span><br></pre></td></tr></table></figure>

<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p>int hashCode()：</p>
<p>用于获取调用对象的哈希码值(内存地址的编号)。<br>若两个对象调用equals方法相等，则各自调用该方法的结果必须相同。<br>若两个调用对象equals方法不相等，则各自调用该方法的结果应该不相同。<br>为了使得该方法与equals方法保持一致，重写了equals方法，就需要重写该方法。</p>
<p><em>例如</em>，上面重写了equals()方法，是基于对象的id比较是否相等，那么hashCode()方法也要重写来与id有关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">31</span> * <span class="number">12</span> + <span class="keyword">this</span>.getId();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是String name这种引用数据类型的话，返回值如下(因为String类中重写了hashCode方法)</span></span><br><span class="line"><span class="comment">//return 31 * 12 + this.getName().hashCode();</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>String toString()：</p>
<p>该方法默认返回的字符串为：包名.类名@哈希码值的十六进制。<br>为了返回更有意义的数据，需要重写该方法。<br>使用print或println打印引用或字符串拼接引用都会自动调用该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;id=&quot;</span> + <span class="keyword">this</span>.id + <span class="string">&quot;,name=&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h4><p>Class&lt;?&gt; getClass() ：</p>
<p>用于返回调用对象执行时的Class实例，反射机制使用</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>通常情况下基本数据类型的变量不是对象，为了满足万物皆对象的理念就需要对基本数据类型的变量进行打包封装处理变成对象，而负责将这些变量声明为成员变量进行对象化处理的相关类，叫做包装类。</p>
<table>
<thead>
<tr>
<th><strong>包装类</strong></th>
<th><strong>对应的基本类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Byte</td>
<td>byte</td>
</tr>
<tr>
<td>java.lang.Short</td>
<td>short</td>
</tr>
<tr>
<td>java.lang.Integer</td>
<td>int</td>
</tr>
<tr>
<td>java.lang.Long</td>
<td>long</td>
</tr>
<tr>
<td>java.lang.Float</td>
<td>float</td>
</tr>
<tr>
<td>java.lang.Double</td>
<td>double</td>
</tr>
<tr>
<td>java.lang.Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>java.lang.Character</td>
<td>char</td>
</tr>
</tbody></table>
<p>其中Byte、Short、Integer、Long、Float、Double包装类都继承自java.lang.Number抽象类。</p>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p>java.lang.Integer类内部包装了一个int类型的变量作为成员变量，主要用于实现对int类型的包装并<br>提供int类型到String类之间的转换等方法。</p>
<p><strong>常用常量</strong></p>
<table>
<thead>
<tr>
<th><strong>常量类型和名称</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public static final int MAX_VALUE</td>
<td>表示int类型可以描述的最大值，即2^31-1</td>
</tr>
<tr>
<td>public static final int MIN_VALUE</td>
<td>表示int类型可以描述的最小值，即-2^31</td>
</tr>
<tr>
<td>public static final int SIZE</td>
<td>表示int类型采用二进制补码形式的位数</td>
</tr>
<tr>
<td>public static final int BYTES</td>
<td>表示int类型所占的字节个数</td>
</tr>
<tr>
<td>public static final Class TYPE</td>
<td>表示int类型的Class实例</td>
</tr>
</tbody></table>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Integer(int value)</td>
<td>根据参数指定的整数来构造对象（已过时）</td>
</tr>
<tr>
<td>Integer(String s)</td>
<td>根据参数指定的字符串来构造对象 （已过时）</td>
</tr>
<tr>
<td>static Integer valueOf(int i)</td>
<td>根据参数指定整数值得到Integer类型对象</td>
</tr>
<tr>
<td>int intValue()</td>
<td>获取调用对象中的整数值并返回</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回描述调用对象数值的字符串形式</td>
</tr>
<tr>
<td>static int parseInt(String s)</td>
<td>将字符串类型转换为int类型并返回</td>
</tr>
<tr>
<td>static String toString(int i)</td>
<td>获取参数指定整数的十进制字符串形式</td>
</tr>
<tr>
<td>static String toBinaryString(int i)</td>
<td>获取参数指定整数的二进制字符串形式</td>
</tr>
<tr>
<td>static String toHexString(int i)</td>
<td>获取参数指定整数的十六进制字符串形式</td>
</tr>
<tr>
<td>static String toOctalString(int i)</td>
<td>获取参数指定整数</td>
</tr>
</tbody></table>
<p><strong>装箱和拆箱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用构造方法创建对象，已过时（不建议使用）</span></span><br><span class="line">Integer it1 = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Integer对象，相当于将int类型转换Integer类型，装箱</span></span><br><span class="line">Integer it2 = Integer.valueOf(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于将Integer类型转换int类型，拆箱</span></span><br><span class="line"><span class="keyword">int</span> ia = it2.intValue();</span><br></pre></td></tr></table></figure>

<p><strong>自动装箱和拆箱</strong>(java5之后的新特性)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java5后，自动装箱拆箱</span></span><br><span class="line">Integer it1 = <span class="number">9</span>;  </span><br><span class="line"><span class="keyword">int</span> ia = it1;</span><br></pre></td></tr></table></figure>

<p><strong>自动装箱池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer it1 = <span class="number">128</span>;</span><br><span class="line">Integer it2 = <span class="number">128</span>;</span><br><span class="line">System.out.println(it5 == it6);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>如上，明显it1和it2的地址不相同，所以结果是false，但是如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer it3 = <span class="number">127</span>;</span><br><span class="line">Integer it4 = <span class="number">127</span>;</span><br><span class="line">System.out.println(it3 == it4);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>结果却是true。因为：</p>
<p>在Integer类的内部提供了自动装箱池技术，将-128到127之间的整数已经装箱完毕，当程序中使用<br>该范围之间的整数时，无需装箱直接取用自动装箱池中的对象即可，从而提高效率。</p>
<p><strong>其他方法演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;返回十进制&quot;</span> + Integer.toString(<span class="number">200</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;返回二进制&quot;</span> + Integer.toBinaryString(<span class="number">200</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;返回八进制&quot;</span> + Integer.toOctalString(<span class="number">200</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;返回十六进制&quot;</span>+Integer.toHexString(<span class="number">200</span>));</span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line">System.out.println(<span class="string">&quot;Integer类型表示的最大值&quot;</span> + Integer.MAX_VALUE);  <span class="comment">//2147483647</span></span><br></pre></td></tr></table></figure>

<h4 id="Bouble"><a href="#Bouble" class="headerlink" title="Bouble"></a>Bouble</h4><p>用法和Interger差不多，例如，装箱拆箱和自动装箱拆箱等…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean isNaN()：判断调用对象的数值是否为非数字</span></span><br><span class="line">Double D1 = Double.valueOf(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">System.out.println( D1.isNaN() );   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Double D2 = Double.valueOf(<span class="number">0</span>/<span class="number">0.0</span>);</span><br><span class="line">System.out.println( D2.isNaN() );   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>用法和Interger差不多，例如，装箱拆箱和自动装箱拆箱等…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换Boolean类型，只有字符串是true(不区分大小写)时，结果才是true，其他都为false。</span></span><br><span class="line">Boolean B = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">System.out.println(B.toString());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h4><p>用法和Interger差不多，例如，装箱拆箱和自动装箱拆箱等…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;是否大写：&quot;</span> + Character.isUpperCase(<span class="string">&#x27;A&#x27;</span>));    <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否小写：&quot;</span> + Character.isLowerCase(<span class="string">&#x27;A&#x27;</span>));    <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否数字：&quot;</span> + Character.isDigit(<span class="string">&#x27;2&#x27;</span>));        <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;转换成大写：&quot;</span> + Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));  <span class="comment">//A</span></span><br><span class="line">System.out.println(<span class="string">&quot;转换成小写：&quot;</span> + Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));  <span class="comment">//a</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>基本数据类型转换为对应包装类的方式</li>
</ul>
<p>调用包装类的构造方法或静态方法即可</p>
<ul>
<li>获取包装类对象中基本数据类型变量数值的方式</li>
</ul>
<p>调用包装类中的xxxValue方法即可</p>
<ul>
<li>字符串转换为基本数据类型的方式</li>
</ul>
<p>调用包装类中的parseXxx方法即可</p>
<h3 id="数学处理类"><a href="#数学处理类" class="headerlink" title="数学处理类"></a>数学处理类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>java.lang.Math类主要用于提供执行数学运算的方法，如：对数，平方根。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static int max(int a, int b)</td>
<td>返回两个参数中的最大值</td>
</tr>
<tr>
<td>static int min(int a, int b)</td>
<td>返回两个参数中的最小值</td>
</tr>
<tr>
<td>static double pow(double a, double b)</td>
<td>返回第一个参数的幂</td>
</tr>
<tr>
<td>static int abs(int a)</td>
<td>返回参数指定数值的绝对值</td>
</tr>
<tr>
<td>static long round(double a)</td>
<td>返回参数四舍五入的结果</td>
</tr>
<tr>
<td>static double sqrt(double a)</td>
<td>返回参数的平方根</td>
</tr>
<tr>
<td>static double random()</td>
<td>返回0.0到1.0的随机数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;最大数：&quot;</span> + Math.max(<span class="number">5</span>,<span class="number">8</span>));    <span class="comment">//8</span></span><br><span class="line">System.out.println(<span class="string">&quot;最小数&quot;</span> + Math.min(<span class="number">5</span>,<span class="number">8</span>));      <span class="comment">//5</span></span><br><span class="line">System.out.println(<span class="string">&quot;求幂&quot;</span> + Math.pow(<span class="number">2</span>,<span class="number">3</span>));        <span class="comment">//8.0</span></span><br><span class="line">System.out.println(<span class="string">&quot;绝对值&quot;</span> + Math.abs(-<span class="number">1</span>));       <span class="comment">//1</span></span><br><span class="line">System.out.println(<span class="string">&quot;四舍五路:&quot;</span> + Math.round(<span class="number">2</span>/<span class="number">0.3</span>));<span class="comment">//7</span></span><br><span class="line">System.out.println(<span class="string">&quot;平方跟:&quot;</span> + Math.sqrt(<span class="number">25</span>));      <span class="comment">//5.0</span></span><br><span class="line">System.out.println(<span class="string">&quot;0到1.0的随机数:&quot;</span> + Math.random());<span class="comment">//随机数</span></span><br></pre></td></tr></table></figure>

<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>由于flfloat类型和double类型在运算时可能会有误差，若希望实现精确运算则借助<br>java.math.BigDecimal类型加以描述。</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BigDecimal(String val)</td>
<td>根据参数指定的字符串来构造对象</td>
</tr>
<tr>
<td>BigDecimal add(BigDecimal augend)</td>
<td>用于实现加法运算</td>
</tr>
<tr>
<td>BigDecimal subtract(BigDecimal subtrahend)</td>
<td>用于实现减法运算</td>
</tr>
<tr>
<td>BigDecimal multiply(BigDecimal multiplicand)</td>
<td>用于实现乘法运算</td>
</tr>
<tr>
<td>BigDecimal divide(BigDecimal divisor)</td>
<td>用于实现除法运算</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;5.2&quot;</span>);</span><br><span class="line">BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.3&quot;</span>);</span><br><span class="line"><span class="comment">//正常浮点类型运算会由失误，虽然误差很小。</span></span><br><span class="line">System.out.println(<span class="number">5.2</span>*<span class="number">1.3</span>);    <span class="comment">//6.760000000000001</span></span><br><span class="line">System.out.println(<span class="string">&quot;加法运算：&quot;</span> + bd1.add(bd2));       <span class="comment">//6,5</span></span><br><span class="line">System.out.println(<span class="string">&quot;减法运算：&quot;</span> + bd1.subtract(bd2));  <span class="comment">//3.9</span></span><br><span class="line">System.out.println(<span class="string">&quot;乘法运算：&quot;</span> + bd1.multiply(bd2));  <span class="comment">//6.76</span></span><br><span class="line">System.out.println(<span class="string">&quot;除法运算：&quot;</span> + bd1.divide(bd2));    <span class="comment">//4.0</span></span><br></pre></td></tr></table></figure>

<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>若希望表示比long类型范围还大的整数数据，则需要借助java.math.BigInteger类型描述。</p>
<p>常用方法：</p>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BigInteger(String val)</td>
<td>根据参数指定的字符串来构造对象</td>
</tr>
<tr>
<td>“加减乘除”与上述BigDecimal一样</td>
<td></td>
</tr>
<tr>
<td>BigInteger remainder(BigInteger val)</td>
<td>用于实现取余运算</td>
</tr>
<tr>
<td>BigInteger[] divideAndRemainder(BigInteger val)</td>
<td>用于实现取商和余数的运算</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">BigInteger bi2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取商和取余数一起</span></span><br><span class="line">BigInteger[] arr = bi1.divideAndRemainder(bi2);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;下标为&quot;</span> + i + <span class="string">&quot;的元素值是：&quot;</span> + arr[i]);    <span class="comment">//0--2， 1--4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul>
<li><p>java.lang.String类用于描述字符串，Java程序中所有的字符串字面值都可以使用该类的对象加以描述，如：”abc”。</p>
</li>
<li><p>该类由fifinal关键字修饰，表示该类不能被继承。</p>
</li>
<li><p>从jdk1.9开始该类的底层不使用char[]来存储数据，而是改成 byte[]加上编码标记，从而节约了一些空间。</p>
</li>
<li><p>该类描述的字符串内容是个常量不可更改，因此可以被共享使用。</p>
<p>如：</p>
<p> String str = “abc”; -表示str指向”abc”，其中”abc”这个字符串是个常量不可改变。 </p>
<p> str = “123”; - 将“123”字符串的地址赋值给变量str。</p>
<p> - 改变str的指向并没有改变指向的内容</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>由于String类型描述的字符串内容是常量不可改变，因此Java虚拟机将首次出现的字符串放入常量</p>
<p>池中，若后续代码中出现了相同字符串内容则直接使用池中已有的字符串对象而无需申请内存及创建对</p>
<p>象，从而提高了性能。</p>
<p>例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h3><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String()</td>
<td>使用无参方式构造对象得到空字符序列</td>
</tr>
<tr>
<td>String(byte[] bytes, int offffset, int length)</td>
<td>使用bytes数组中下标从offffset位置开始的length个字节来构造对象</td>
</tr>
<tr>
<td>String(byte[] bytes)</td>
<td>使用bytes数组中的所有内容构造对象</td>
</tr>
<tr>
<td>String(char[] value, int offffset, int count)</td>
<td>使用value数组中下标从offffset位置开始的count个字符来构造对象</td>
</tr>
<tr>
<td>String(char[] value)</td>
<td>使用value数组中的所有内容构造对象</td>
</tr>
<tr>
<td>String(String original)</td>
<td>根据参数指定的字符串内容来构造对象，新创建对象为参数对象的副本</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bArr = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(bBrr);</span><br><span class="line">System.out.println(str);  <span class="comment">//abcd   由ASCII码转换而成。</span></span><br></pre></td></tr></table></figure>

<p><strong>考点</strong>：</p>
<ul>
<li>String str = “abc”  和 String str = new String(“abc”)的区别：<br>String str = “abc”：常量“abc”被创建在常量池中，str指向“abc”。<br>String str = new String(“abc”)：常量“abc”被创建在常量池中，new String()被创建在堆区，str指向堆区的new String()。</li>
<li>判断如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;adcd&quot;</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;adcd&quot;</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;adcd&quot;</span>);</span><br><span class="line"><span class="comment">//判断内容</span></span><br><span class="line">System.out.println(str1.equals(str2));   <span class="comment">//true</span></span><br><span class="line">System.out.println(str3.equals(str4));   <span class="comment">//true</span></span><br><span class="line"><span class="comment">//判断地址</span></span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true，都指向常量池中的常量“abcd”。</span></span><br><span class="line">System.out.println(str3 == str4);   <span class="comment">//false，指向堆区中不同的String类型对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;   <span class="comment">//常量优化机制</span></span><br><span class="line">System.out.println(str1 == str2);   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String str4 = str3 + <span class="string">&quot;cd&quot;</span>;  <span class="comment">//没有常量优化机制</span></span><br><span class="line">System.out.println(str1 == str4);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回字符串本身</td>
</tr>
<tr>
<td>byte[] getBytes()</td>
<td>将当前字符串内容转换为byte数组并返回</td>
</tr>
<tr>
<td>char[] toCharArray()</td>
<td>用于将当前字符串内容转换为char数组并返回</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>char charAt(int index)</td>
<td>方法charAt用于返回字符串指定位置的字符。</td>
</tr>
<tr>
<td>int length()</td>
<td>返回字符串字符序列的长度</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断字符串是否为空</td>
</tr>
</tbody></table>
<p>案例题目:</p>
<p>判断字符串“上海自来水来自海上”是否为回文并打印，所谓回文是指一个字符序列无论从左向右读</p>
<p>还是从右向左读都是相同的句子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">&quot;上海自来水来自海上&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str2.length()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>( str2.charAt(i) != str2.charAt(str2.length()-<span class="number">1</span>-i) )&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不是回文！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;是回文！&quot;</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>int compareTo(String anotherString)</td>
<td>用于比较调用对象和参数对象的大小关系</td>
</tr>
<tr>
<td>int compareToIgnoreCase(String str)</td>
<td>不考虑大小写，也就是’a’和’A’是相等的关系</td>
</tr>
</tbody></table>
<p>从头比，相同的继续比较下一个，不同就用字符串对应的ASCII码值相减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println( str.compareTo(<span class="string">&quot;hello&quot;</span>) );          <span class="comment">//相同返回 0</span></span><br><span class="line">System.out.println( str.compareTo(<span class="string">&quot;hgllo&quot;</span>) );          <span class="comment">//e-g 返回 -2</span></span><br><span class="line">System.out.println( str.compareTo(<span class="string">&quot;hello1234&quot;</span>) );      <span class="comment">//长度返回 -4</span></span><br><span class="line">System.out.println( str.compareToIgnoreCase(<span class="string">&quot;HELLO&quot;</span>) );<span class="comment">//不区分大小写 0</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>String concat(String str)</td>
<td>用于实现字符串的拼接</td>
</tr>
<tr>
<td>boolean contains(CharSequence s)</td>
<td>用于判断当前字符串是否包含参数指定的内容</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>返回字符串的小写形式</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>返回字符串的大写形式</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回去掉前导和后继空白的字符串</td>
</tr>
<tr>
<td>boolean startsWith(String prefifix)</td>
<td>判断字符串是否以参数字符串开头</td>
</tr>
<tr>
<td>boolean startsWith(String prefifix, int toffffset)</td>
<td>从指定位置开始是否以参数字符串开头</td>
</tr>
<tr>
<td>boolean endsWith(String suffiffiffix)</td>
<td>判断字符串是否以参数字符串结尾</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean equals(Object anObject)</td>
<td>用于比较字符串内容是否相等并返回</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>用于比较字符串内容是否相等并返回，不考虑大小写，如：’A’和’a’是相等</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>获取调用对象的哈希码值</td>
</tr>
</tbody></table>
<p>案例题目</p>
<p>提示用户从键盘输入用户名和密码信息，若输入”admin”和”123456”则提示“登录成功，欢迎使</p>
<p>用”，否则提示“用户名或密码错误，您还有n次机会”，若用户输入三次后依然错误则提示“账户已</p>
<p>冻结，请联系客服人员！”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">    String user = sc.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">    String password = sc.next();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(user) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功，欢迎使用&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;账户已冻结，请联系客服人员！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名或密码错误，您还有&quot;</span> + (i-<span class="number">1</span>) + <span class="string">&quot;次机会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int indexOf(int ch)</td>
<td>用于返回当前字符串中参数ch指定的字符第一次出现的下标</td>
</tr>
<tr>
<td>int indexOf(int ch, int fromIndex)</td>
<td>用于从fromIndex位置开始查找ch指定的字符</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>在字符串中检索str返回其第一次出现的位置，若找不到返回-1</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>表示从字符串的fromIndex位置开始检索str第一次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(int ch)</td>
<td>用于返回参数ch指定的字符最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(int ch, int fromIndex)</td>
<td>用于从fromIndex位置开始查找ch指定字符出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>返回str指定字符串最后一次出现的下标</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>用于从fromIndex位置开始反向搜索的第一次出现的下标。</td>
</tr>
</tbody></table>
<p>注意：indexOf() 是从左往右第一个，而lastIndexOf() 是从右往左第一个。</p>
<ul>
<li>案例题目</li>
</ul>
<p>编写通用的代码可以查询字符串”Good Good Study, Day Day Up!”中所有”Day”出现的索引位置并打印出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Good Good Study, Day Day Up!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = str.indexOf(<span class="string">&quot;Day&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(i != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i = str.indexOf(<span class="string">&quot;Day&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Good Good Study, Day Day Up!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( (i=str.indexOf(<span class="string">&quot;Day&quot;</span>, i)) != -<span class="number">1</span> )&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i += <span class="string">&quot;Day&quot;</span>.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>方法声明</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>返回字符串中从下标beginIndex（包括）开始到endIndex（不包括）结束的子字符串</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>返回字符串中从下标beginIndex（包括）开始到字符串结尾的子字符串</td>
</tr>
</tbody></table>
<ul>
<li>案例题目</li>
</ul>
<p>提示用户从键盘输入一个字符串和一个字符，输出该字符(不含)后面的所有子字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">String str1 = sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入字符：&quot;</span>);</span><br><span class="line">String str2 = sc.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = str1.indexOf(str2);</span><br><span class="line">String str3 = str1.substring(i+<span class="number">1</span>);</span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式本质就是一个“规则字符串”，可以用于对字符串数据的格式进行验证，以及匹配、查</p>
<p>找、替换等操作。该字符串通常使用^运算符作为开头标志，使用$运算符作为结尾标志，当然也可以省</p>
<p>略。</p>
<p>规则：</p>
<ul>
<li><p>[abc] ：可以出现a、b、c中任意一个字符</p>
</li>
<li><p>[^abc] ：可以出现任何字符，除了a、b、c的任意字符</p>
</li>
<li><p>[a-z] ：可以出现a、b、c、……、z中的任意一个字符</p>
</li>
<li><p>[a-zA-Z0-9] ：可以出现a<del>z、A</del>Z、0~9中任意一个字符</p>
</li>
</ul>
<hr>
<hr>
<ul>
<li><p>. ：任意一个字符（通常不包含换行符）</p>
</li>
<li><p>\d ：任意一个数字字符，相当于[0-9]</p>
</li>
<li><p>\D ：任意一个非数字字符</p>
</li>
<li><p>\s ：空白字符，相当于[\t\n\x0B\f\r]</p>
</li>
<li><p>\S ：非空白字符</p>
</li>
<li><p>\w ：任意一个单词字符，相当于[a-zA-Z_0-9]</p>
</li>
<li><p>\W ：任意一个非单词字符</p>
</li>
</ul>
<hr>
<hr>
<ul>
<li><p>X? ：表示X可以出现一次或一次也没有，也就是0 ~ 1次</p>
</li>
<li><p>X* ：表示X可以出现零次或多次，也就是0 ~ n次</p>
</li>
<li><p>X+ ：表示X可以出现一次或多次，也就是1 ~ n次</p>
</li>
<li><p>X{n} ：表示X可以出现恰好 n 次</p>
</li>
<li><p>X{n，} ：表示X可以出现至少 n 次，也就是&gt;=n次</p>
</li>
<li><p>X{n，m} ：表示X可以出现至少 n 次，但是不超过 m 次，也就是&gt;=n并且&lt;=m次</p>
</li>
</ul>
<p><strong>相关方法：</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>方法说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean matches(String regex)</td>
<td>判断当前正在调用的字符串是否匹配参数指定的正则表达式规则</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">String str = sc.next();</span><br><span class="line"><span class="comment">//规则: 银行卡密码的规则：要求是由6位数字组成。</span></span><br><span class="line">String reg = <span class="string">&quot;\\d&#123;6&#125;&quot;</span>;   </span><br><span class="line"><span class="keyword">if</span>( str.matches(reg) )&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;字符规则正确！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;字符规则错误！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分割和替换：</p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>String[] split(String regex)</td>
<td>参数regex为正则表达式，以regex所表示的字符串为分隔符，将字符串拆分成字符串数组</td>
</tr>
<tr>
<td>String replace(char oldChar, char newChar)</td>
<td>使用参数newChar替换此字符串中出现的所有参数oldChar</td>
</tr>
<tr>
<td>String replaceFirst(String regex, String replacement)</td>
<td>替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>将字符串中匹配正则表达式regex的字符串替换成replacement</td>
</tr>
</tbody></table>
<h1 id="Java核心类库-下"><a href="#Java核心类库-下" class="headerlink" title="Java核心类库(下)"></a>Java核心类库(下)</h1>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>感谢老铁的支持！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="唧唧歪歪 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="唧唧歪歪 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 基础</a>
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/25/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%89%E5%89%91%E5%AE%A2/" rel="prev" title="数据分析与挖掘(数据分析三剑客)">
                  <i class="fa fa-chevron-left"></i> 数据分析与挖掘(数据分析三剑客)
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MzYzOC8zMDExMQ=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唧唧歪歪</span>
</div>
<div class="busuanzi-count">
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
